[assembly: System.CLSCompliantAttribute(true)]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.AcceptanceTesting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Core.Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Hosting.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.PerformanceTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"ReturnToSourceQueue, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.5.2", FrameworkDisplayName=".NET Framework 4.5.2")]
public class static ConfigureHandlerSettings
{
    [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
        "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
        "l over handler creation. Will be removed in version 7.0.0.", true)]
    public static void InitializeHandlerProperty<THandler>(this NServiceBus.EndpointConfiguration config, string property, object value) { }
}
namespace NServiceBus
{
    [System.ObsoleteAttribute("Use the string based overloads. Will be removed in version 7.0.0.", true)]
    public class Address
    {
        public Address() { }
    }
    public enum AddressMode
    {
        Local = 0,
        Remote = 1,
    }
    [System.ObsoleteAttribute("Please use `EndpointConfiguration.ExcludeAssemblies` instead. Will be removed in " +
        "version 7.0.0.", true)]
    public class AllAssemblies
    {
        public AllAssemblies() { }
    }
    public class static AutoSubscribeSettingsExtensions
    {
        public static NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings AutoSubscribe(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static BestPracticesOptionExtensions
    {
        public static void DoNotEnforceBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingReplyContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingSendContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.ISubscribeContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingPublishContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IUnsubscribeContext context) { }
        public static bool IgnoredBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public class static Bus
    {
        [System.ObsoleteAttribute("Please use `Endpoint.Create` instead. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.IStartableBus Create(NServiceBus.EndpointConfiguration configuration) { }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.SendOnly` instead. Will be removed in version 7" +
            ".0.0.", true)]
        public static NServiceBus.IBus CreateSendOnly(NServiceBus.EndpointConfiguration configuration) { }
    }
    [System.ObsoleteAttribute("No longer used, use the new callbacks api described in the version 6 upgrade guid" +
        "e. Will be removed in version 7.0.0.", true)]
    public class BusAsyncResultEventArgs
    {
        public BusAsyncResultEventArgs() { }
    }
    [System.ObsoleteAttribute("Please use `EndpointConfiguration` instead. Will be removed in version 7.0.0.", true)]
    public class BusConfiguration
    {
        public BusConfiguration() { }
    }
    [System.ObsoleteAttribute("Please use `Notifications` instead. Will be removed in version 7.0.0.", true)]
    public class BusNotifications
    {
        public BusNotifications() { }
    }
    [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
    public class CompletionResult
    {
        public CompletionResult() { }
    }
    public class static ConfigurationTimeoutExtensions
    {
        public static void TimeToWaitBeforeTriggeringCriticalErrorOnTimeoutOutages(this NServiceBus.EndpointConfiguration config, System.TimeSpan timeToWait) { }
    }
    [System.ObsoleteAttribute("This is no longer a public API. Will be removed in version 7.0.0.", true)]
    public class Configure
    {
        public Configure() { }
    }
    public class static ConfigureAudit
    {
        public static void AuditProcessedMessagesTo(this NServiceBus.EndpointConfiguration config, string auditQueue, System.Nullable<System.TimeSpan> timeToBeReceived = null) { }
    }
    public class static ConfigureCriticalErrorAction
    {
        public static void DefineCriticalErrorAction(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Func<NServiceBus.ICriticalErrorContext, System.Threading.Tasks.Task> onCriticalError) { }
        [System.ObsoleteAttribute("Please use `ConfigureCriticalErrorAction.DefineCriticalErrorAction(EndpointConfig" +
            "uration, Func<ICriticalErrorContext, Task>)` instead. Will be removed in version" +
            " 7.0.0.", true)]
        public static void DefineCriticalErrorAction(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Action<string, System.Exception> onCriticalError) { }
    }
    public class static ConfigureError
    {
        public static void SendFailedMessagesTo(this NServiceBus.EndpointConfiguration config, string errorQueue) { }
    }
    public class static ConfigureFileShareDataBus
    {
        public static NServiceBus.DataBus.DataBusExtentions<NServiceBus.FileShareDataBus> BasePath(this NServiceBus.DataBus.DataBusExtentions<NServiceBus.FileShareDataBus> config, string basePath) { }
    }
    public class static ConfigureForwarding
    {
        public static void ForwardReceivedMessagesTo(this NServiceBus.EndpointConfiguration config, string address) { }
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class static ConfigureInMemoryFaultManagement
    {
        [System.ObsoleteAttribute("This is no longer supported. If you want full control over what happens when a me" +
            "ssage fails (including retries) override the MoveFaultsToErrorQueue behavior. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public static void DiscardFailedMessagesInsteadOfSendingToErrorQueue(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static ConfigureLicenseExtensions
    {
        public static void License(this NServiceBus.EndpointConfiguration config, string licenseText) { }
        public static void LicensePath(this NServiceBus.EndpointConfiguration config, string licenseFile) { }
    }
    public class static ConfigurePurging
    {
        public static void PurgeOnStartup(this NServiceBus.EndpointConfiguration config, bool value) { }
        [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
        public static bool PurgeOnStartup(this NServiceBus.Configure config) { }
    }
    public class static ConfigureQueueCreation
    {
        [System.ObsoleteAttribute("Please use `CreateQueues` instead. Will be removed in version 7.0.0.", true)]
        public static bool CreateQueues(this NServiceBus.Configure config) { }
        public static bool CreateQueues(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static void DoNotCreateQueues(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static ConfigureRijndaelEncryptionService
    {
        public static void RegisterEncryptionService(this NServiceBus.EndpointConfiguration config, System.Func<NServiceBus.IEncryptionService> func) { }
        [System.ObsoleteAttribute(@"It is no longer possible to access the builder to create an encryption service. If container access is required use the container directly in the factory. Please use `RegisterEncryptionService(this EndpointConfiguration config, Func<IEncryptionService> func)` instead. Will be removed in version 7.0.0.", true)]
        public static void RegisterEncryptionService(this NServiceBus.EndpointConfiguration config, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.IEncryptionService> func) { }
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config) { }
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config, string encryptionKeyIdentifier, byte[] encryptionKey, System.Collections.Generic.IList<byte[]> decryptionKeys = null) { }
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config, string encryptionKeyIdentifier, System.Collections.Generic.IDictionary<string, byte[]> keys, System.Collections.Generic.IList<byte[]> decryptionKeys = null) { }
    }
    public class static ConfigureTransportConnectionString
    {
        [System.ObsoleteAttribute("Not available any more. Will be removed in version 7.0.0.", true)]
        public static string TransportConnectionString(this NServiceBus.Configure config) { }
    }
    public class static ConnectorContextExtensions
    {
        public static NServiceBus.Pipeline.IAuditContext CreateAuditContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IAuditContext> forkConnector, NServiceBus.Transports.OutgoingMessage message, string auditAddress, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IBatchDispatchContext CreateBatchDispatchContext(this NServiceBus.Pipeline.StageForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IBatchDispatchContext> stageForkConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> transportOperations, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IDispatchContext CreateDispatchContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IBatchDispatchContext, NServiceBus.Pipeline.IDispatchContext> stageConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> transportOperations, NServiceBus.Pipeline.IBatchDispatchContext sourceContext) { }
        public static NServiceBus.Pipeline.IDispatchContext CreateDispatchContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IRoutingContext, NServiceBus.Pipeline.IDispatchContext> stageConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> transportOperations, NServiceBus.Pipeline.IRoutingContext sourceContext) { }
        public static NServiceBus.Pipeline.IFaultContext CreateFaultContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IFaultContext> forkConnector, NServiceBus.Pipeline.ITransportReceiveContext sourceContext, NServiceBus.Transports.OutgoingMessage outgoingMessage, string errorQueueAddress, System.Exception exception) { }
        public static NServiceBus.Pipeline.IForwardingContext CreateForwardingContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IForwardingContext> forwardingContext, NServiceBus.Transports.OutgoingMessage message, string forwardingAddress, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingLogicalMessageContext CreateIncomingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IIncomingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.LogicalMessage logicalMessage, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(this NServiceBus.Pipeline.StageForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IBatchDispatchContext> stageForkConnector, NServiceBus.Transports.IncomingMessage incomingMessage, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext> stageConnector, NServiceBus.Transports.IncomingMessage incomingMessage, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IInvokeHandlerContext CreateInvokeHandlerContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IIncomingLogicalMessageContext, NServiceBus.Pipeline.IInvokeHandlerContext> stageConnector, NServiceBus.Pipeline.MessageHandler messageHandler, NServiceBus.Persistence.CompletableSynchronizedStorageSession storageSession, NServiceBus.Pipeline.IIncomingLogicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingPublishContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingPublishContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingReplyContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingReplyContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingSendContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingSendContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingPhysicalMessageContext CreateOutgoingPhysicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingLogicalMessageContext, NServiceBus.Pipeline.IOutgoingPhysicalMessageContext> stageConnector, byte[] messageBody, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingLogicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IRoutingContext> forkConnector, NServiceBus.Transports.OutgoingMessage outgoingMessage, string localAddress, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IForwardingContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transports.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy, NServiceBus.Pipeline.IForwardingContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IAuditContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transports.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy, NServiceBus.Pipeline.IAuditContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IFaultContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transports.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy, NServiceBus.Pipeline.IFaultContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingPhysicalMessageContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transports.OutgoingMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingPhysicalMessageContext sourceContext) { }
    }
    public abstract class ContainSagaData : NServiceBus.IContainSagaData
    {
        protected ContainSagaData() { }
        public virtual System.Guid Id { get; set; }
        public virtual string OriginalMessageId { get; set; }
        public virtual string Originator { get; set; }
    }
    public class static ContentTypes
    {
        public const string Json = "application/json";
        public const string Xml = "text/xml";
    }
    public class Conventions
    {
        public Conventions() { }
        public void AddSystemMessagesConventions(System.Func<System.Type, bool> definesMessageType) { }
        [System.ObsoleteAttribute("No longer an extension point. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan GetTimeToBeReceived(System.Type messageType) { }
        public bool IsCommandType(System.Type t) { }
        public bool IsDataBusProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEncryptedProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEventType(System.Type t) { }
        [System.ObsoleteAttribute("No longer an extension point. Will be removed in version 7.0.0.", true)]
        public static bool IsExpressMessageType(System.Type t) { }
        public bool IsInSystemConventionList(System.Type t) { }
        public bool IsMessageType(System.Type t) { }
    }
    public class ConventionsBuilder : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public ConventionsBuilder(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.Conventions Conventions { get; }
        public NServiceBus.ConventionsBuilder DefiningCommandsAs(System.Func<System.Type, bool> definesCommandType) { }
        public NServiceBus.ConventionsBuilder DefiningDataBusPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesDataBusProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEncryptedPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesEncryptedProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEventsAs(System.Func<System.Type, bool> definesEventType) { }
        public NServiceBus.ConventionsBuilder DefiningMessagesAs(System.Func<System.Type, bool> definesMessageType) { }
    }
    public class static CorrelationContextExtensions
    {
        public static string GetCorrelationId(this NServiceBus.SendOptions options) { }
        public static string GetCorrelationId(this NServiceBus.ReplyOptions options) { }
        public static void SetCorrelationId(this NServiceBus.SendOptions options, string correlationId) { }
        public static void SetCorrelationId(this NServiceBus.ReplyOptions options, string correlationId) { }
    }
    public class CriticalError
    {
        public CriticalError(System.Func<NServiceBus.ICriticalErrorContext, System.Threading.Tasks.Task> onCriticalErrorAction) { }
        public virtual void Raise(string errorMessage, System.Exception exception) { }
    }
    public class CriticalErrorContext : NServiceBus.ICriticalErrorContext
    {
        public CriticalErrorContext(System.Func<System.Threading.Tasks.Task> stop, string error, System.Exception exception) { }
        public string Error { get; }
        public System.Exception Exception { get; }
        public System.Func<System.Threading.Tasks.Task> Stop { get; }
    }
    public class static CriticalTimeMonitoringConfig
    {
        public static void EnableCriticalTimePerformanceCounter(this NServiceBus.EndpointConfiguration config) { }
    }
    public class DataBusProperty<T> : NServiceBus.IDataBusProperty, System.Runtime.Serialization.ISerializable
        where T :  class
    {
        public DataBusProperty(T value) { }
        protected DataBusProperty(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public bool HasValue { get; set; }
        public string Key { get; set; }
        public T Value { get; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public object GetValue() { }
        public void SetValue(object valueToSet) { }
    }
    public class static DateTimeExtensions
    {
        public static System.DateTime ToUtcDateTime(string wireFormattedString) { }
        public static string ToWireFormattedString(System.DateTime dateTime) { }
    }
    public class static DelayedDeliveryOptionExtensions
    {
        public static void DelayDeliveryWith(this NServiceBus.SendOptions options, System.TimeSpan delay) { }
        public static void DoNotDeliverBefore(this NServiceBus.SendOptions options, System.DateTimeOffset at) { }
        public static System.Nullable<System.DateTimeOffset> GetDeliveryDate(this NServiceBus.SendOptions options) { }
        public static System.Nullable<System.TimeSpan> GetDeliveryDelay(this NServiceBus.SendOptions options) { }
    }
    public enum DependencyLifecycle
    {
        SingleInstance = 0,
        InstancePerUnitOfWork = 1,
        InstancePerCall = 2,
    }
    public class static DurableMessagesConfig
    {
        public static void DisableDurableMessages(this NServiceBus.EndpointConfiguration config) { }
        public static bool DurableMessagesEnabled(this NServiceBus.Settings.ReadOnlySettings settings) { }
        [System.ObsoleteAttribute("Please use `DurableMessagesEnabled` instead. Will be removed in version 7.0.0.", true)]
        public static bool DurableMessagesEnabled(this NServiceBus.Configure config) { }
        public static void EnableDurableMessages(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static DurableMessagesConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningExpressMessagesAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, bool> definesExpressMessageType) { }
    }
    public class EncryptedValue
    {
        public EncryptedValue() { }
        public string Base64Iv { get; set; }
        public string EncryptedBase64Value { get; set; }
    }
    public class static Endpoint
    {
        public static System.Threading.Tasks.Task<NServiceBus.IStartableEndpoint> Create(NServiceBus.EndpointConfiguration configuration) { }
        public static async System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start(NServiceBus.EndpointConfiguration configuration) { }
    }
    public class EndpointConfiguration : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public EndpointConfiguration(string endpointName) { }
        public NServiceBus.Notifications Notifications { get; }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.AddHeaderToAllOutgoingMessages(string key,strin" +
            "g value)` instead. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.ExcludeAssemblies` instead. Will be removed in " +
            "version 7.0.0.", true)]
        public void AssembliesToScan(System.Collections.Generic.IEnumerable<System.Reflection.Assembly> assemblies) { }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.ExcludeAssemblies` instead. Will be removed in " +
            "version 7.0.0.", true)]
        public void AssembliesToScan(params System.Reflection.Assembly[] assemblies) { }
        public NServiceBus.ConventionsBuilder Conventions() { }
        public void CustomConfigurationSource(NServiceBus.Config.ConfigurationSource.IConfigurationSource configurationSource) { }
        [System.ObsoleteAttribute("Endpoint name is now a mandatory constructor argument on EndpointConfiguration. W" +
            "ill be removed in version 7.0.0.", true)]
        public void EndpointName(string name) { }
        public void ExcludeAssemblies(params string[] assemblies) { }
        public void ExcludeTypes(params System.Type[] types) { }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.UseTransport<T>().AddAddressTranslationRule(Fun" +
            "c<LogicalAddress, string> rule)` instead. Will be removed in version 7.0.0.", true)]
        public void OverrideLocalAddress(string queue) { }
        public void OverridePublicReturnAddress(string address) { }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.OverridePublicReturnAddress(string address)` in" +
            "stead. Will be removed in version 7.0.0.", true)]
        public void OverridePublicReturnAddress(NServiceBus.Address address) { }
        public void RegisterComponents(System.Action<NServiceBus.ObjectBuilder.IConfigureComponents> registration) { }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.ExcludeAssemblies` instead. Will be removed in " +
            "version 7.0.0.", true)]
        public void ScanAssembliesInDirectory(string probeDirectory) { }
        public void ScanAssembliesInNestedDirectories() { }
        public void SendOnly() { }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.ExcludeTypes` instead. Will be removed in versi" +
            "on 7.0.0.", true)]
        public void TypesToScan(System.Collections.Generic.IEnumerable<System.Type> typesToScan) { }
        public void UseContainer<T>(System.Action<NServiceBus.Container.ContainerCustomizations> customizations = null)
            where T : NServiceBus.Container.ContainerDefinition, new () { }
        public void UseContainer(System.Type definitionType) { }
        public void UseContainer(NServiceBus.ObjectBuilder.Common.IContainer builder) { }
    }
    public class static EndpointConfigurationExtensions
    {
        public static void DisableFeature<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void DisableFeature(this NServiceBus.EndpointConfiguration config, System.Type featureType) { }
        public static void EnableFeature<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void EnableFeature(this NServiceBus.EndpointConfiguration config, System.Type featureType) { }
    }
    public class static EndpointInstanceExtensions
    {
        public static NServiceBus.Routing.EndpointInstance AtMachine(this NServiceBus.Routing.EndpointInstance instance, string machineName) { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class ExpressAttribute : System.Attribute
    {
        public ExpressAttribute() { }
    }
    [System.ObsoleteAttribute("Headers are not managed via the send, reply and publishoptions. Will be removed i" +
        "n version 7.0.0.", true)]
    public class static ExtensionMethods
    {
        [System.ObsoleteAttribute("Use a incoming behavior to get access to the current message. Will be removed in " +
            "version 7.0.0.", true)]
        public static object CurrentMessageBeingHandled { get; set; }
        [System.ObsoleteAttribute("Headers are not \'set\' only on the outgoing pipeline. Will be removed in version 7" +
            ".0.0.", true)]
        public static string GetMessageHeader(this NServiceBus.IBus bus, object msg, string key) { }
        [System.ObsoleteAttribute("Headers can be set using the ``.SetHeader` method on the context object passed in" +
            "to the behavior or mutator. Will be removed in version 7.0.0.", true)]
        public static void SetMessageHeader(this NServiceBus.IBus bus, object msg, string key, string value) { }
    }
    public class static FileBasedRoutingConfigurationExtensions
    {
        public static NServiceBus.FileRoutingTableSettings DistributeMessagesUsingFileBasedEndpointInstanceMapping(this NServiceBus.RoutingMappingSettings config, string filePath) { }
    }
    public class FileRoutingTableSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public FileRoutingTableSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.FileRoutingTableSettings MaxLoadAttempts(int maxLoadAttempts) { }
        public NServiceBus.FileRoutingTableSettings RefreshInterval(System.TimeSpan refreshInterval) { }
    }
    public class FileShareDataBus : NServiceBus.DataBus.DataBusDefinition
    {
        public FileShareDataBus() { }
        protected internal override System.Type ProvidedByFeature() { }
    }
    [System.ObsoleteAttribute("Please use `EndpointConfiguration.ExecuteTheseHandlersFirst` instead. Will be rem" +
        "oved in version 7.0.0.", true)]
    public class First<T>
    {
        public First() { }
    }
    public class static HeaderOptionExtensions
    {
        public static System.Collections.Generic.IReadOnlyDictionary<string, string> GetHeaders(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void SetHeader(this NServiceBus.Extensibility.ExtendableOptions options, string key, string value) { }
    }
    public class static Headers
    {
        public const string ContentType = "NServiceBus.ContentType";
        public const string ControlMessageHeader = "NServiceBus.ControlMessage";
        public const string ConversationId = "NServiceBus.ConversationId";
        public const string CorrelationId = "NServiceBus.CorrelationId";
        public const string DestinationSites = "NServiceBus.DestinationSites";
        public const string EnclosedMessageTypes = "NServiceBus.EnclosedMessageTypes";
        public const string FLRetries = "NServiceBus.FLRetries";
        public const string HasLicenseExpired = "$.diagnostics.license.expired";
        public const string HeaderName = "Header";
        public const string HostDisplayName = "$.diagnostics.hostdisplayname";
        public const string HostId = "$.diagnostics.hostid";
        public const string HttpFrom = "NServiceBus.From";
        public const string HttpTo = "NServiceBus.To";
        public const string IsDeferredMessage = "NServiceBus.IsDeferredMessage";
        public const string IsSagaTimeoutMessage = "NServiceBus.IsSagaTimeoutMessage";
        public const string MessageId = "NServiceBus.MessageId";
        public const string MessageIntent = "NServiceBus.MessageIntent";
        public const string NonDurableMessage = "NServiceBus.NonDurableMessage";
        public const string NServiceBusVersion = "NServiceBus.Version";
        public const string OriginatingAddress = "NServiceBus.OriginatingAddress";
        public const string OriginatingEndpoint = "NServiceBus.OriginatingEndpoint";
        public const string OriginatingHostId = "$.diagnostics.originating.hostid";
        public const string OriginatingMachine = "NServiceBus.OriginatingMachine";
        public const string OriginatingSagaId = "NServiceBus.OriginatingSagaId";
        public const string OriginatingSagaType = "NServiceBus.OriginatingSagaType";
        public const string OriginatingSite = "NServiceBus.OriginatingSite";
        public const string ProcessingEnded = "NServiceBus.ProcessingEnded";
        public const string ProcessingEndpoint = "NServiceBus.ProcessingEndpoint";
        public const string ProcessingMachine = "NServiceBus.ProcessingMachine";
        public const string ProcessingStarted = "NServiceBus.ProcessingStarted";
        public const string RelatedTo = "NServiceBus.RelatedTo";
        public const string ReplyToAddress = "NServiceBus.ReplyToAddress";
        public const string Retries = "NServiceBus.Retries";
        public const string ReturnMessageErrorCodeHeader = "NServiceBus.ReturnMessage.ErrorCode";
        public const string RijndaelKeyIdentifier = "NServiceBus.RijndaelKeyIdentifier";
        public const string RouteTo = "NServiceBus.Header.RouteTo";
        public const string SagaId = "NServiceBus.SagaId";
        public const string SagaType = "NServiceBus.SagaType";
        public const string SubscriberEndpoint = "NServiceBus.SubscriberEndpoint";
        public const string SubscriberTransportAddress = "NServiceBus.SubscriberAddress";
        public const string SubscriptionMessageType = "SubscriptionMessageType";
        public const string TimeSent = "NServiceBus.TimeSent";
        public const string TimeToBeReceived = "NServiceBus.TimeToBeReceived";
        [System.ObsoleteAttribute("The WinIdName header is no longer attached to outgoing message to avoid passing s" +
            "ecurity related information on the wire. Should you rely on the header being pre" +
            "sent you can add a message mutator that sets it. Will be removed in version 7.0." +
            "0.", true)]
        public const string WindowsIdentityName = "WinIdName";
    }
    public class static HostInfoConfigurationExtensions
    {
        public static NServiceBus.HostInfoSettings UniquelyIdentifyRunningInstance(this NServiceBus.EndpointConfiguration config) { }
    }
    public class HostInfoSettings
    {
        public NServiceBus.HostInfoSettings UsingCustomDisplayName(string displayName) { }
        public NServiceBus.HostInfoSettings UsingCustomIdentifier(System.Guid id) { }
        public NServiceBus.HostInfoSettings UsingInstalledFilePath() { }
        public NServiceBus.HostInfoSettings UsingNames(string instanceName, string hostName) { }
    }
    public interface IAmStartedByMessages<T> : NServiceBus.IHandleMessages<T> { }
    [System.ObsoleteAttribute("Please use `config.UseTransport<MsmqTransport>().SubscriptionAuthorizer(Authorize" +
        "r);` instead. Will be removed in version 7.0.0.", true)]
    public interface IAuthorizeSubscriptions { }
    [System.ObsoleteAttribute(@"IHandleMessages<T> now exposes the IMessageHandlerContext parameter. Use this to access what used to be available in the IBus interface. Use the provided context in extension points like message handlers or IEndpointInstance when outside the message processing pipeline. Will be removed in version 7.0.0.", true)]
    public interface IBus { }
    public class static IBusExtensions
    {
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.DoNotContinueDispatchingCurrentMessageToHandlers()` p" +
            "rovided to message handlers instead. Will be removed in version 7.0.0.", true)]
        public static void DoNotContinueDispatchingCurrentMessageToHandlers(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.ForwardCurrentMessageTo(string destination)` provided" +
            " to message handlers instead. Will be removed in version 7.0.0.", true)]
        public static void ForwardCurrentMessageTo(this NServiceBus.IBus bus, string destination) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.HandleCurrentMessageLater()` provided to message hand" +
            "lers instead. Will be removed in version 7.0.0.", true)]
        public static void HandleCurrentMessageLater(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.Reply(object message)` provided to message handlers i" +
            "nstead. Will be removed in version 7.0.0.", true)]
        public static void Reply(this NServiceBus.IBus bus, object message) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.Reply<T>(Action<T> messageConstructor)` provided to m" +
            "essage handlers instead. Will be removed in version 7.0.0.", true)]
        public static void Reply<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.SendLocal(object message)` provided to message handle" +
            "rs instead. Will be removed in version 7.0.0.", true)]
        public static void SendLocal(this NServiceBus.IBus bus, object message) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.SendLocal<T>(Action<T> messageConstructor)` provided " +
            "to message handlers instead. Will be removed in version 7.0.0.", true)]
        public static void SendLocal<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `Subscribe(Type messageType)` instead. Will be removed in version 7.0." +
            "0.", true)]
        public static void Subscribe(this NServiceBus.IBus bus, System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `Subscribe<T>()` instead. Will be removed in version 7.0.0.", true)]
        public static void Subscribe<T>(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Please use `Unsubscribe(Type messageType)` instead. Will be removed in version 7." +
            "0.0.", true)]
        public static void Unsubscribe(this NServiceBus.IBus bus, System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `Unsubscribe<T>()` instead. Will be removed in version 7.0.0.", true)]
        public static void Unsubscribe<T>(this NServiceBus.IBus bus) { }
    }
    [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
    public interface ICallback { }
    public interface ICommand : NServiceBus.IMessage { }
    public interface IConfigureHowToFindSagaWithMessage
    {
        void ConfigureMapping<TSagaEntity, TMessage>(System.Linq.Expressions.Expression<System.Func<TSagaEntity, object>> sagaEntityProperty, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty)
            where TSagaEntity : NServiceBus.IContainSagaData
        ;
    }
    public interface IContainSagaData
    {
        System.Guid Id { get; set; }
        string OriginalMessageId { get; set; }
        string Originator { get; set; }
    }
    public interface ICriticalErrorContext
    {
        string Error { get; }
        System.Exception Exception { get; }
        System.Func<System.Threading.Tasks.Task> Stop { get; }
    }
    public interface IDataBusProperty
    {
        bool HasValue { get; set; }
        string Key { get; set; }
        object GetValue();
        void SetValue(object value);
    }
    public interface IEncryptionService
    {
        string Decrypt(NServiceBus.EncryptedValue encryptedValue, NServiceBus.Pipeline.IIncomingLogicalMessageContext context);
        NServiceBus.EncryptedValue Encrypt(string value, NServiceBus.Pipeline.IOutgoingLogicalMessageContext context);
    }
    public interface IEndpointInstance : NServiceBus.IMessageSession
    {
        System.Threading.Tasks.Task Stop();
    }
    public interface IEvent : NServiceBus.IMessage { }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public interface IExcludesBuilder { }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface IHandleMessages<T>
    {
        System.Threading.Tasks.Task Handle(T message, NServiceBus.IMessageHandlerContext context);
    }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface IHandleTimeouts<T>
    {
        System.Threading.Tasks.Task Timeout(T state, NServiceBus.IMessageHandlerContext context);
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public interface IIncludesBuilder { }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public interface IManageMessageHeaders { }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface IMessage { }
    [System.ObsoleteAttribute("Use `IMessageHandlerContext` provided to message handlers instead. Will be remove" +
        "d in version 7.0.0.", true)]
    public interface IMessageContext { }
    public interface IMessageCreator
    {
        T CreateInstance<T>();
        T CreateInstance<T>(System.Action<T> action);
        object CreateInstance(System.Type messageType);
    }
    public interface IMessageHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext
    {
        NServiceBus.Persistence.SynchronizedStorageSession SynchronizedStorageSession { get; }
        void DoNotContinueDispatchingCurrentMessageToHandlers();
        System.Threading.Tasks.Task HandleCurrentMessageLater();
    }
    public interface IMessageProcessingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext
    {
        System.Collections.Generic.IReadOnlyDictionary<string, string> MessageHeaders { get; }
        string MessageId { get; }
        string ReplyToAddress { get; }
        System.Threading.Tasks.Task ForwardCurrentMessageTo(string destination);
        System.Threading.Tasks.Task Reply(object message, NServiceBus.ReplyOptions options);
        System.Threading.Tasks.Task Reply<T>(System.Action<T> messageConstructor, NServiceBus.ReplyOptions options);
    }
    public class static IMessageProcessingContextExtensions
    {
        public static System.Threading.Tasks.Task Reply(this NServiceBus.IMessageProcessingContext context, object message) { }
        public static System.Threading.Tasks.Task Reply<T>(this NServiceBus.IMessageProcessingContext context, System.Action<T> messageConstructor) { }
    }
    public interface IMessageSession
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.SubscribeOptions options);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.UnsubscribeOptions options);
    }
    public class static IMessageSessionExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IMessageSession session) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IMessageSession session, string destination, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IMessageSession session, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Subscribe(this NServiceBus.IMessageSession session, System.Type messageType) { }
        public static System.Threading.Tasks.Task Subscribe<T>(this NServiceBus.IMessageSession session) { }
        public static System.Threading.Tasks.Task Unsubscribe(this NServiceBus.IMessageSession session, System.Type messageType) { }
        public static System.Threading.Tasks.Task Unsubscribe<T>(this NServiceBus.IMessageSession session) { }
    }
    public class static ImmediateDispatchOptionExtensions
    {
        public static bool RequiredImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void RequireImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface INeedInitialization
    {
        void Customize(NServiceBus.EndpointConfiguration configuration);
    }
    public class InMemoryPersistence : NServiceBus.Persistence.PersistenceDefinition { }
    public class static InstallConfigExtensions
    {
        public static void EnableInstallers(this NServiceBus.EndpointConfiguration config, string username = null) { }
    }
    public interface IPipelineContext : NServiceBus.Extensibility.IExtendable
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
    }
    public class static IPipelineContextExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IPipelineContext context) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IPipelineContext context, string destination, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IPipelineContext context, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
    }
    [System.ObsoleteAttribute("Use IEndpointInstance to create sending session. Will be removed in version 7.0.0" +
        ".", true)]
    public interface ISendOnlyBus : System.IDisposable { }
    [System.ObsoleteAttribute("Please use `EndpointConfiguration.ExecuteTheseHandlersFirst` instead. Will be rem" +
        "oved in version 7.0.0.", true)]
    public interface ISpecifyMessageHandlerOrdering { }
    [System.ObsoleteAttribute("Please use `IStartableEndpoint` instead. Will be removed in version 7.0.0.", true)]
    public interface IStartableBus : NServiceBus.IBus
    {
        [System.ObsoleteAttribute("Please use `IStartableEndpoint` instead. Will be removed in version 7.0.0.", true)]
        NServiceBus.IBus Start();
    }
    public interface IStartableEndpoint
    {
        System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start();
    }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface IWantToRunBeforeConfigurationIsFinalized
    {
        void Run(NServiceBus.Settings.SettingsHolder settings);
    }
    [System.ObsoleteAttribute(@"`IWantToRunWhenBusStartsAndStops` has been moved to the host implementations and renamed. If you're self-hosting, instead of using this interface, you can call any startup code right before `Endpoint.Create` or any cleanup code right after `Endpoint.Stop`. When using either NServiceBus.Host or NServiceBus.Host.AzureCloudService, use the host's interface `IWantToRunWhenEndpointStartsAndStops` instead. Will be removed in version 7.0.0.", true)]
    public interface IWantToRunWhenBusStartsAndStops { }
    public class JsonSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public JsonSerializer() { }
        public override System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public class static JsonSerializerConfigurationExtensions
    {
        public static void Encoding(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.JsonSerializer> config, System.Text.Encoding encoding) { }
    }
    public class static LoadMessageHandlersExtentions
    {
        public static void ExecuteTheseHandlersFirst(this NServiceBus.EndpointConfiguration config, System.Collections.Generic.IEnumerable<System.Type> handlerTypes) { }
        public static void ExecuteTheseHandlersFirst(this NServiceBus.EndpointConfiguration config, params System.Type[] handlerTypes) { }
        [System.ObsoleteAttribute("Please use `ExecuteTheseHandlersFirst` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static void LoadMessageHandlers<TFirst>(this NServiceBus.EndpointConfiguration config) { }
        [System.ObsoleteAttribute("Please use `ExecuteTheseHandlersFirst` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static void LoadMessageHandlers<T>(this NServiceBus.EndpointConfiguration config, NServiceBus.First<T> order) { }
    }
    public sealed class LogicalAddress
    {
        public LogicalAddress(NServiceBus.Routing.EndpointInstance endpointInstance, [JetBrains.Annotations.NotNullAttribute()] string qualifier) { }
        public LogicalAddress(NServiceBus.Routing.EndpointInstance endpointInstance) { }
        public NServiceBus.Routing.EndpointInstance EndpointInstance { get; }
        public string Qualifier { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class MessageDeserializationException : System.Runtime.Serialization.SerializationException
    {
        public MessageDeserializationException(string message) { }
        public MessageDeserializationException(string transportMessageId, System.Exception innerException) { }
        protected MessageDeserializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static MessageDrivenSubscriptionsConfigExtensions
    {
        public static void SubscriptionAuthorizer(this NServiceBus.TransportExtensions transportExtensions, System.Func<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, bool> authorizer) { }
    }
    public class static MessageIdExtensions
    {
        public static string GetMessageId(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void SetMessageId(this NServiceBus.Extensibility.ExtendableOptions options, string messageId) { }
    }
    public enum MessageIntentEnum
    {
        Send = 1,
        Publish = 2,
        Subscribe = 3,
        Unsubscribe = 4,
        Reply = 5,
    }
    public class static MessageProcessingOptimizationExtensions
    {
        public static void LimitMessageProcessingConcurrencyTo(this NServiceBus.EndpointConfiguration config, int maxConcurrency) { }
    }
    public class static MsmqConfigurationExtensions
    {
        public static NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> ApplyLabelToMessages(this NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> transportExtensions, System.Func<System.Collections.Generic.IReadOnlyDictionary<string, string>, string> labelGenerator) { }
        public static NServiceBus.FileRoutingTableSettings DistributeMessagesUsingFileBasedEndpointInstanceMapping(this NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> config, string filePath) { }
        public static NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> TransactionScopeOptions(this NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> transportExtensions, System.Nullable<System.TimeSpan> timeout = null, System.Nullable<System.Transactions.IsolationLevel> isolationLevel = null) { }
    }
    public class MsmqTransport : NServiceBus.Transports.TransportDefinition
    {
        public MsmqTransport() { }
        public override string ExampleConnectionStringForErrorMessage { get; }
        public override bool RequiresConnectionString { get; }
        protected internal override NServiceBus.Transports.TransportInfrastructure Initialize(NServiceBus.Settings.SettingsHolder settings, string connectionString) { }
    }
    public class NonDurableDelivery : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public NonDurableDelivery() { }
    }
    public class Notifications
    {
        public Notifications() { }
        public NServiceBus.Faults.ErrorsNotifications Errors { get; }
        [System.ObsoleteAttribute("For performance reasons it is no longer possible to instrument the pipeline execu" +
            "tion. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PipelineNotifications Pipeline { get; }
    }
    [System.ObsoleteAttribute("Please use `EndpointConfiguration.ExecuteTheseHandlersFirst` instead. Will be rem" +
        "oved in version 7.0.0.", true)]
    public class Order
    {
        public Order() { }
    }
    public class static OutboxConfigExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings EnableOutbox(this NServiceBus.EndpointConfiguration config) { }
    }
    public class PendingTransportOperations
    {
        public PendingTransportOperations() { }
        public bool HasOperations { get; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> Operations { get; }
        public void Add(NServiceBus.Transports.TransportOperation transportOperation) { }
        public void AddRange(System.Collections.Generic.IEnumerable<NServiceBus.Transports.TransportOperation> transportOperations) { }
    }
    public class static PersistenceConfig
    {
        public static NServiceBus.PersistenceExtentions<T> UsePersistence<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition { }
        public static NServiceBus.PersistenceExtentions<T, S> UsePersistence<T, S>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition
            where S : NServiceBus.Persistence.StorageType { }
        public static NServiceBus.PersistenceExtentions UsePersistence(this NServiceBus.EndpointConfiguration config, System.Type definitionType) { }
    }
    public class PersistenceExtentions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public PersistenceExtentions(System.Type definitionType, NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
        [System.ObsoleteAttribute("Please use `UsePersistence<T, S>()` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PersistenceExtentions For(params NServiceBus.Persistence.Storage[] specificStorages) { }
    }
    public class PersistenceExtentions<T> : NServiceBus.PersistenceExtentions
        where T : NServiceBus.Persistence.PersistenceDefinition
    {
        public PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings) { }
        protected PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
        [System.ObsoleteAttribute("Please use `UsePersistence<T, S>()` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PersistenceExtentions<T> For(params NServiceBus.Persistence.Storage[] specificStorages) { }
    }
    public class PersistenceExtentions<T, S> : NServiceBus.PersistenceExtentions<T>
        where T : NServiceBus.Persistence.PersistenceDefinition
        where S : NServiceBus.Persistence.StorageType
    {
        public PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    [System.ObsoleteAttribute("For performance reasons it is no longer possible to instrument the pipeline execu" +
        "tion. Will be removed in version 7.0.0.", true)]
    public class PipelineNotifications
    {
        public PipelineNotifications() { }
    }
    public class PublishOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public PublishOptions() { }
    }
    public class ReplyOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public ReplyOptions() { }
    }
    public class RoutingMappingSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.Routing.UnicastRoutingTable Logical { get; }
        public NServiceBus.Routing.EndpointInstances Physical { get; }
        public NServiceBus.Routing.MessageDrivenSubscriptions.Publishers Publishers { get; }
        public void SetMessageDistributionStrategy(NServiceBus.Routing.DistributionStrategy distributionStrategy, System.Func<System.Type, bool> typeMatchingRule) { }
    }
    public class static RoutingOptionExtensions
    {
        public static string GetDestination(this NServiceBus.ReplyOptions options) { }
        public static string GetDestination(this NServiceBus.SendOptions options) { }
        public static string GetReplyToRoute(this NServiceBus.ReplyOptions options) { }
        public static string GetReplyToRoute(this NServiceBus.SendOptions options) { }
        public static string GetRouteToSpecificInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToAnyInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToAnyInstance(this NServiceBus.ReplyOptions options) { }
        public static bool IsRoutingReplyToThisInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToThisInstance(this NServiceBus.ReplyOptions options) { }
        public static bool IsRoutingToThisEndpoint(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingToThisInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyTo(this NServiceBus.ReplyOptions options, string address) { }
        public static void RouteReplyTo(this NServiceBus.SendOptions options, string address) { }
        public static void RouteReplyToAnyInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyToAnyInstance(this NServiceBus.ReplyOptions options) { }
        public static void RouteReplyToThisInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyToThisInstance(this NServiceBus.ReplyOptions options) { }
        public static void RouteToSpecificInstance(this NServiceBus.SendOptions options, string instanceId) { }
        public static void RouteToThisEndpoint(this NServiceBus.SendOptions options) { }
        public static void RouteToThisInstance(this NServiceBus.SendOptions options) { }
        public static void SetDestination(this NServiceBus.SendOptions options, string destination) { }
        public static void SetDestination(this NServiceBus.ReplyOptions options, string destination) { }
    }
    public class static RoutingSettingsExtensions
    {
        public static NServiceBus.UnicastRoutingSettings UnicastRouting(this NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings config) { }
    }
    public abstract class Saga
    {
        protected Saga() { }
        public bool Completed { get; }
        public NServiceBus.IContainSagaData Entity { get; set; }
        protected internal abstract void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
        protected void MarkAsComplete() { }
        protected System.Threading.Tasks.Task ReplyToOriginator(NServiceBus.IMessageHandlerContext context, object message) { }
        [System.ObsoleteAttribute("Please use `ReplyToOriginator(IMessageHandlerContext, object)` instead. Will be r" +
            "emoved in version 7.0.0.", true)]
        protected void ReplyToOriginator(object message) { }
        [System.ObsoleteAttribute("Construct the message and pass it to the non Action overload. Please use `ReplyTo" +
            "Originator(IMessageHandlerContext, object)` instead. Will be removed in version " +
            "7.0.0.", true)]
        protected virtual void ReplyToOriginator<TMessage>(System.Action<TMessage> messageConstructor) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTime at)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
        [System.ObsoleteAttribute("Please use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, DateTime)" +
            "` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at) { }
        [System.ObsoleteAttribute("Construct the message and pass it to the non Action overload. Please use `Request" +
            "Timeout<TTimeoutMessageType>(IMessageHandlerContext DateTime, TTimeoutMessageTyp" +
            "e)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at, System.Action<TTimeoutMessageType> action) { }
        [System.ObsoleteAttribute("Please use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, DateTime," +
            " TTimeoutMessageType)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        [System.ObsoleteAttribute("Please use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan)" +
            "` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within) { }
        [System.ObsoleteAttribute("Construct the message and pass it to the non Action overload. Please use `Saga.Re" +
            "questTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan, TTimeoutMess" +
            "ageType)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within, System.Action<TTimeoutMessageType> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan," +
            " TTimeoutMessageType)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
    }
    public abstract class Saga<TSagaData> : NServiceBus.Saga
        where TSagaData : NServiceBus.IContainSagaData, new ()
    {
        protected Saga() { }
        public TSagaData Data { get; set; }
        protected internal override void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration) { }
        protected abstract void ConfigureHowToFindSaga(NServiceBus.SagaPropertyMapper<TSagaData> mapper);
    }
    public class SagaPropertyMapper<TSagaData>
        where TSagaData : NServiceBus.IContainSagaData
    {
        public NServiceBus.ToSagaExpression<TSagaData, TMessage> ConfigureMapping<TMessage>(System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
    }
    public class static ScaleOutExtentions
    {
        public static NServiceBus.Settings.ScaleOutSettings ScaleOut(this NServiceBus.EndpointConfiguration config) { }
    }
    [System.ObsoleteAttribute("Use extension methods provided on ISendOnlyBus. Will be removed in version 7.0.0." +
        "", true)]
    public class Schedule
    {
        public Schedule() { }
    }
    public class static ScheduleExtensions
    {
        [System.ObsoleteAttribute("Please use `ScheduleEvery(this IMessageSession session, TimeSpan timeSpan, Func<I" +
            "PipelineContext, Task> task)` instead. Will be removed in version 7.0.0.", true)]
        public static void ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, System.Action task) { }
        [System.ObsoleteAttribute("Please use `ScheduleEvery(this IMessageSession session, TimeSpan timeSpan, string" +
            " name, Func<IPipelineContext, Task> task)` instead. Will be removed in version 7" +
            ".0.0.", true)]
        public static void ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, string name, System.Action task) { }
        public static System.Threading.Tasks.Task ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, System.Func<NServiceBus.IPipelineContext, System.Threading.Tasks.Task> task) { }
        public static System.Threading.Tasks.Task ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, string name, System.Func<NServiceBus.IPipelineContext, System.Threading.Tasks.Task> task) { }
    }
    public class static SecondLevelRetriesConfigExtensions
    {
        public static NServiceBus.SecondLevelRetries.Config.SecondLevelRetriesSettings SecondLevelRetries(this NServiceBus.EndpointConfiguration config) { }
    }
    public class SendOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SendOptions() { }
    }
    public class static SerializationConfigExtensions
    {
        public static void AddDeserializer<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtentions<T> UseSerialization<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtentions<T> UseSerialization<T>(this NServiceBus.EndpointConfiguration config, T serializationDefinition)
            where T : NServiceBus.Serialization.SerializationDefinition { }
        [System.ObsoleteAttribute("To use a custom serializer derive from SerializationDefinition and provide a fact" +
            "ory method for creating the serializer instance. Will be removed in version 7.0." +
            "0.", true)]
        public static void UseSerialization(this NServiceBus.EndpointConfiguration config, System.Type serializerType) { }
    }
    public class static SerializationContextExtensions
    {
        public static bool ShouldSkipSerialization(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context) { }
        public static void SkipSerialization(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context) { }
    }
    public class static SettingsExtentions
    {
        public static NServiceBus.Routing.EndpointInstance EndpointInstanceName(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static NServiceBus.Routing.EndpointName EndpointName(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static System.Collections.Generic.IList<System.Type> GetAvailableTypes(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static T GetConfigSection<T>(this NServiceBus.Settings.ReadOnlySettings settings)
            where T :  class, new () { }
        public static string InstanceSpecificQueue(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static string LocalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public class static SLAMonitoringConfig
    {
        public static void EnableSLAPerformanceCounter(this NServiceBus.EndpointConfiguration config, System.TimeSpan sla) { }
        public static void EnableSLAPerformanceCounter(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static StaticHeadersConfigExtensions
    {
        public static void AddHeaderToAllOutgoingMessages(this NServiceBus.EndpointConfiguration config, string key, string value) { }
    }
    public class SubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SubscribeOptions() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class TimeToBeReceivedAttribute : System.Attribute
    {
        public TimeToBeReceivedAttribute(string timeSpan) { }
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class static TimeToBeReceivedConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningTimeToBeReceivedAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, System.TimeSpan> retrieveTimeToBeReceived) { }
    }
    public class ToSagaExpression<TSagaData, TMessage>
        where TSagaData : NServiceBus.IContainSagaData
    {
        public ToSagaExpression(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
        public void ToSaga(System.Linq.Expressions.Expression<System.Func<TSagaData, object>> sagaEntityProperty) { }
    }
    public class TransportExtensions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions AddAddressTranslationException(NServiceBus.LogicalAddress logicalAddress, string transportAddress) { }
        public NServiceBus.TransportExtensions AddAddressTranslationException(NServiceBus.Routing.EndpointInstance endpointInstance, string transportAddress) { }
        public NServiceBus.TransportExtensions AddAddressTranslationRule(System.Func<NServiceBus.LogicalAddress, string> rule) { }
        public NServiceBus.TransportExtensions ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions ConnectionString(System.Func<string> connectionString) { }
        public NServiceBus.TransportExtensions ConnectionStringName(string name) { }
        public NServiceBus.TransportExtensions Transactions(NServiceBus.TransportTransactionMode transportTransactionMode) { }
    }
    public class TransportExtensions<T> : NServiceBus.TransportExtensions
        where T : NServiceBus.Transports.TransportDefinition
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(System.Func<string> connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionStringName(string name) { }
        public NServiceBus.TransportExtensions<T> Transactions(NServiceBus.TransportTransactionMode transportTransactionMode) { }
    }
    [System.ObsoleteAttribute("Not used anymore, use `OutgoingMessage` or `IncomingMessage` instead. Will be rem" +
        "oved in version 7.0.0.", true)]
    public class TransportMessage
    {
        public TransportMessage() { }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.Body\' or \'OutgoingMessage.Body\' instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public byte[] Body { get; set; }
        [System.ObsoleteAttribute("Use the value of the \'NServiceBus.CorrelationId\' header instead. Will be removed " +
            "in version 7.0.0.", true)]
        public string CorrelationId { get; set; }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.Headers\' or \'OutgoingMesssage.Headers\' inst" +
            "ead. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.MessageId\' or \'OutgoingMesssage.MessageId\' " +
            "instead. Will be removed in version 7.0.0.", true)]
        public string Id { get; }
        [System.ObsoleteAttribute("Please use `GetMessageIntent(this IncomingMessage message)` instead. Will be remo" +
            "ved in version 7.0.0.", true)]
        public NServiceBus.MessageIntentEnum MessageIntent { get; }
        [System.ObsoleteAttribute(@"For sending purposes use `DeliveryConstraintContextExtensions.AddDeliveryConstraint(new NonDurableDelivery())` to set NonDurable delivery or `NonDurableDelivery constraint;DeliveryConstraintContextExtensions.TryGetDeliveryConstraint(out constraint)` to read wether NonDurable delivery is set. When receiving look at the new 'NServiceBus.NonDurableMessage' header. Will be removed in version 7.0.0.", true)]
        public bool Recoverable { get; set; }
        [System.ObsoleteAttribute("Please use `GetReplyToAddress(this IncomingMessage message)` instead. Will be rem" +
            "oved in version 7.0.0.", true)]
        public string ReplyToAddress { get; }
        [System.ObsoleteAttribute(@"For sending purposes use `DeliveryConstraintContextExtensions.AddDeliveryConstraint(new DiscardIfNotReceivedBefore(timeToBeReceived))` to set the `TimeToBeReceived` or `DiscardIfNotReceivedBefore constraint;DeliveryConstraintContextExtensions.TryGetDeliveryConstraint(out constraint)` to read the `TimeToBeReceived`. When receiving look at the new 'NServiceBus.TimeToBeReceived' header. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan TimeToBeReceived { get; set; }
    }
    public enum TransportTransactionMode
    {
        None = 0,
        ReceiveOnly = 1,
        SendsAtomicWithReceive = 2,
        TransactionScope = 3,
    }
    public class UnicastRoutingSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.RoutingMappingSettings Mapping { get; }
        public void AddPublisher(string publisherEndpoint, System.Type eventType) { }
        public void AddPublisher(string publisherEndpoint, System.Reflection.Assembly eventAssembly, string eventNamespace = null) { }
        public void RouteToEndpoint(System.Type messageType, string destination) { }
    }
    public sealed class UnicastRoutingTarget
    {
        public NServiceBus.Routing.EndpointName Endpoint { get; }
        public NServiceBus.Routing.EndpointInstance Instance { get; }
        public string TransportAddress { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public static NServiceBus.UnicastRoutingTarget ToAnonymousInstance(NServiceBus.Routing.EndpointName endpoint, string transportAddress) { }
        public static NServiceBus.UnicastRoutingTarget ToEndpointInstance(NServiceBus.Routing.EndpointInstance instance) { }
        public static NServiceBus.UnicastRoutingTarget ToTransportAddress(string transportAddress) { }
    }
    public class UnitOfWorkSettings
    {
        public NServiceBus.UnitOfWorkSettings WrapHandlersInATransactionScope(System.Nullable<System.TimeSpan> timeout = null, System.Nullable<System.Transactions.IsolationLevel> isolationLevel = null) { }
    }
    public class static UnitOfWorkSettingsExtensions
    {
        public static NServiceBus.UnitOfWorkSettings UnitOfWork(this NServiceBus.EndpointConfiguration config) { }
    }
    public class UnsubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public UnsubscribeOptions() { }
    }
    public class static UseDataBusExtensions
    {
        public static NServiceBus.DataBus.DataBusExtentions<T> UseDataBus<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.DataBus.DataBusDefinition, new () { }
        public static NServiceBus.DataBus.DataBusExtentions UseDataBus(this NServiceBus.EndpointConfiguration config, System.Type dataBusType) { }
    }
    public class static UseTransportExtensions
    {
        public static NServiceBus.TransportExtensions<T> UseTransport<T>(this NServiceBus.EndpointConfiguration endpointConfiguration)
            where T : NServiceBus.Transports.TransportDefinition, new () { }
        public static NServiceBus.TransportExtensions UseTransport(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Type transportDefinitionType) { }
    }
    public class WireEncryptedString : System.Runtime.Serialization.ISerializable
    {
        public WireEncryptedString() { }
        public WireEncryptedString(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        [System.ObsoleteAttribute("No longer required. Will be removed in version 7.0.0.", true)]
        public string Base64Iv { get; set; }
        [System.ObsoleteAttribute("No longer required. Will be removed in version 7.0.0.", true)]
        public string EncryptedBase64Value { get; set; }
        public NServiceBus.EncryptedValue EncryptedValue { get; set; }
        public string Value { get; set; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static XmlSerializationExtentions
    {
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> DontWrapRawXml(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config) { }
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> Namespace(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config, string namespaceToUse) { }
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> SanitizeInput(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config) { }
    }
    public class XmlSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public XmlSerializer() { }
        public override System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
}
namespace NServiceBus.AutomaticSubscriptions.Config
{
    public class AutoSubscribeSettings
    {
        [System.ObsoleteAttribute("Encourages bad practices. IMessageSession.Subscribe should be explicitly used. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public void AutoSubscribePlainMessages() { }
        public void DoNotAutoSubscribeSagas() { }
        [System.ObsoleteAttribute("Transports with support for centralized pubsub will default this to true. Can saf" +
            "ely be removed. Will be removed in version 7.0.0.", true)]
        public void DoNotRequireExplicitRouting() { }
    }
}
namespace NServiceBus.Config
{
    public class AuditConfig : System.Configuration.ConfigurationSection
    {
        public AuditConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("OverrideTimeToBeReceived", IsRequired=false)]
        public System.TimeSpan OverrideTimeToBeReceived { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("QueueName", IsRequired=false)]
        public string QueueName { get; set; }
    }
    [System.ObsoleteAttribute("Use the feature concept instead via A class which inherits from `NServiceBus.Feat" +
        "ures.Feature` and use `configuration.EnableFeature<YourClass>()`. Will be remove" +
        "d in version 7.0.0.", true)]
    public interface IWantToRunWhenConfigurationIsComplete { }
    public enum KeyFormat
    {
        Ascii = 0,
        Base64 = 1,
    }
    public class Logging : System.Configuration.ConfigurationSection
    {
        public Logging() { }
        [System.Configuration.ConfigurationPropertyAttribute("Threshold", DefaultValue="Info", IsRequired=true)]
        public string Threshold { get; set; }
    }
    [System.ObsoleteAttribute("Please use `EndpointConfiguration.EnlistWithLegacyMSMQDistributor` instead. Will " +
        "be removed in version 7.0.0.", true)]
    public class MasterNodeConfig : System.Configuration.ConfigurationSection
    {
        public MasterNodeConfig() { }
    }
    public class MessageEndpointMapping : System.Configuration.ConfigurationElement, System.IComparable<NServiceBus.Config.MessageEndpointMapping>
    {
        public MessageEndpointMapping() { }
        [System.Configuration.ConfigurationPropertyAttribute("Assembly", IsRequired=false)]
        public string AssemblyName { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Endpoint", IsRequired=true)]
        public string Endpoint { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Messages", IsRequired=false)]
        public string Messages { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Namespace", IsRequired=false)]
        public string Namespace { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Type", IsRequired=false)]
        public string TypeFullName { get; set; }
        public int CompareTo(NServiceBus.Config.MessageEndpointMapping other) { }
        public void Configure(System.Action<System.Type, string> mapTypeToEndpoint) { }
    }
    public class MessageEndpointMappingCollection : System.Configuration.ConfigurationElementCollection
    {
        public MessageEndpointMappingCollection() { }
        public new string AddElementName { get; set; }
        public new string ClearElementName { get; set; }
        public override System.Configuration.ConfigurationElementCollectionType CollectionType { get; }
        public new int Count { get; }
        public NServiceBus.Config.MessageEndpointMapping this[int index] { get; set; }
        public NServiceBus.Config.MessageEndpointMapping this[string Name] { get; }
        public new string RemoveElementName { get; }
        public void Add(NServiceBus.Config.MessageEndpointMapping mapping) { }
        protected override void BaseAdd(System.Configuration.ConfigurationElement element) { }
        public void Clear() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement(string elementName) { }
        protected override object GetElementKey(System.Configuration.ConfigurationElement element) { }
        public int IndexOf(NServiceBus.Config.MessageEndpointMapping mapping) { }
        public override bool IsReadOnly() { }
        public void Remove(NServiceBus.Config.MessageEndpointMapping mapping) { }
        public void Remove(string name) { }
        public void RemoveAt(int index) { }
    }
    public class MessageForwardingInCaseOfFaultConfig : System.Configuration.ConfigurationSection
    {
        public MessageForwardingInCaseOfFaultConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("ErrorQueue", IsRequired=true)]
        public string ErrorQueue { get; set; }
    }
    public class MsmqSubscriptionStorageConfig : System.Configuration.ConfigurationSection
    {
        public MsmqSubscriptionStorageConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("Queue", IsRequired=true)]
        public string Queue { get; set; }
    }
    public class RijndaelEncryptionServiceConfig : System.Configuration.ConfigurationSection
    {
        public RijndaelEncryptionServiceConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("ExpiredKeys", IsRequired=false)]
        public NServiceBus.Config.RijndaelExpiredKeyCollection ExpiredKeys { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Key", IsRequired=true)]
        public string Key { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("KeyFormat", IsRequired=false)]
        public NServiceBus.Config.KeyFormat KeyFormat { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("KeyIdentifier", IsRequired=false)]
        public string KeyIdentifier { get; set; }
    }
    public class RijndaelExpiredKey : System.Configuration.ConfigurationElement
    {
        public RijndaelExpiredKey() { }
        [System.Configuration.ConfigurationPropertyAttribute("Key", IsRequired=true)]
        public string Key { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("KeyFormat", IsRequired=false)]
        public NServiceBus.Config.KeyFormat KeyFormat { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("KeyIdentifier", IsRequired=false)]
        public string KeyIdentifier { get; set; }
    }
    public class RijndaelExpiredKeyCollection : System.Configuration.ConfigurationElementCollection
    {
        public RijndaelExpiredKeyCollection() { }
        public override System.Configuration.ConfigurationElementCollectionType CollectionType { get; }
        public NServiceBus.Config.RijndaelExpiredKey this[int index] { get; set; }
        public NServiceBus.Config.RijndaelExpiredKey this[string key] { get; }
        public void Add(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        protected override void BaseAdd(System.Configuration.ConfigurationElement element) { }
        public void Clear() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement(string elementName) { }
        protected override object GetElementKey(System.Configuration.ConfigurationElement element) { }
        public int IndexOf(NServiceBus.Config.RijndaelExpiredKey encryptionKey) { }
        public override bool IsReadOnly() { }
        public void Remove(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        public void Remove(string name) { }
        public void RemoveAt(int index) { }
    }
    public class SecondLevelRetriesConfig : System.Configuration.ConfigurationSection
    {
        public SecondLevelRetriesConfig() { }
        public bool Enabled { get; set; }
        public int NumberOfRetries { get; set; }
        public System.TimeSpan TimeIncrease { get; set; }
    }
    public class TransportConfig : System.Configuration.ConfigurationSection
    {
        public TransportConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("MaximumConcurrencyLevel", DefaultValue=0, IsRequired=false)]
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.LimitMessageProcessingConcurrencyTo` instead. W" +
            "ill be removed in version 7.0.0.", true)]
        public int MaximumConcurrencyLevel { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MaximumMessageThroughputPerSecond", DefaultValue=-1, IsRequired=false)]
        [System.ObsoleteAttribute("Message throughput throttling has been removed. Consult the documentation for fur" +
            "ther information. Will be removed in version 7.0.0.", true)]
        public int MaximumMessageThroughputPerSecond { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MaxRetries", DefaultValue=5, IsRequired=false)]
        public int MaxRetries { get; set; }
    }
    public class UnicastBusConfig : System.Configuration.ConfigurationSection
    {
        public UnicastBusConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("DistributorControlAddress", IsRequired=false)]
        [System.ObsoleteAttribute("Switch to the code API by using \'EndpointConfiguration.EnlistWithLegacyMSMQDistri" +
            "butor\' instead. Will be removed in version 7.0.0.", true)]
        public string DistributorControlAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("DistributorDataAddress", IsRequired=false)]
        [System.ObsoleteAttribute("Switch to the code API by using \'EndpointConfiguration.EnlistWithLegacyMSMQDistri" +
            "butor\' instead. Will be removed in version 7.0.0.", true)]
        public string DistributorDataAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("ForwardReceivedMessagesTo", IsRequired=false)]
        [System.ObsoleteAttribute("Use \'EndpointConfiguration.ForwardReceivedMessagesTo\' to configure the forwarding" +
            " address. Will be removed in version 7.0.0.", true)]
        public string ForwardReceivedMessagesTo { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MessageEndpointMappings", IsRequired=false)]
        public NServiceBus.Config.MessageEndpointMappingCollection MessageEndpointMappings { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("TimeoutManagerAddress", IsRequired=false)]
        public string TimeoutManagerAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("TimeToBeReceivedOnForwardedMessages", IsRequired=false)]
        public System.TimeSpan TimeToBeReceivedOnForwardedMessages { get; set; }
    }
}
namespace NServiceBus.Config.ConfigurationSource
{
    public class DefaultConfigurationSource : NServiceBus.Config.ConfigurationSource.IConfigurationSource
    {
        public DefaultConfigurationSource() { }
    }
    public interface IConfigurationSource
    {
        T GetConfiguration<T>()
            where T :  class, new ();
    }
    public interface IProvideConfiguration<T>
    {
        T GetConfiguration();
    }
}
namespace NServiceBus.Configuration.AdvanceExtensibility
{
    public class static AdvanceExtensibilityExtensions
    {
        public static NServiceBus.Settings.SettingsHolder GetSettings(this NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings config) { }
    }
    public abstract class ExposeSettings
    {
        protected ExposeSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.ConsistencyGuarantees
{
    public class static TransactionModeSettingsExtensions
    {
        public static NServiceBus.TransportTransactionMode GetRequiredTransactionModeForReceives(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
}
namespace NServiceBus.Container
{
    public class ContainerCustomizations
    {
        public NServiceBus.Settings.SettingsHolder Settings { get; }
    }
    public abstract class ContainerDefinition
    {
        protected ContainerDefinition() { }
        public abstract NServiceBus.ObjectBuilder.Common.IContainer CreateContainer(NServiceBus.Settings.ReadOnlySettings settings);
    }
}
namespace NServiceBus.DataBus
{
    public abstract class DataBusDefinition
    {
        protected DataBusDefinition() { }
        protected internal abstract System.Type ProvidedByFeature();
    }
    public class DataBusExtentions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public DataBusExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class DataBusExtentions<T> : NServiceBus.DataBus.DataBusExtentions
        where T : NServiceBus.DataBus.DataBusDefinition
    {
        public DataBusExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public interface IDataBus
    {
        System.Threading.Tasks.Task<System.IO.Stream> Get(string key);
        System.Threading.Tasks.Task<string> Put(System.IO.Stream stream, System.TimeSpan timeToBeReceived);
        System.Threading.Tasks.Task Start();
    }
    public interface IDataBusSerializer
    {
        object Deserialize(System.IO.Stream stream);
        void Serialize(object databusProperty, System.IO.Stream stream);
    }
}
namespace NServiceBus.DelayedDelivery
{
    public class DelayDeliveryWith : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DelayDeliveryWith(System.TimeSpan delay) { }
        public System.TimeSpan Delay { get; }
    }
    public abstract class DelayedDeliveryConstraint : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        protected DelayedDeliveryConstraint() { }
    }
    public class DoNotDeliverBefore : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DoNotDeliverBefore(System.DateTime at) { }
        public System.DateTime At { get; }
    }
}
namespace NServiceBus.DeliveryConstraints
{
    public abstract class DeliveryConstraint
    {
        protected DeliveryConstraint() { }
    }
    public class static DeliveryConstraintContextExtensions
    {
        public static void AddDeliveryConstraint(this NServiceBus.Extensibility.ContextBag context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> GetDeliveryConstraints(this NServiceBus.Extensibility.ContextBag context) { }
        public static void RemoveDeliveryConstaint(this NServiceBus.Extensibility.ContextBag context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static bool TryGetDeliveryConstraint<T>(this NServiceBus.Extensibility.ContextBag context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
        public static bool TryRemoveDeliveryConstraint<T>(this NServiceBus.Extensibility.ContextBag context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
    }
}
namespace NServiceBus.Extensibility
{
    public class ContextBag : NServiceBus.Extensibility.ReadOnlyContextBag
    {
        public ContextBag(NServiceBus.Extensibility.ContextBag parentBag = null) { }
        public T Get<T>() { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public void Remove<T>() { }
        public void Remove(string key) { }
        public void Set<T>(T t) { }
        public void Set<T>(string key, T t) { }
        public bool TryGet<T>(out T result) { }
        public bool TryGet<T>(string key, out T result) { }
    }
    public abstract class ExtendableOptions
    {
        protected ExtendableOptions() { }
    }
    public class static ExtendableOptionsExtensions
    {
        public static NServiceBus.Extensibility.ContextBag GetExtensions(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public interface IExtendable
    {
        NServiceBus.Extensibility.ContextBag Extensions { get; }
    }
    public interface ReadOnlyContextBag
    {
        T Get<T>();
        bool TryGet<T>(out T result);
        bool TryGet<T>(string key, out T result);
    }
}
namespace NServiceBus.Faults
{
    public class ErrorsNotifications
    {
        public ErrorsNotifications() { }
        public event System.EventHandler<NServiceBus.Faults.SecondLevelRetry> MessageHasBeenSentToSecondLevelRetries;
        public event System.EventHandler<NServiceBus.Faults.FirstLevelRetry> MessageHasFailedAFirstLevelRetryAttempt;
        public event System.EventHandler<NServiceBus.Faults.FailedMessage> MessageSentToErrorQueue;
    }
    public struct FailedMessage
    {
        public FailedMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static FaultsHeaderKeys
    {
        public const string FailedQ = "NServiceBus.FailedQ";
    }
    public struct FirstLevelRetry
    {
        public FirstLevelRetry(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public int RetryAttempt { get; }
    }
    [System.ObsoleteAttribute("IManageMessageFailures is no longer an extension point. To take control of the er" +
        "ror handling part of the message processing pipeline, review the Version 5 to 6 " +
        "upgrade guide for details. Will be removed in version 7.0.0.", true)]
    public interface IManageMessageFailures { }
    public struct SecondLevelRetry
    {
        public SecondLevelRetry(System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public int RetryAttempt { get; }
    }
}
namespace NServiceBus.Features
{
    public class Audit : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class AutoSubscribe : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class BestPracticeEnforcement : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Use extensions provided by the TransportDefinition class instead. Will be removed" +
        " in version 7.0.0.", true)]
    public class ConfigureTransport
    {
        public ConfigureTransport() { }
    }
    public class CriticalTimeMonitoring : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class DataBus : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Encryptor : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public abstract class Feature
    {
        protected Feature() { }
        public bool IsActive { get; }
        public bool IsEnabledByDefault { get; }
        public string Name { get; }
        public string Version { get; }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> settings) { }
        protected void DependsOn<T>()
            where T : NServiceBus.Features.Feature { }
        protected void DependsOn(string featureName) { }
        protected void DependsOnAtLeastOne(params System.Type[] features) { }
        protected void DependsOnAtLeastOne(params string[] featureNames) { }
        protected void DependsOnOptionally(string featureName) { }
        protected void DependsOnOptionally(System.Type featureType) { }
        protected void DependsOnOptionally<T>()
            where T : NServiceBus.Features.Feature { }
        protected void EnableByDefault() { }
        protected void Prerequisite(System.Func<NServiceBus.Features.FeatureConfigurationContext, bool> condition, string description) { }
        [System.ObsoleteAttribute("Please use `FeatureConfigurationContext.RegisterStartupTask` instead. Will be rem" +
            "oved in version 7.0.0.", true)]
        protected void RegisterStartupTask<T>()
            where T : NServiceBus.Features.FeatureStartupTask { }
        protected internal abstract void Setup(NServiceBus.Features.FeatureConfigurationContext context);
        public override string ToString() { }
    }
    public class FeatureConfigurationContext
    {
        public NServiceBus.ObjectBuilder.IConfigureComponents Container { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        public NServiceBus.Settings.ReadOnlySettings Settings { get; }
        public NServiceBus.Pipeline.PipelineSettings AddSatellitePipeline(string name, NServiceBus.TransportTransactionMode requiredTransportTransactionMode, NServiceBus.Transports.PushRuntimeSettings runtimeSettings, string qualifier, out string transportAddress) { }
        public NServiceBus.Pipeline.PipelineSettings AddSatellitePipeline(string name, NServiceBus.TransportTransactionMode requiredTransportTransactionMode, NServiceBus.Transports.PushRuntimeSettings runtimeSettings, string transportAddress) { }
        public void RegisterStartupTask<TTask>(TTask startupTask)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<NServiceBus.ObjectBuilder.IBuilder, TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
    }
    public abstract class FeatureStartupTask
    {
        protected FeatureStartupTask() { }
        protected abstract System.Threading.Tasks.Task OnStart(NServiceBus.IMessageSession session);
        protected abstract System.Threading.Tasks.Task OnStop(NServiceBus.IMessageSession session);
    }
    public enum FeatureState
    {
        Disabled = 0,
        Enabled = 1,
        Active = 2,
        Deactivated = 3,
    }
    public class FirstLevelRetries : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class ForwardReceivedMessages : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryGatewayPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryOutboxPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySagaPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryTimeoutPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MessageDrivenSubscriptions : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MsmqSubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Outbox : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Sagas : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Scheduler : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class SecondLevelRetries : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Use the ConfigureSerialization Feature class instead. Please use `ConfigureSerial" +
        "ization` instead. Will be removed in version 7.0.0.", true)]
    public class static SerializationFeatureHelper { }
    public class static SettingsExtentions
    {
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault<T>(this NServiceBus.Settings.SettingsHolder settings)
            where T : NServiceBus.Features.Feature { }
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault(this NServiceBus.Settings.SettingsHolder settings, System.Type featureType) { }
        public static bool IsFeatureActive(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
        public static bool IsFeatureEnabled(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
    }
    public class SLAMonitoring : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class StorageDrivenPublishing
    {
        public StorageDrivenPublishing() { }
    }
    public class TimeoutManager : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class TimeoutManagerBasedDeferral
    {
        public TimeoutManagerBasedDeferral() { }
    }
}
namespace NServiceBus.Gateway.Deduplication
{
    public interface IDeduplicateMessages
    {
        System.Threading.Tasks.Task<bool> DeduplicateMessage(string clientId, System.DateTime timeReceived, NServiceBus.Extensibility.ContextBag context);
    }
}
namespace NServiceBus.Hosting.Helpers
{
    public class AssemblyScanner
    {
        public AssemblyScanner() { }
        public AssemblyScanner(string baseDirectoryToScan) { }
        [System.ObsoleteAttribute("This method is no longer required since deep scanning of assemblies is done to de" +
            "tect an NServiceBus reference. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.List<System.Reflection.Assembly> MustReferenceAtLeastOneAssembly { get; }
        public bool ThrowExceptions { get; set; }
        public NServiceBus.Hosting.Helpers.AssemblyScannerResults GetScannableAssemblies() { }
    }
    public class AssemblyScannerResults
    {
        public AssemblyScannerResults() { }
        public System.Collections.Generic.List<System.Reflection.Assembly> Assemblies { get; }
        public bool ErrorsThrownDuringScanning { get; }
        public System.Collections.Generic.List<NServiceBus.Hosting.Helpers.SkippedFile> SkippedFiles { get; }
        public System.Collections.Generic.List<System.Type> Types { get; }
    }
    public class SkippedFile
    {
        public string FilePath { get; }
        public string SkipReason { get; }
    }
}
namespace NServiceBus.Hosting
{
    public class HostInformation
    {
        public HostInformation(System.Guid hostId, string displayName) { }
        public HostInformation(System.Guid hostId, string displayName, System.Collections.Generic.Dictionary<string, string> properties) { }
        public string DisplayName { get; }
        public System.Guid HostId { get; }
        public System.Collections.Generic.Dictionary<string, string> Properties { get; }
    }
}
namespace NServiceBus.InMemory.Outbox
{
    public class static InMemoryOutboxSettingsExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings TimeToKeepDeduplicationData(this NServiceBus.Outbox.OutboxSettings settings, System.TimeSpan time) { }
    }
}
namespace NServiceBus.Installation
{
    public interface INeedToInstallSomething
    {
        System.Threading.Tasks.Task Install(string identity);
    }
}
namespace NServiceBus.Logging
{
    public class DefaultFactory : NServiceBus.Logging.LoggingFactoryDefinition
    {
        public DefaultFactory() { }
        public void Directory(string directory) { }
        protected internal override NServiceBus.Logging.ILoggerFactory GetLoggingFactory() { }
        public void Level(NServiceBus.Logging.LogLevel level) { }
    }
    public interface ILog
    {
        bool IsDebugEnabled { get; }
        bool IsErrorEnabled { get; }
        bool IsFatalEnabled { get; }
        bool IsInfoEnabled { get; }
        bool IsWarnEnabled { get; }
        void Debug(string message);
        void Debug(string message, System.Exception exception);
        [JetBrains.Annotations.StringFormatMethodAttribute("format")]
        void DebugFormat(string format, params object[] args);
        void Error(string message);
        void Error(string message, System.Exception exception);
        [JetBrains.Annotations.StringFormatMethodAttribute("format")]
        void ErrorFormat(string format, params object[] args);
        void Fatal(string message);
        void Fatal(string message, System.Exception exception);
        [JetBrains.Annotations.StringFormatMethodAttribute("format")]
        void FatalFormat(string format, params object[] args);
        void Info(string message);
        void Info(string message, System.Exception exception);
        [JetBrains.Annotations.StringFormatMethodAttribute("format")]
        void InfoFormat(string format, params object[] args);
        void Warn(string message);
        void Warn(string message, System.Exception exception);
        [JetBrains.Annotations.StringFormatMethodAttribute("format")]
        void WarnFormat(string format, params object[] args);
    }
    public interface ILoggerFactory
    {
        NServiceBus.Logging.ILog GetLogger(System.Type type);
        NServiceBus.Logging.ILog GetLogger(string name);
    }
    public abstract class LoggingFactoryDefinition
    {
        protected LoggingFactoryDefinition() { }
        protected internal abstract NServiceBus.Logging.ILoggerFactory GetLoggingFactory();
    }
    public enum LogLevel
    {
        Debug = 0,
        Info = 1,
        Warn = 2,
        Error = 3,
        Fatal = 4,
    }
    public class static LogManager
    {
        public static NServiceBus.Logging.ILog GetLogger<T>() { }
        public static NServiceBus.Logging.ILog GetLogger(System.Type type) { }
        public static NServiceBus.Logging.ILog GetLogger(string name) { }
        public static T Use<T>()
            where T : NServiceBus.Logging.LoggingFactoryDefinition, new () { }
        public static void UseFactory(NServiceBus.Logging.ILoggerFactory loggerFactory) { }
    }
}
namespace NServiceBus.MessageInterfaces
{
    public interface IMessageMapper : NServiceBus.IMessageCreator
    {
        System.Type GetMappedTypeFor(System.Type t);
        System.Type GetMappedTypeFor(string typeName);
        void Initialize(System.Collections.Generic.IEnumerable<System.Type> types);
    }
}
namespace NServiceBus.MessageInterfaces.MessageMapper.Reflection
{
    public class MessageMapper : NServiceBus.IMessageCreator, NServiceBus.MessageInterfaces.IMessageMapper
    {
        public MessageMapper() { }
        public T CreateInstance<T>(System.Action<T> action) { }
        public T CreateInstance<T>() { }
        public object CreateInstance(System.Type t) { }
        public System.Type GetMappedTypeFor(System.Type t) { }
        public System.Type GetMappedTypeFor(string typeName) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> types) { }
    }
}
namespace NServiceBus.MessageMutator
{
    [System.ObsoleteAttribute("Have the mutator implement both IMutateOutgoingMessages and IMutateIncomingMessag" +
        "es. Will be removed in version 7.0.0.", true)]
    public interface IMessageMutator { }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface IMutateIncomingMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingMessageContext context);
    }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface IMutateIncomingTransportMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingTransportMessageContext context);
    }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface IMutateOutgoingMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingMessageContext context);
    }
    [JetBrains.Annotations.UsedImplicitlyAttribute(JetBrains.Annotations.ImplicitUseTargetFlags.Default | JetBrains.Annotations.ImplicitUseTargetFlags.Itself | JetBrains.Annotations.ImplicitUseTargetFlags.Members | JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers)]
    public interface IMutateOutgoingTransportMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingTransportMessageContext context);
    }
    [System.ObsoleteAttribute("Have the mutator implement both IMutateIncomingTransportMessages and IMutateOutgo" +
        "ingTransportMessages. Will be removed in version 7.0.0.", true)]
    public interface IMutateTransportMessages : NServiceBus.MessageMutator.IMutateIncomingTransportMessages, NServiceBus.MessageMutator.IMutateOutgoingTransportMessages { }
    public class MutateIncomingMessageContext
    {
        public MutateIncomingMessageContext(object message, System.Collections.Generic.Dictionary<string, string> headers) { }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public object Message { get; set; }
    }
    public class MutateIncomingTransportMessageContext
    {
        public MutateIncomingTransportMessageContext(byte[] body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public byte[] Body { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
    }
    public class MutateOutgoingMessageContext
    {
        public MutateOutgoingMessageContext(object outgoingMessage, System.Collections.Generic.Dictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public System.Collections.Generic.Dictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; set; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<, > incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
    public class MutateOutgoingTransportMessageContext
    {
        public MutateOutgoingTransportMessageContext(byte[] outgoingBody, object outgoingMessage, System.Collections.Generic.Dictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public byte[] OutgoingBody { get; set; }
        public System.Collections.Generic.Dictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<, > incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
}
namespace NServiceBus.ObjectBuilder.Common
{
    public interface IContainer : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        NServiceBus.ObjectBuilder.Common.IContainer BuildChildContainer();
        void Configure(System.Type component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void Configure<T>(System.Func<T> component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        bool HasComponent(System.Type componentType);
        void RegisterSingleton(System.Type lookupType, object instance);
        void Release(object instance);
    }
}
namespace NServiceBus.ObjectBuilder
{
    public interface IBuilder : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        T Build<T>();
        System.Collections.Generic.IEnumerable<T> BuildAll<T>();
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        void BuildAndDispatch(System.Type typeToBuild, System.Action<object> action);
        NServiceBus.ObjectBuilder.IBuilder CreateChildBuilder();
        void Release(object instance);
    }
    [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
        "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
        "l over handler creation. Will be removed in version 7.0.0.", true)]
    public interface IComponentConfig { }
    [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
        "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
        "l over handler creation. Will be removed in version 7.0.0.", true)]
    public interface IComponentConfig<T> { }
    [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
        "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
        "l over handler creation. Will be removed in version 7.0.0.", true)]
    public class static IConfigureComponentObsoleteExtensions
    {
        [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
            "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
            "l over handler creation. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.ObjectBuilder.IConfigureComponents ConfigureProperty<T>(this NServiceBus.ObjectBuilder.IConfigureComponents config, System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
            "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
            "l over handler creation. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.ObjectBuilder.IConfigureComponents ConfigureProperty<T>(this NServiceBus.ObjectBuilder.IConfigureComponents config, string propertyName, object value) { }
    }
    public interface IConfigureComponents
    {
        void ConfigureComponent(System.Type concreteComponent, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(System.Func<T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(System.Func<NServiceBus.ObjectBuilder.IBuilder, T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        bool HasComponent<T>();
        bool HasComponent(System.Type componentType);
        void RegisterSingleton(System.Type lookupType, object instance);
        void RegisterSingleton<T>(T instance);
    }
}
namespace NServiceBus.Outbox
{
    public interface IOutboxStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxTransaction> BeginTransaction(NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxMessage> Get(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task SetAsDispatched(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Store(NServiceBus.Outbox.OutboxMessage message, NServiceBus.Outbox.OutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context);
    }
    public class OutboxMessage
    {
        public OutboxMessage(string messageId, System.Collections.Generic.IList<NServiceBus.Outbox.TransportOperation> operations) { }
        public string MessageId { get; }
        public System.Collections.Generic.IList<NServiceBus.Outbox.TransportOperation> TransportOperations { get; }
    }
    public class OutboxSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        [System.ObsoleteAttribute("Please use `InMemoryOutboxSettingsExtensions.TimeToKeepDeduplicationData(TimeSpan" +
            " time)` instead. Will be removed in version 7.0.0.", true)]
        public void TimeToKeepDeduplicationData(System.TimeSpan time) { }
    }
    public interface OutboxTransaction : System.IDisposable
    {
        System.Threading.Tasks.Task Commit();
    }
    public class TransportOperation
    {
        public TransportOperation(string messageId, System.Collections.Generic.Dictionary<string, string> options, byte[] body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public System.Collections.Generic.Dictionary<string, string> Options { get; }
    }
}
namespace NServiceBus.Performance.TimeToBeReceived
{
    public class DiscardIfNotReceivedBefore : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public DiscardIfNotReceivedBefore(System.TimeSpan maxTime) { }
        public System.TimeSpan MaxTime { get; }
    }
}
namespace NServiceBus.Persistence
{
    public interface CompletableSynchronizedStorageSession : NServiceBus.Persistence.SynchronizedStorageSession, System.IDisposable
    {
        System.Threading.Tasks.Task CompleteAsync();
    }
    public interface ISynchronizedStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> OpenSession(NServiceBus.Extensibility.ContextBag contextBag);
    }
    public interface ISynchronizedStorageAdapter
    {
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> TryAdapt(NServiceBus.Outbox.OutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> TryAdapt(NServiceBus.Transports.TransportTransaction transportTransaction, NServiceBus.Extensibility.ContextBag context);
    }
    public abstract class PersistenceDefinition
    {
        protected PersistenceDefinition() { }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> action) { }
        [System.ObsoleteAttribute("Please use `HasSupportFor<T>()` instead. Will be removed in version 7.0.0.", true)]
        public bool HasSupportFor(NServiceBus.Persistence.Storage storage) { }
        public bool HasSupportFor<T>()
            where T : NServiceBus.Persistence.StorageType { }
        public bool HasSupportFor(System.Type storageType) { }
        protected void Supports<T>(System.Action<NServiceBus.Settings.SettingsHolder> action)
            where T : NServiceBus.Persistence.StorageType { }
        [System.ObsoleteAttribute("Please use `Supports<T>()` instead. Will be removed in version 7.0.0.", true)]
        protected void Supports(NServiceBus.Persistence.Storage storage, System.Action<NServiceBus.Settings.SettingsHolder> action) { }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.Persistence.StorageType` instead. Will be removed in vers" +
        "ion 7.0.0.", true)]
    public enum Storage
    {
        Timeouts = 1,
        Subscriptions = 2,
        Sagas = 3,
        GatewayDeduplication = 4,
        Outbox = 5,
    }
    public abstract class StorageType
    {
        public override string ToString() { }
        public sealed class GatewayDeduplication : NServiceBus.Persistence.StorageType { }
        public sealed class Outbox : NServiceBus.Persistence.StorageType { }
        public sealed class Sagas : NServiceBus.Persistence.StorageType { }
        public sealed class Subscriptions : NServiceBus.Persistence.StorageType { }
        public sealed class Timeouts : NServiceBus.Persistence.StorageType { }
    }
    public interface SynchronizedStorageSession { }
}
namespace NServiceBus.Persistence.Legacy
{
    public class MsmqPersistence : NServiceBus.Persistence.PersistenceDefinition { }
}
namespace NServiceBus.Pipeline
{
    public abstract class Behavior<TContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TContext, TContext>
        where TContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected Behavior() { }
        public System.Threading.Tasks.Task Invoke(TContext context, System.Func<TContext, System.Threading.Tasks.Task> next) { }
        public abstract System.Threading.Tasks.Task Invoke(TContext context, System.Func<System.Threading.Tasks.Task> next);
    }
    public abstract class ForkConnector<TFromContext, TForkContext> : NServiceBus.Pipeline.Behavior<TFromContext>, NServiceBus.IForkConnector, NServiceBus.IForkConnector<TForkContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TForkContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected ForkConnector() { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<System.Threading.Tasks.Task> next, System.Func<TForkContext, System.Threading.Tasks.Task> fork);
        public virtual System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<System.Threading.Tasks.Task> next) { }
    }
    public interface IAuditContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        string AuditAddress { get; }
        NServiceBus.Transports.OutgoingMessage Message { get; }
        void AddAuditData(string key, string value);
    }
    public interface IBatchDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> Operations { get; }
    }
    public interface IBehavior { }
    [System.ObsoleteAttribute("Please use `Behavior<T>` instead. Will be removed in version 7.0.0.", true)]
    public interface IBehavior<in TContext> { }
    public interface IBehavior<in TInContext, out TOutContext> : NServiceBus.Pipeline.IBehavior
        where in TInContext : NServiceBus.Pipeline.IBehaviorContext
        where out TOutContext : NServiceBus.Pipeline.IBehaviorContext
    {
        System.Threading.Tasks.Task Invoke(TInContext context, System.Func<TOutContext, System.Threading.Tasks.Task> next);
    }
    public interface IBehaviorContext : NServiceBus.Extensibility.IExtendable
    {
        NServiceBus.ObjectBuilder.IBuilder Builder { get; }
    }
    public interface IDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.IEnumerable<NServiceBus.Transports.TransportOperation> Operations { get; }
    }
    public interface IFaultContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        string ErrorQueueAddress { get; }
        System.Exception Exception { get; }
        NServiceBus.Transports.OutgoingMessage Message { get; }
        void AddFaultData(string key, string value);
    }
    public interface IForwardingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        string Address { get; }
        NServiceBus.Transports.OutgoingMessage Message { get; }
    }
    public interface IIncomingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext { }
    public interface IIncomingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        NServiceBus.Pipeline.LogicalMessage Message { get; }
        bool MessageHandled { get; set; }
        void UpdateMessageInstance(object newInstance);
    }
    public interface IIncomingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        NServiceBus.Transports.IncomingMessage Message { get; }
        void UpdateMessage(byte[] body);
    }
    public interface IInvokeHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageHandlerContext, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        bool HandleCurrentMessageLaterWasCalled { get; }
        bool HandlerInvocationAborted { get; }
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        object MessageBeingHandled { get; }
        NServiceBus.Pipeline.MessageHandler MessageHandler { get; }
        NServiceBus.Unicast.Messages.MessageMetadata MessageMetadata { get; }
    }
    public interface IOutgoingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        string MessageId { get; }
    }
    public interface IOutgoingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessage(object newInstance);
    }
    public interface IOutgoingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        byte[] Body { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessage(byte[] body);
    }
    public interface IOutgoingPublishContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IOutgoingReplyContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IOutgoingSendContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IRoutingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transports.OutgoingMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; set; }
    }
    public interface ISatelliteProcessingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transports.IncomingMessage Message { get; }
    }
    public interface ISubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Type EventType { get; }
    }
    public interface ITransportReceiveContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transports.IncomingMessage Message { get; }
        void AbortReceiveOperation();
    }
    public interface IUnsubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Type EventType { get; }
    }
    public class LogicalMessage
    {
        public LogicalMessage(NServiceBus.Unicast.Messages.MessageMetadata metadata, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Unicast.Messages.MessageMetadata Metadata { get; }
        [System.ObsoleteAttribute("Please use `IIncomingLogicalMessageContext.UpdateMessageInstance(object newInstan" +
            "ce)` instead. Will be removed in version 7.0.0.", true)]
        public void UpdateMessageInstance(object newInstance) { }
    }
    public class LogicalMessageFactory
    {
        public LogicalMessageFactory(NServiceBus.Unicast.Messages.MessageMetadataRegistry messageMetadataRegistry, NServiceBus.MessageInterfaces.IMessageMapper messageMapper) { }
        public NServiceBus.Pipeline.LogicalMessage Create(object message) { }
        public NServiceBus.Pipeline.LogicalMessage Create(System.Type messageType, object message) { }
    }
    public class MessageHandler
    {
        public MessageHandler(System.Func<object, object, NServiceBus.IMessageHandlerContext, System.Threading.Tasks.Task> invocation, System.Type handlerType) { }
        public System.Type HandlerType { get; }
        public object Instance { get; set; }
        public System.Threading.Tasks.Task Invoke(object message, NServiceBus.IMessageHandlerContext handlerContext) { }
    }
    public class OutgoingLogicalMessage
    {
        public OutgoingLogicalMessage(System.Type messageType, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
    }
    [System.ObsoleteAttribute("The pipeline context is no longer avaliable via dependency injection. Use a custo" +
        "m behavior as described in the version 6 upgrade guide. Will be removed in versi" +
        "on 7.0.0.", true)]
    public class PipelineExecutor
    {
        public PipelineExecutor() { }
    }
    public class PipelineSettings
    {
        public NServiceBus.Pipeline.StepRegistrationSequence Register(string stepId, System.Type behavior, string description) { }
        public NServiceBus.Pipeline.StepRegistrationSequence Register<T>(string stepId, System.Func<NServiceBus.ObjectBuilder.IBuilder, T> factoryMethod, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public NServiceBus.Pipeline.StepRegistrationSequence Register<T>(string stepId, T behavior, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public NServiceBus.Pipeline.StepRegistrationSequence Register(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type behavior, string description) { }
        public void Register<TRegisterStep>()
            where TRegisterStep : NServiceBus.Pipeline.RegisterStep, new () { }
        public void Register(NServiceBus.Pipeline.RegisterStep registration) { }
        public void Remove(string stepId) { }
        public void Remove(NServiceBus.Pipeline.WellKnownStep wellKnownStep) { }
        public void Replace(string stepId, System.Type newBehavior, string description = null) { }
        public void Replace<T>(string stepId, T newBehavior, string description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Replace<T>(string stepId, System.Func<NServiceBus.ObjectBuilder.IBuilder, T> factoryMethod, string description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Replace(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type newBehavior, string description = null) { }
    }
    public abstract class PipelineTerminator<T> : NServiceBus.Pipeline.StageConnector<T, NServiceBus.Pipeline.PipelineTerminator<T>.ITerminatingContext>, NServiceBus.IPipelineTerminator
        where T : NServiceBus.Pipeline.IBehaviorContext
    {
        protected PipelineTerminator() { }
        public virtual System.Threading.Tasks.Task Invoke(T context, System.Func<NServiceBus.Pipeline.PipelineTerminator<T>.ITerminatingContext, System.Threading.Tasks.Task> next) { }
        protected abstract System.Threading.Tasks.Task Terminate(T context);
        public interface ITerminatingContext<T> : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
            where T : NServiceBus.Pipeline.IBehaviorContext { }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{StepId}({BehaviorType.FullName}) - {Description}")]
    public abstract class RegisterStep
    {
        protected RegisterStep(string stepId, System.Type behavior, string description, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Pipeline.IBehavior> factoryMethod = null) { }
        public System.Type BehaviorType { get; }
        public string Description { get; }
        public string StepId { get; }
        public void InsertAfter(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertAfter(string id) { }
        public void InsertAfterIfExists(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertAfterIfExists(string id) { }
        public void InsertBefore(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertBefore(string id) { }
        public void InsertBeforeIfExists(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertBeforeIfExists(string id) { }
        public virtual bool IsEnabled(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public abstract class StageConnector<TFromContext, TToContext> : NServiceBus.IStageConnector, NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TToContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TToContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected StageConnector() { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> stage);
    }
    public abstract class StageForkConnector<TFromContext, TToContext, TForkContext> : NServiceBus.IForkConnector, NServiceBus.IForkConnector<TForkContext>, NServiceBus.IStageConnector, NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TToContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TToContext : NServiceBus.Pipeline.IBehaviorContext
        where TForkContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected StageForkConnector() { }
        public System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> next) { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> stage, System.Func<TForkContext, System.Threading.Tasks.Task> fork);
    }
    public class StepRegistrationSequence
    {
        public NServiceBus.Pipeline.StepRegistrationSequence Register(string stepId, System.Type behavior, string description) { }
        public NServiceBus.Pipeline.StepRegistrationSequence Register(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type behavior, string description) { }
    }
    public class static TransportMessageContextExtensions
    {
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingReplyContext context, out NServiceBus.Transports.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context, out NServiceBus.Transports.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingPhysicalMessageContext context, out NServiceBus.Transports.IncomingMessage message) { }
    }
    public class WellKnownStep
    {
        public static readonly NServiceBus.Pipeline.WellKnownStep AuditProcessedMessage;
        [System.ObsoleteAttribute("The child container creation is now an integral part of the pipeline invocation a" +
            "nd no longer a separate behavior. Will be removed in version 7.0.0.", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep CreateChildContainer;
        [System.ObsoleteAttribute("The dispatch step is the terminating step in v6 so any dependency on it can safel" +
            "y be removed. Will be removed in version 7.0.0.", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep DispatchMessageToTransport;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforcePublishBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceReplyBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceSendBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceSubscribeBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceUnsubscribeBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep ExecuteUnitOfWork;
        public static NServiceBus.Pipeline.WellKnownStep HostInformation;
        public static readonly NServiceBus.Pipeline.WellKnownStep InvokeHandlers;
        public static readonly NServiceBus.Pipeline.WellKnownStep InvokeSaga;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateIncomingMessages;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateIncomingTransportMessage;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateOutgoingMessages;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateOutgoingTransportMessage;
        public static NServiceBus.Pipeline.WellKnownStep ProcessingStatistics;
    }
}
namespace NServiceBus.Pipeline.Contexts
{
    [System.ObsoleteAttribute("Please use `OutgoingLogicalMessage` instead. Will be removed in version 7.0.0.", true)]
    public class OutgoingContext
    {
        public OutgoingContext() { }
    }
}
namespace NServiceBus.Routing
{
    public abstract class AddressTag
    {
        protected AddressTag() { }
    }
    public class AllInstancesDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public AllInstancesDistributionStrategy() { }
        public override System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> allInstances) { }
    }
    public abstract class DistributionStrategy
    {
        protected DistributionStrategy() { }
        public abstract System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> allInstances);
    }
    public sealed class EndpointInstance
    {
        public EndpointInstance(string endpoint, string discriminator = null, System.Collections.Generic.IReadOnlyDictionary<string, string> properties = null) { }
        public EndpointInstance(NServiceBus.Routing.EndpointName endpoint, string discriminator = null, System.Collections.Generic.IReadOnlyDictionary<string, string> properties = null) { }
        public string Discriminator { get; }
        public NServiceBus.Routing.EndpointName Endpoint { get; }
        public System.Collections.Generic.IReadOnlyDictionary<string, string> Properties { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public NServiceBus.Routing.EndpointInstance SetProperty(string key, string value) { }
        public override string ToString() { }
    }
    public class EndpointInstances
    {
        public EndpointInstances() { }
        public void Add(NServiceBus.Routing.EndpointName endpoint, params NServiceBus.Routing.EndpointInstance[] instances) { }
        public void AddDynamic(System.Func<NServiceBus.Routing.EndpointName, System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Routing.EndpointInstance>>> dynamicRule) { }
    }
    public sealed class EndpointName
    {
        public EndpointName(string name) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public interface IUnicastRoute
    {
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget>> Resolve(System.Func<NServiceBus.Routing.EndpointName, System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Routing.EndpointInstance>>> instanceResolver);
    }
    public class MulticastAddressTag : NServiceBus.Routing.AddressTag
    {
        public MulticastAddressTag(System.Type messageType) { }
        public System.Type MessageType { get; }
    }
    public class MulticastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public MulticastRoutingStrategy(System.Type messageType) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public abstract class RoutingStrategy
    {
        protected RoutingStrategy() { }
        public abstract NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers);
    }
    public class SingleInstanceRoundRobinDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public SingleInstanceRoundRobinDistributionStrategy() { }
        [System.Runtime.CompilerServices.IteratorStateMachineAttribute(typeof(NServiceBus.Routing.SingleInstanceRoundRobinDistributionStrategy.<SelectDestination>d__0))]
        public override System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> currentAllInstances) { }
    }
    public class UnicastAddressTag : NServiceBus.Routing.AddressTag
    {
        public UnicastAddressTag(string destination) { }
        public string Destination { get; }
    }
    public class UnicastRoute : NServiceBus.Routing.IUnicastRoute
    {
        public UnicastRoute(NServiceBus.Routing.EndpointName endpoint) { }
        public UnicastRoute(NServiceBus.Routing.EndpointInstance instance) { }
        public UnicastRoute(string physicalAddress) { }
    }
    public class UnicastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public UnicastRoutingStrategy(string destination) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public class UnicastRoutingTable
    {
        public UnicastRoutingTable() { }
        public void AddDynamic(System.Func<System.Collections.Generic.List<System.Type>, NServiceBus.Extensibility.ContextBag, System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Routing.IUnicastRoute>>> dynamicRule) { }
        public void AddDynamic(System.Func<System.Collections.Generic.List<System.Type>, NServiceBus.Extensibility.ContextBag, System.Collections.Generic.IEnumerable<NServiceBus.Routing.IUnicastRoute>> dynamicRule) { }
        public void RouteToAddress(System.Type messageType, string destinationAddress) { }
        public void RouteToEndpoint(System.Type messageType, NServiceBus.Routing.EndpointName destination) { }
        public void RouteToEndpoint(System.Type messageType, string destination) { }
    }
}
namespace NServiceBus.Routing.Legacy
{
    public class static ConfigureMSMQDistributor
    {
        public static void EnlistWithLegacyMSMQDistributor(this NServiceBus.EndpointConfiguration config, string masterNodeAddress, string masterNodeControlAddress, int capacity) { }
    }
}
namespace NServiceBus.Routing.MessageDrivenSubscriptions
{
    public class PublisherAddress
    {
        public PublisherAddress(NServiceBus.Routing.EndpointName endpoint) { }
        public PublisherAddress(params NServiceBus.Routing.EndpointInstance[] instances) { }
        public PublisherAddress(params string[] addresses) { }
    }
    public class Publishers
    {
        public Publishers() { }
        public void Add(string publisher, System.Type eventType) { }
        public void Add(string publisher, System.Reflection.Assembly eventAssembly, string eventNamespace = null) { }
        public void AddByAddress(string publisherAddress, System.Type eventType) { }
        public void AddDynamic(System.Func<System.Type, NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress> dynamicRule, string description = null) { }
    }
}
namespace NServiceBus.Routing.StorageDrivenPublishing
{
    [System.ObsoleteAttribute("No longer an extension point, if you want to list events without subscribers you " +
        "can take a dependency on ISubscriptionStorage and query it for the event types y" +
        "ou want to check. Will be removed in version 7.0.0.", true)]
    public class SubscribersForEvent
    {
        public SubscribersForEvent(System.Collections.Generic.List<string> subscribers, System.Type eventType) { }
        public System.Type EventType { get; }
        public System.Collections.Generic.IEnumerable<string> Subscribers { get; }
    }
}
namespace NServiceBus.Sagas
{
    public class ActiveSagaInstance
    {
        public System.DateTime Created { get; }
        public NServiceBus.Saga Instance { get; }
        public bool IsNew { get; }
        public System.DateTime Modified { get; }
        public bool NotFound { get; }
        public string SagaId { get; }
        [System.ObsoleteAttribute("Please use `.Metadata.SagaType` instead. Will be removed in version 7.0.0.", true)]
        public System.Type SagaType { get; }
        public void AttachNewEntity(NServiceBus.IContainSagaData sagaEntity) { }
    }
    public interface IFinder { }
    public abstract class IFindSagas<T>
        where T : NServiceBus.IContainSagaData
    {
        protected IFindSagas() { }
        public interface Using<T, M> : NServiceBus.Sagas.IFinder
            where T : NServiceBus.IContainSagaData
        {
            System.Threading.Tasks.Task<T> FindBy(M message, NServiceBus.Persistence.SynchronizedStorageSession storageSession, NServiceBus.Extensibility.ReadOnlyContextBag context);
        }
    }
    public interface IHandleSagaNotFound
    {
        System.Threading.Tasks.Task Handle(object message, NServiceBus.IMessageProcessingContext context);
    }
    public interface ISagaPersister
    {
        System.Threading.Tasks.Task Complete(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(System.Guid sagaId, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context)
            where TSagaData : NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(string propertyName, object propertyValue, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context)
            where TSagaData : NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task Save(NServiceBus.IContainSagaData sagaData, NServiceBus.Sagas.SagaCorrelationProperty correlationProperty, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Update(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
    }
    public class SagaCorrelationProperty
    {
        public SagaCorrelationProperty(string name, object value) { }
        public string Name { get; }
        public static NServiceBus.Sagas.SagaCorrelationProperty None { get; }
        public object Value { get; }
    }
    public class SagaFinderDefinition
    {
        public SagaFinderDefinition(System.Type type, string messageType, System.Collections.Generic.Dictionary<string, object> properties) { }
        public string MessageType { get; }
        public System.Collections.Generic.Dictionary<string, object> Properties { get; }
        public System.Type Type { get; }
    }
    public class SagaMessage
    {
        public SagaMessage(string messageType, bool isAllowedToStart) { }
        public bool IsAllowedToStartSaga { get; }
        public string MessageType { get; }
    }
    public class SagaMetadata
    {
        public SagaMetadata(string name, System.Type sagaType, string entityName, System.Type sagaEntityType, NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata correlationProperty, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> messages, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> finders) { }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> AssociatedMessages { get; }
        public string EntityName { get; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> Finders { get; }
        public string Name { get; }
        public System.Type SagaEntityType { get; }
        public System.Type SagaType { get; }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType) { }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType, System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
        public bool IsMessageAllowedToStartTheSaga(string messageType) { }
        public bool TryGetCorrelationProperty(out NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata property) { }
        public bool TryGetFinder(string messageType, out NServiceBus.Sagas.SagaFinderDefinition finderDefinition) { }
        public class CorrelationPropertyMetadata
        {
            public CorrelationPropertyMetadata(string name, System.Type type) { }
            public string Name { get; }
            public System.Type Type { get; }
        }
    }
    public class SagaMetadataCollection : System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMetadata>, System.Collections.IEnumerable
    {
        public SagaMetadataCollection() { }
        public NServiceBus.Sagas.SagaMetadata Find(System.Type sagaType) { }
        public NServiceBus.Sagas.SagaMetadata FindByEntity(System.Type entityType) { }
        public System.Collections.Generic.IEnumerator<NServiceBus.Sagas.SagaMetadata> GetEnumerator() { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
    }
    [System.ObsoleteAttribute("There is no need for this attribute anymore, all mapped properties are automatica" +
        "lly correlated. Will be removed in version 7.0.0.", true)]
    public sealed class UniqueAttribute : System.Attribute
    {
        public UniqueAttribute() { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Collections.Generic.IDictionary<string, object> GetUniqueProperties(NServiceBus.IContainSagaData entity) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> GetUniqueProperties(System.Type type) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Reflection.PropertyInfo GetUniqueProperty(System.Type type) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Nullable<System.Collections.Generic.KeyValuePair<string, object>> GetUniqueProperty(NServiceBus.IContainSagaData entity) { }
    }
}
namespace NServiceBus.Satellites
{
    [System.ObsoleteAttribute(@"ISatellite is no longer an extension point. In order to create a satellite one must create a feature that uses AddSatellitePipeline() method and a class that inherits from SatelliteBehavior that is used for processing the messages. Will be removed in version 7.0.0.", true)]
    public interface IAdvancedSatellite { }
    [System.ObsoleteAttribute(@"ISatellite is no longer an extension point. In order to create a satellite one must create a feature that uses AddSatellitePipeline() method and a class that inherits from SatelliteBehavior that is used for processing the messages. Will be removed in version 7.0.0.", true)]
    public interface ISatellite { }
}
namespace NServiceBus.SecondLevelRetries.Config
{
    public class SecondLevelRetriesSettings
    {
        [System.ObsoleteAttribute("Please use `CustomRetryPolicy(Func<IncomingMessage, TimeSpan> customPolicy)` inst" +
            "ead. Will be removed in version 7.0.0.", true)]
        public void CustomRetryPolicy(System.Func<NServiceBus.TransportMessage, System.TimeSpan> customPolicy) { }
        public void CustomRetryPolicy(System.Func<NServiceBus.Transports.IncomingMessage, System.TimeSpan> customPolicy) { }
    }
}
namespace NServiceBus.Serialization
{
    [System.ObsoleteAttribute("To use a custom serializer derive from SerializationDefinition and provide a fact" +
        "ory method for creating the serializer instance. Will be removed in version 7.0." +
        "0.", true)]
    public abstract class ConfigureSerialization
    {
        protected ConfigureSerialization() { }
    }
    public interface IMessageSerializer
    {
        string ContentType { get; }
        object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypes = null);
        void Serialize(object message, System.IO.Stream stream);
    }
    public abstract class SerializationDefinition
    {
        protected SerializationDefinition() { }
        public abstract System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings);
    }
    public class SerializationExtentions<T> : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
        where T : NServiceBus.Serialization.SerializationDefinition
    {
        public SerializationExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.Serializers.Json
{
    [System.ObsoleteAttribute("Built-in serializers are internal. Switch to an alternative (e.g. Json.net) or co" +
        "py the serializer code. Will be removed in version 7.0.0.", true)]
    public class JsonMessageSerializer
    {
        public JsonMessageSerializer() { }
    }
}
namespace NServiceBus.Serializers.XML
{
    [System.ObsoleteAttribute("Built-in serializers are internal. Switch to an  alternative (e.g. XmlSerializer)" +
        " or copy the serializer code. Will be removed in version 7.0.0.", true)]
    public class XmlMessageSerializer
    {
        public XmlMessageSerializer() { }
    }
}
namespace NServiceBus.Settings.NServiceBus
{
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class static TransactionSettingsExtentions
    {
        [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.Settings.TransactionSettings Transactions(this NServiceBus.EndpointConfiguration config) { }
    }
}
namespace NServiceBus.Settings
{
    public interface ReadOnlySettings
    {
        T Get<T>();
        T Get<T>(string key);
        object Get(string key);
        T GetOrDefault<T>();
        T GetOrDefault<T>(string key);
        bool HasExplicitValue(string key);
        bool HasExplicitValue<T>();
        bool HasSetting(string key);
        bool HasSetting<T>();
        bool TryGet<T>(out T val);
        bool TryGet<T>(string key, out T val);
    }
    public class static ReadOnlySettingsExtensions
    {
        [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
            "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
            "l over handler creation. Will be removed in version 7.0.0.", true)]
        public static void ApplyTo<T>(NServiceBus.ObjectBuilder.IComponentConfig config) { }
        [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
            "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
            "l over handler creation. Will be removed in version 7.0.0.", true)]
        public static void ApplyTo(System.Type componentType, NServiceBus.ObjectBuilder.IComponentConfig config) { }
    }
    public class ScaleOutSettings
    {
        public void InstanceDiscriminator(string discriminator) { }
        [System.ObsoleteAttribute("Not required any more as for MSMQ this is the default behavior and for other tran" +
            "sports the unique instance ID has to be provided. Will be removed in version 7.0" +
            ".0.", true)]
        public void UniqueQueuePerEndpointInstance() { }
        [System.ObsoleteAttribute("Please use `EndpointConfiguration.ScaleOut().InstanceDiscriminator(string discrim" +
            "inator)` instead. Will be removed in version 7.0.0.", true)]
        public void UniqueQueuePerEndpointInstance(string discriminator) { }
        [System.ObsoleteAttribute("This is the default starting with V6. Will be removed in version 7.0.0.", true)]
        public void UseSingleBrokerQueue() { }
        [System.ObsoleteAttribute("Not required any more as for MSMQ this is the default behavior and for other tran" +
            "sports the unique instance ID has to be provided. Will be removed in version 7.0" +
            ".0.", true)]
        public void UseUniqueBrokerQueuePerMachine() { }
    }
    public class SettingsHolder : NServiceBus.Settings.ReadOnlySettings
    {
        public SettingsHolder() { }
        [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
            "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
            "l over handler creation. Will be removed in version 7.0.0.", true)]
        public void ApplyTo<T>(NServiceBus.ObjectBuilder.IComponentConfig config) { }
        [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
            "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
            "l over handler creation. Will be removed in version 7.0.0.", true)]
        public void ApplyTo(System.Type componentType, NServiceBus.ObjectBuilder.IComponentConfig config) { }
        public void Clear() { }
        public T Get<T>(string key) { }
        public T Get<T>() { }
        public object Get(string key) { }
        public T GetOrDefault<T>() { }
        public T GetOrDefault<T>(string key) { }
        public bool HasExplicitValue(string key) { }
        public bool HasExplicitValue<T>() { }
        public bool HasSetting(string key) { }
        public bool HasSetting<T>() { }
        public void Set(string key, object value) { }
        public void Set<T>(object value) { }
        public void Set<T>(System.Action value) { }
        public void SetDefault<T>(object value) { }
        public void SetDefault<T>(System.Action value) { }
        public void SetDefault(string key, object value) { }
        public void SetProperty<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        public void SetPropertyDefault<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        public bool TryGet<T>(out T val) { }
        public bool TryGet<T>(string key, out T val) { }
    }
    public class TransactionSettings
    {
        public TransactionSettings() { }
        [System.ObsoleteAttribute("Please use `config.UnitOfWork().WrapHandlersInATransactionScope(timeout: TimeSpan" +
            ".FromSeconds(X));` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings DefaultTimeout(System.TimeSpan defaultTimeout) { }
        [System.ObsoleteAttribute("Please use `config.UseTransport<MyTransport>().Transactions(TransportTransactionM" +
            "ode.None);` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings Disable() { }
        [System.ObsoleteAttribute("Please use `config.UseTransport<MyTransport>().Transactions(TransportTransactionM" +
            "ode.ReceiveOnly|TransportTransactionMode.SendsAtomicWithReceive);` instead. Will" +
            " be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings DisableDistributedTransactions() { }
        [System.ObsoleteAttribute(@"DoNotWrapHandlersExecutionInATransactionScope() has been removed since transaction scopes are no longer used by non DTC transports delay the dispatch of all outgoing operations until handlers have been executed.\r\nIn Version 6 handlers will only be wrapped in a transactionscope if running the MSMQ or SQLServer transports in default mode. This means that performing storage operations against data sources also supporting transaction scopes \r\nwill escalate to a distributed transaction. Previous versions allowed opting out of this behavior using config.Transactions().DoNotWrapHandlersExecutionInATransactionScope(). In Version 6 it's recommended to use `EndpointConfiguration.UseTransport<MyTransport>().Transactions(TransportTransactionMode.ReceiveOnly)` to lean on native transport transaction and the new batched dispatch support to achieve the same level of consistency with better performance.\r\nSuppressing the ambient transaction created by the MSMQ and SQL Server transports can still be achieved by creating a custom pipeline behavior with a suppressed transaction scope. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings DoNotWrapHandlersExecutionInATransactionScope() { }
        [System.ObsoleteAttribute("Please use `config.UseTransport<MyTransport>().Transactions(TransportTransactionM" +
            "ode.ReceiveOnly|TransportTransactionMode.SendsAtomicWithReceive);` instead. Will" +
            " be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings Enable() { }
        [System.ObsoleteAttribute("Please use `config.UseTransport<MyTransport>().Transactions(TransportTransactionM" +
            "ode.TransactionScope);` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings EnableDistributedTransactions() { }
        [System.ObsoleteAttribute("Please use `config.UnitOfWork().WrapHandlersInATransactionScope(isolationLevel: I" +
            "solationLevel.X);` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings IsolationLevel(System.Transactions.IsolationLevel isolationLevel) { }
        [System.ObsoleteAttribute("Please use `config.UnitOfWork().WrapHandlersInATransactionScope();` instead. Will" +
            " be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings WrapHandlersExecutionInATransactionScope() { }
    }
}
namespace NServiceBus.Support
{
    public class static RuntimeEnvironment
    {
        public static string MachineName { get; }
        public static System.Func<string> MachineNameAction { get; set; }
    }
}
namespace NServiceBus.Timeout.Core
{
    public interface IPersistTimeouts
    {
        System.Threading.Tasks.Task Add(NServiceBus.Timeout.Core.TimeoutData timeout, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutData> Peek(string timeoutId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task RemoveTimeoutBy(System.Guid sagaId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<bool> TryRemove(string timeoutId, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IQueryTimeouts
    {
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutsChunk> GetNextChunk(System.DateTime startSlice);
    }
    public class TimeoutData
    {
        [System.ObsoleteAttribute("Not used anymore. Will be removed in version 7.0.0.", true)]
        public const string OriginalReplyToAddress = "NServiceBus.Timeout.ReplyToAddress";
        public TimeoutData() { }
        public string Destination { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
        public string Id { get; set; }
        public string OwningTimeoutManager { get; set; }
        public System.Guid SagaId { get; set; }
        public byte[] State { get; set; }
        public System.DateTime Time { get; set; }
        [System.ObsoleteAttribute("Use new SendOptions() instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Unicast.SendOptions ToSendOptions(NServiceBus.Address replyToAddress) { }
        [System.ObsoleteAttribute("Use new SendOptions() instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Unicast.SendOptions ToSendOptions(string replyToAddress) { }
        public override string ToString() { }
        [System.ObsoleteAttribute("Use new OutgoingMessage(timeoutData.State) instead. Will be removed in version 7." +
            "0.0.", true)]
        public NServiceBus.TransportMessage ToTransportMessage() { }
    }
    public class TimeoutsChunk
    {
        public TimeoutsChunk(System.Collections.Generic.IEnumerable<NServiceBus.Timeout.Core.TimeoutsChunk.Timeout> dueTimeouts, System.DateTime nextTimeToQuery) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Timeout.Core.TimeoutsChunk.Timeout> DueTimeouts { get; }
        public System.DateTime NextTimeToQuery { get; }
        public class Timeout
        {
            public Timeout(string id, System.DateTime dueTime) { }
            public System.DateTime DueTime { get; }
            public string Id { get; }
        }
    }
}
namespace NServiceBus.Transports
{
    public enum DispatchConsistency
    {
        Default = 1,
        Isolated = 2,
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public interface IAuditMessages { }
    public interface ICancelDeferredMessages
    {
        System.Threading.Tasks.Task CancelDeferredMessages(string messageKey, NServiceBus.Pipeline.IBehaviorContext context);
    }
    public interface ICreateQueues
    {
        System.Threading.Tasks.Task CreateQueueIfNecessary(NServiceBus.Transports.QueueBindings queueBindings, string identity);
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface IDeferMessages
    {
        [System.ObsoleteAttribute("Please use `ICancelDeferredMessages` instead. Will be removed in version 7.0.0.", true)]
        void ClearDeferredMessages(string headerKey, string headerValue);
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.Transport.IPushMessages` instead. Will be removed in vers" +
        "ion 7.0.0.", true)]
    public interface IDequeueMessages
    {
        void Init(NServiceBus.Address address, NServiceBus.Unicast.Transport.TransactionSettings transactionSettings, System.Func<NServiceBus.TransportMessage, bool> tryProcessMessage, System.Action<NServiceBus.TransportMessage, System.Exception> endProcessMessage);
        void Start(int maximumConcurrencyLevel);
        void Stop();
    }
    public interface IDispatchMessages
    {
        System.Threading.Tasks.Task Dispatch(NServiceBus.Transports.TransportOperations outgoingMessages, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IManageSubscriptions
    {
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
    }
    public class IncomingMessage
    {
        public IncomingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.IO.Stream bodyStream) { }
        public byte[] Body { get; set; }
        public System.IO.Stream BodyStream { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static IncomingMessageExtensions
    {
        public static NServiceBus.MessageIntentEnum GetMesssageIntent(this NServiceBus.Transports.IncomingMessage message) { }
        public static string GetReplyToAddress(this NServiceBus.Transports.IncomingMessage message) { }
    }
    public interface IOutgoingTransportOperation
    {
        System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        NServiceBus.Transports.OutgoingMessage Message { get; }
        NServiceBus.Transports.DispatchConsistency RequiredDispatchConsistency { get; }
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface IPublishMessages { }
    public interface IPushMessages
    {
        System.Threading.Tasks.Task Init(System.Func<NServiceBus.Transports.PushContext, System.Threading.Tasks.Task> pipe, NServiceBus.CriticalError criticalError, NServiceBus.Transports.PushSettings settings);
        void Start(NServiceBus.Transports.PushRuntimeSettings limitations);
        System.Threading.Tasks.Task Stop();
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface ISendMessages
    {
        void Send(NServiceBus.TransportMessage message, NServiceBus.Unicast.SendOptions sendOptions);
    }
    public class MulticastTransportOperation : NServiceBus.Transports.IOutgoingTransportOperation
    {
        public MulticastTransportOperation(NServiceBus.Transports.OutgoingMessage message, System.Type messageType, NServiceBus.Transports.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public NServiceBus.Transports.OutgoingMessage Message { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Transports.DispatchConsistency RequiredDispatchConsistency { get; }
    }
    public class OutboundRoutingPolicy
    {
        public OutboundRoutingPolicy(NServiceBus.Transports.OutboundRoutingType sends, NServiceBus.Transports.OutboundRoutingType publishes, NServiceBus.Transports.OutboundRoutingType replies) { }
        public NServiceBus.Transports.OutboundRoutingType Publishes { get; }
        public NServiceBus.Transports.OutboundRoutingType Replies { get; }
        public NServiceBus.Transports.OutboundRoutingType Sends { get; }
    }
    public enum OutboundRoutingType
    {
        Unicast = 0,
        Multicast = 1,
    }
    public class OutgoingMessage
    {
        public OutgoingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class PushContext
    {
        public PushContext(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.IO.Stream bodyStream, NServiceBus.Transports.TransportTransaction transportTransaction, System.Threading.CancellationTokenSource receiveCancellationTokenSource, NServiceBus.Extensibility.ContextBag context) { }
        public System.IO.Stream BodyStream { get; }
        public NServiceBus.Extensibility.ContextBag Context { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public System.Threading.CancellationTokenSource ReceiveCancellationTokenSource { get; }
        public NServiceBus.Transports.TransportTransaction TransportTransaction { get; }
    }
    public class PushRuntimeSettings
    {
        public PushRuntimeSettings(int maxConcurrency = 100) { }
        public static NServiceBus.Transports.PushRuntimeSettings Default { get; }
        public int MaxConcurrency { get; }
    }
    public class PushSettings
    {
        public PushSettings(string inputQueue, string errorQueue, bool purgeOnStartup, NServiceBus.TransportTransactionMode requiredTransactionMode) { }
        public string ErrorQueue { get; }
        public string InputQueue { get; }
        public bool PurgeOnStartup { get; }
        public NServiceBus.TransportTransactionMode RequiredTransactionMode { get; }
    }
    public class QueueBindings
    {
        public QueueBindings() { }
        public System.Collections.Generic.IReadOnlyCollection<string> ReceivingAddresses { get; }
        public System.Collections.Generic.IReadOnlyCollection<string> SendingAddresses { get; }
        public void BindReceiving(string address) { }
        public void BindSending(string transportAddress) { }
    }
    public class StartupCheckResult
    {
        public static readonly NServiceBus.Transports.StartupCheckResult Success;
        public string ErrorMessage { get; }
        public bool Succeeded { get; }
        public static NServiceBus.Transports.StartupCheckResult Failed(string errorMessage) { }
    }
    public class TransportAddresses
    {
        public void AddRule(System.Func<NServiceBus.LogicalAddress, string> dynamicRule) { }
        public void AddSpecialCase([JetBrains.Annotations.NotNullAttribute()] NServiceBus.LogicalAddress endpointInstance, string physicalAddress) { }
        public void AddSpecialCase([JetBrains.Annotations.NotNullAttribute()] NServiceBus.Routing.EndpointInstance endpointInstance, string physicalAddress) { }
    }
    public abstract class TransportDefinition
    {
        protected TransportDefinition() { }
        public abstract string ExampleConnectionStringForErrorMessage { get; }
        [System.ObsoleteAttribute("Use TransportInfrastructure.OutboundRoutingPolicy.Publishes == OutboundRoutingTyp" +
            "e.Multicast instead. Will be removed in version 7.0.0.", true)]
        public bool HasNativePubSubSupport { get; set; }
        [System.ObsoleteAttribute("The concept of centralized publish and subscribe is no longer available. Will be " +
            "removed in version 7.0.0.", true)]
        public bool HasSupportForCentralizedPubSub { get; set; }
        [System.ObsoleteAttribute("Use TransportInfrastructure.TransactionMode == TransportTransactionMode.Transacti" +
            "onScope instead. Will be removed in version 7.0.0.", true)]
        public System.Nullable<bool> HasSupportForDistributedTransactions { get; set; }
        [System.ObsoleteAttribute("Use TransportInfrastructure.TransactionMode == TransportTransactionMode.SendsAtom" +
            "icWithReceive instead. Will be removed in version 7.0.0.", true)]
        public bool HasSupportForMultiQueueNativeTransactions { get; set; }
        public virtual bool RequiresConnectionString { get; }
        protected internal abstract NServiceBus.Transports.TransportInfrastructure Initialize(NServiceBus.Settings.SettingsHolder settings, string connectionString);
    }
    public abstract class TransportInfrastructure
    {
        protected TransportInfrastructure() { }
        public abstract System.Collections.Generic.IEnumerable<System.Type> DeliveryConstraints { get; }
        public abstract NServiceBus.Transports.OutboundRoutingPolicy OutboundRoutingPolicy { get; }
        public bool RequireOutboxConsent { get; set; }
        public abstract NServiceBus.TransportTransactionMode TransactionMode { get; }
        public abstract NServiceBus.Routing.EndpointInstance BindToLocalEndpoint(NServiceBus.Routing.EndpointInstance instance);
        public abstract NServiceBus.Transports.TransportReceiveInfrastructure ConfigureReceiveInfrastructure();
        public abstract NServiceBus.Transports.TransportSendInfrastructure ConfigureSendInfrastructure();
        public abstract NServiceBus.Transports.TransportSubscriptionInfrastructure ConfigureSubscriptionInfrastructure();
        public virtual string MakeCanonicalForm(string transportAddress) { }
        public virtual System.Threading.Tasks.Task Start() { }
        public virtual System.Threading.Tasks.Task Stop() { }
        public abstract string ToTransportAddress(NServiceBus.LogicalAddress logicalAddress);
    }
    public class TransportOperation
    {
        public TransportOperation(NServiceBus.Transports.OutgoingMessage message, NServiceBus.Routing.AddressTag addressTag, NServiceBus.Transports.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public NServiceBus.Routing.AddressTag AddressTag { get; }
        public System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public NServiceBus.Transports.OutgoingMessage Message { get; }
        public NServiceBus.Transports.DispatchConsistency RequiredDispatchConsistency { get; set; }
    }
    public class TransportOperations
    {
        public TransportOperations(params NServiceBus.Transports.TransportOperation[] transportOperations) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Transports.MulticastTransportOperation> MulticastTransportOperations { get; }
        public System.Collections.Generic.IEnumerable<NServiceBus.Transports.UnicastTransportOperation> UnicastTransportOperations { get; }
    }
    public class TransportReceiveInfrastructure
    {
        public TransportReceiveInfrastructure(System.Func<NServiceBus.Transports.IPushMessages> messagePumpFactory, System.Func<NServiceBus.Transports.ICreateQueues> queueCreatorFactory, System.Func<System.Threading.Tasks.Task<NServiceBus.Transports.StartupCheckResult>> preStartupCheck) { }
    }
    public class TransportSendInfrastructure
    {
        public TransportSendInfrastructure(System.Func<NServiceBus.Transports.IDispatchMessages> dispatcherFactory, System.Func<System.Threading.Tasks.Task<NServiceBus.Transports.StartupCheckResult>> preStartupCheck) { }
    }
    public class TransportSubscriptionInfrastructure
    {
        public TransportSubscriptionInfrastructure(System.Func<NServiceBus.Transports.IManageSubscriptions> subscriptionManagerFactory) { }
    }
    public class TransportTransaction : NServiceBus.Extensibility.ContextBag
    {
        public TransportTransaction() { }
    }
    public class UnicastTransportOperation : NServiceBus.Transports.IOutgoingTransportOperation
    {
        public UnicastTransportOperation(NServiceBus.Transports.OutgoingMessage message, string destination, NServiceBus.Transports.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public string Destination { get; }
        public NServiceBus.Transports.OutgoingMessage Message { get; }
        public NServiceBus.Transports.DispatchConsistency RequiredDispatchConsistency { get; }
    }
}
namespace NServiceBus.Transports.Msmq.Config
{
    [System.ObsoleteAttribute("No longer available, see the documentation for native sends for alternative solut" +
        "ions. Will be removed in version 7.0.0.", true)]
    public class MsmqSettings
    {
        public MsmqSettings() { }
    }
}
namespace NServiceBus.Transports.Msmq
{
    public class HeaderInfo
    {
        public HeaderInfo() { }
        public string Key { get; set; }
        public string Value { get; set; }
    }
    [System.ObsoleteAttribute("No longer available, resolve an instance of IPushMessages from the container inst" +
        "ead. Will be removed in version 7.0.0.", true)]
    public class MsmqDequeueStrategy
    {
        public MsmqDequeueStrategy() { }
    }
    [System.ObsoleteAttribute("No longer available, see the documentation for native sends for alternative solut" +
        "ions. Will be removed in version 7.0.0.", true)]
    public class MsmqMessageSender
    {
        public MsmqMessageSender() { }
    }
    [System.ObsoleteAttribute("The msmq transaction is now available via the pipeline context. Will be removed i" +
        "n version 7.0.0.", true)]
    public class MsmqUnitOfWork
    {
        public MsmqUnitOfWork() { }
    }
}
namespace NServiceBus.Unicast.Behaviors
{
    public class MessageHandler
    {
        [System.ObsoleteAttribute("Please use `NServiceBus.Pipeline.MessageHandler(Action<object, object, object> in" +
            "vocation, Type handlerType)` instead. Will be removed in version 7.0.0.", true)]
        public MessageHandler() { }
        [System.ObsoleteAttribute("Please use `NServiceBus.Pipeline.MessageHandler.Invoke` instead. Will be removed " +
            "in version 7.0.0.", true)]
        public System.Action<object, object> Invocation { get; set; }
    }
}
namespace NServiceBus.Unicast
{
    public class static BuilderExtensions
    {
        public static void ForEach<T>(this NServiceBus.ObjectBuilder.IBuilder builder, System.Action<T> action) { }
    }
    [System.ObsoleteAttribute("No longer used, use the new callbacks api described in the version 6 upgrade guid" +
        "e. Will be removed in version 7.0.0.", true)]
    public class BusAsyncResult
    {
        public BusAsyncResult() { }
    }
    public class DeliveryMessageOptions
    {
        public DeliveryMessageOptions() { }
        [System.ObsoleteAttribute("Use the ConsistencyGuarantee class instead. Will be removed in version 7.0.0.", true)]
        public bool EnlistInReceiveTransaction { get; set; }
        [System.ObsoleteAttribute("Use context.TryGetDeliveryConstraint<NonDurableDelivery> instead. Will be removed" +
            " in version 7.0.0.", true)]
        public System.Nullable<bool> NonDurable { get; set; }
        [System.ObsoleteAttribute("Use context.TryGetDeliveryConstraint<DiscardIfNotReceivedBefore> instead. Will be" +
            " removed in version 7.0.0.", true)]
        public System.Nullable<System.TimeSpan> TimeToBeReceived { get; set; }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.UnicastBus.DeliveryMessageOptions` instead. Will be remov" +
        "ed in version 7.0.0.", true)]
    public abstract class DeliveryOptions
    {
        protected DeliveryOptions() { }
        [System.ObsoleteAttribute("Turn best practices check off using configuration.DisableFeature<BestPracticeEnfo" +
            "rcement>(). Will be removed in version 7.0.0.", true)]
        public bool EnforceMessagingBestPractices { get; set; }
        [System.ObsoleteAttribute("Reply to address can be get/set using the `NServiceBus.ReplyToAddress` header. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public string ReplyToAddress { get; set; }
    }
    [System.ObsoleteAttribute("Not a public API. Please use `MessageHandlerRegistry` instead. Will be removed in" +
        " version 7.0.0.", true)]
    public interface IMessageHandlerRegistry { }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class MessageContext
    {
        public MessageContext() { }
    }
    public class MessageEventArgs : System.EventArgs
    {
        public MessageEventArgs(object msg) { }
        public object Message { get; }
    }
    public class MessageHandlerRegistry
    {
        [System.ObsoleteAttribute("Please use `MessageHandlerRegistry.RegisterHandler(Type handlerType)` instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public void CacheMethodForHandler(System.Type handler, System.Type messageType) { }
        public void Clear() { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Pipeline.MessageHandler> GetHandlersFor(System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `MessageHandlerRegistry.GetHandlersFor(Type messageType)` instead. Wil" +
            "l be removed in version 7.0.0.", true)]
        public System.Collections.Generic.IEnumerable<System.Type> GetHandlerTypes(System.Type messageType) { }
        public System.Collections.Generic.IEnumerable<System.Type> GetMessageTypes() { }
        [System.ObsoleteAttribute("Please use `MessageHandler.Invoke(object message, object context)` instead. Will " +
            "be removed in version 7.0.0.", true)]
        public void InvokeHandle(object handler, object message) { }
        [System.ObsoleteAttribute("Please use `MessageHandler.Invoke(object message, object context)` instead. Will " +
            "be removed in version 7.0.0.", true)]
        public void InvokeTimeout(object handler, object state) { }
        public void RegisterHandler(System.Type handlerType) { }
    }
    public class MessagesEventArgs : System.EventArgs
    {
        public MessagesEventArgs(object[] messages) { }
        public object[] Messages { get; }
    }
    [System.ObsoleteAttribute("Use context.Intent to detect of the message is a event being published and use co" +
        "ntext.MessageType to get the actual event type. Will be removed in version 7.0.0" +
        ".", true)]
    public class PublishOptions : NServiceBus.Unicast.DeliveryOptions
    {
        public PublishOptions() { }
    }
    [System.ObsoleteAttribute("Not used anymore, use the \'NServiceBus.MessageIntent\' header to detect if the mes" +
        "sage is a reply. Will be removed in version 7.0.0.", true)]
    public class ReplyOptions
    {
        public ReplyOptions() { }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.UnicastBus.SendMessageOptions` instead. Will be removed i" +
        "n version 7.0.0.", true)]
    public class SendOptions : NServiceBus.Unicast.DeliveryOptions
    {
        [System.ObsoleteAttribute("Please use `SendMessageOptions(string)` instead. Will be removed in version 7.0.0" +
            ".", true)]
        public SendOptions(NServiceBus.Address destination) { }
        [System.ObsoleteAttribute("Reply to address can be get/set using the `NServiceBus.CorrelationId` header. Wil" +
            "l be removed in version 7.0.0.", true)]
        public string CorrelationId { get; set; }
        [System.ObsoleteAttribute("Please use `DelayDeliveryFor` instead. Will be removed in version 7.0.0.", true)]
        public System.Nullable<System.TimeSpan> DelayDeliveryWith { get; set; }
    }
    [System.ObsoleteAttribute("UnicastBus has been made internal. Use IEndpointInstance instead. Will be removed" +
        " in version 7.0.0.", true)]
    public class UnicastBus
    {
        public UnicastBus() { }
    }
}
namespace NServiceBus.Unicast.Messages
{
    public class MessageMetadata
    {
        public MessageMetadata(System.Type messageType, System.Collections.Generic.IEnumerable<System.Type> messageHierarchy = null) { }
        public System.Collections.Generic.IEnumerable<System.Type> MessageHierarchy { get; }
        public System.Type MessageType { get; }
        [System.ObsoleteAttribute("You can access Recoverable via the DeliveryConstraints collection on the outgoing" +
            " context, the new constraint is called NonDurableDelivery. Will be removed in ve" +
            "rsion 7.0.0.", true)]
        public bool Recoverable { get; }
        [System.ObsoleteAttribute("You can access TTBR via the DeliveryConstraints collection on the outgoing contex" +
            "t. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class MessageMetadataRegistry
    {
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(System.Type messageType) { }
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(string messageTypeIdentifier) { }
    }
}
namespace NServiceBus.Unicast.Queuing
{
    [System.ObsoleteAttribute("Please use `QueueBindings` instead. Will be removed in version 7.0.0.", true)]
    public interface IWantQueueCreated { }
    public class QueueNotFoundException : System.Exception
    {
        public QueueNotFoundException() { }
        [System.ObsoleteAttribute("Please use `QueueNotFoundException(string queue, string message, Exception inner)" +
            "` instead. Will be removed in version 7.0.0.", true)]
        public QueueNotFoundException(NServiceBus.Address queue, string message, System.Exception inner) { }
        public QueueNotFoundException(string queue, string message, System.Exception inner) { }
        protected QueueNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public string Queue { get; set; }
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
}
namespace NServiceBus.Unicast.Routing
{
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class StaticMessageRouter
    {
        public StaticMessageRouter() { }
        [System.ObsoleteAttribute("Please use `config.AutoSubscribe().AutoSubscribePlainMessages()` instead. Will be" +
            " removed in version 7.0.0.", true)]
        public bool SubscribeToPlainMessages { get; set; }
    }
}
namespace NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions
{
    public interface IInitializableSubscriptionStorage : NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.ISubscriptionStorage
    {
        void Init();
    }
    public interface ISubscriptionStorage
    {
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber>> GetSubscriberAddressesForMessage(System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Subscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, NServiceBus.Unicast.Subscriptions.MessageType messageType, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, NServiceBus.Unicast.Subscriptions.MessageType messageType, NServiceBus.Extensibility.ContextBag context);
    }
    public class Subscriber
    {
        public Subscriber(string transportAddress, NServiceBus.Routing.EndpointName endpoint) { }
        public NServiceBus.Routing.EndpointName Endpoint { get; }
        public string TransportAddress { get; }
    }
}
namespace NServiceBus.Unicast.Subscriptions
{
    public class MessageType
    {
        public MessageType(System.Type type) { }
        public MessageType(string messageTypeString) { }
        public MessageType(string typeName, string versionString) { }
        public MessageType(string typeName, System.Version version) { }
        public string TypeName { get; }
        public System.Version Version { get; }
        public bool Equals(NServiceBus.Unicast.Subscriptions.MessageType other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class SubscriptionEventArgs
    {
        public SubscriptionEventArgs() { }
    }
}
namespace NServiceBus.Unicast.Transport
{
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class static ControlMessage { }
    public class static ControlMessageFactory
    {
        public static NServiceBus.Transports.OutgoingMessage Create(NServiceBus.MessageIntentEnum intent) { }
    }
    [System.ObsoleteAttribute("Use the pipeline to catch failures. Will be removed in version 7.0.0.", true)]
    public class FailedMessageProcessingEventArgs : System.EventArgs
    {
        public FailedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class FinishedMessageProcessingEventArgs : System.EventArgs
    {
        public FinishedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("Please use `IPushMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface ITransport { }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class StartedMessageProcessingEventArgs
    {
        public StartedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("Transaction settings is no longer available via this class. See obsoletes on indi" +
        "vidual members for further details. Will be removed in version 7.0.0.", true)]
    public class TransactionSettings
    {
        [System.ObsoleteAttribute("No longer used. Will be removed in version 7.0.0.", true)]
        public TransactionSettings(bool isTransactional, System.TimeSpan transactionTimeout, System.Transactions.IsolationLevel isolationLevel, bool suppressDistributedTransactions, bool doNotWrapHandlersExecutionInATransactionScope) { }
        [System.ObsoleteAttribute("DoNotWrapHandlersExecutionInATransactionScope is no longer used here. Use setting" +
            "s.GetOrDefault<bool>(\'Transactions.DoNotWrapHandlersExecutionInATransactionScope" +
            "\') instead. Will be removed in version 7.0.0.", true)]
        public bool DoNotWrapHandlersExecutionInATransactionScope { get; set; }
        [System.ObsoleteAttribute("Isolation level are now controlled explicitly for the transaction scope unit of w" +
            "ork using config.UnitOfWork().WrapHandlersInATransactionScope(isolationlevel: X)" +
            ". Will be removed in version 7.0.0.", true)]
        public System.Transactions.IsolationLevel IsolationLevel { get; set; }
        [System.ObsoleteAttribute("IsTransactional is no longer used here. Use `context.Settings.GetRequiredTransact" +
            "ionModeForReceives() != Transactions.None` instead. Will be removed in version 7" +
            ".0.0.", true)]
        public bool IsTransactional { get; set; }
        [System.ObsoleteAttribute("SuppressDistributedTransactions is no longer used here. Uuse `context.Settings.Ge" +
            "tRequiredTransactionModeForReceives() != Transactions.TransactionScope` instead." +
            " Will be removed in version 7.0.0.", true)]
        public bool SuppressDistributedTransactions { get; set; }
        [System.ObsoleteAttribute("Timeouts are now controlled explicitly for the transaction scope unit of work usi" +
            "ng config.UnitOfWork().WrapHandlersInATransactionScope(timeout: X). Will be remo" +
            "ved in version 7.0.0.", true)]
        public System.TimeSpan TransactionTimeout { get; set; }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportMessageAvailableEventArgs
    {
        public TransportMessageAvailableEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportMessageReceivedEventArgs
    {
        public TransportMessageReceivedEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportReceiver
    {
        public TransportReceiver() { }
    }
}
namespace NServiceBus.UnitOfWork
{
    public interface IManageUnitsOfWork
    {
        System.Threading.Tasks.Task Begin();
        System.Threading.Tasks.Task End(System.Exception ex = null);
    }
}