[assembly: System.CLSCompliantAttribute(true)]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.AcceptanceTesting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Core.Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Hosting.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.PerformanceTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"ReturnToSourceQueue, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.5.2", FrameworkDisplayName=".NET Framework 4.5.2")]
namespace NServiceBus
{
    [System.ObsoleteAttribute("Use the string based overloads. Will be removed in version 7.0.0.", true)]
    public class Address
    {
        public Address() { }
    }
    public enum AddressMode
    {
        Local = 0,
        Remote = 1,
    }
    [System.ObsoleteAttribute("Please use `BusConfiguration.ExcludeAssemblies` instead. Will be removed in versi" +
        "on 7.0.0.", true)]
    public class AllAssemblies
    {
        public AllAssemblies() { }
    }
    public class static AutoSubscribeSettingsExtensions
    {
        public static NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings AutoSubscribe(this NServiceBus.BusConfiguration config) { }
    }
    public interface BatchDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.BehaviorContext
    {
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> Operations { get; }
    }
    public class static BestPracticesOptionExtensions
    {
        public static void DoNotEnforceBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.OutgoingPipeline.OutgoingReplyContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.OutgoingPipeline.OutgoingSendContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Routing.SubscribeContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.OutgoingPipeline.OutgoingPublishContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Routing.UnsubscribeContext context) { }
    }
    public class static Bus
    {
        [System.ObsoleteAttribute("Please use `Endpoint.Create` instead. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.IStartableBus Create(NServiceBus.BusConfiguration configuration) { }
        [System.ObsoleteAttribute("Please use `BusConfiguration.SendOnly` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static NServiceBus.IBus CreateSendOnly(NServiceBus.BusConfiguration configuration) { }
    }
    [System.ObsoleteAttribute("No longer used, please use the new callbacks api described in the v6 upgrade guid" +
        "e. Will be removed in version 7.0.0.", true)]
    public class BusAsyncResultEventArgs
    {
        public BusAsyncResultEventArgs() { }
    }
    public class BusConfiguration : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public BusConfiguration() { }
        [System.ObsoleteAttribute("Please use `SetOutgoingHeaders(string key,string value)` instead. Will be removed" +
            " in version 7.0.0.", true)]
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        [System.ObsoleteAttribute("Please use `ExcludeAssemblies` instead. Will be removed in version 7.0.0.", true)]
        public void AssembliesToScan(System.Collections.Generic.IEnumerable<System.Reflection.Assembly> assemblies) { }
        [System.ObsoleteAttribute("Please use `ExcludeAssemblies` instead. Will be removed in version 7.0.0.", true)]
        public void AssembliesToScan(params System.Reflection.Assembly[] assemblies) { }
        public NServiceBus.ConventionsBuilder Conventions() { }
        public void CustomConfigurationSource(NServiceBus.Config.ConfigurationSource.IConfigurationSource configurationSource) { }
        public void EndpointName(string name) { }
        public void ExcludeAssemblies(params string[] assemblies) { }
        public void ExcludeTypes(params System.Type[] types) { }
        [System.ObsoleteAttribute("Please use `UseCustomLogicalToTransportAddressTranslation` instead. Will be remov" +
            "ed in version 7.0.0.", true)]
        public void OverrideLocalAddress(string queue) { }
        public void OverridePublicReturnAddress(string address) { }
        [System.ObsoleteAttribute("Please use `OverridePublicReturnAddress(string address)` instead. Will be removed" +
            " in version 7.0.0.", true)]
        public void OverridePublicReturnAddress(NServiceBus.Address address) { }
        public void RegisterComponents(System.Action<NServiceBus.ObjectBuilder.IConfigureComponents> registration) { }
        public void RunWhenEndpointStartsAndStops(NServiceBus.IWantToRunWhenBusStartsAndStops callbackObject) { }
        [System.ObsoleteAttribute("Please use `ExcludeAssemblies` instead. Will be removed in version 7.0.0.", true)]
        public void ScanAssembliesInDirectory(string probeDirectory) { }
        public void ScanAssembliesInNestedDirectories() { }
        public void SendOnly() { }
        [System.ObsoleteAttribute("Please use `ExcludeTypes` instead. Will be removed in version 7.0.0.", true)]
        public void TypesToScan(System.Collections.Generic.IEnumerable<System.Type> typesToScan) { }
        public void UseContainer<T>(System.Action<NServiceBus.Container.ContainerCustomizations> customizations = null)
            where T : NServiceBus.Container.ContainerDefinition, new () { }
        public void UseContainer(System.Type definitionType) { }
        public void UseContainer(NServiceBus.ObjectBuilder.Common.IContainer builder) { }
        public void UseCustomLogicalToTransportAddressTranslation(System.Func<NServiceBus.LogicalAddress, string, string> translation) { }
    }
    public class BusNotifications : System.IDisposable
    {
        public BusNotifications() { }
        public NServiceBus.Faults.ErrorsNotifications Errors { get; }
        [System.ObsoleteAttribute("For performance reasons it is no longer possible to instrument the pipeline execu" +
            "tion. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PipelineNotifications Pipeline { get; }
    }
    [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
    public class CompletionResult
    {
        public CompletionResult() { }
    }
    public class static ConfigurationBuilderExtensions
    {
        public static void DisableFeature<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void DisableFeature(this NServiceBus.BusConfiguration config, System.Type featureType) { }
        public static void EnableFeature<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void EnableFeature(this NServiceBus.BusConfiguration config, System.Type featureType) { }
    }
    public class static ConfigurationTimeoutExtensions
    {
        public static void TimeToWaitBeforeTriggeringCriticalErrorOnTimeoutOutages(this NServiceBus.BusConfiguration config, System.TimeSpan timeToWait) { }
    }
    [System.ObsoleteAttribute("This is no longer a public API. Will be removed in version 7.0.0.", true)]
    public class Configure
    {
        public Configure() { }
    }
    public class static ConfigureAudit
    {
        public static void AuditProcessedMessagesTo(this NServiceBus.BusConfiguration config, string auditQueue, System.Nullable<System.TimeSpan> timeToBeReceived = null) { }
    }
    public class static ConfigureCriticalErrorAction
    {
        public static void DefineCriticalErrorAction(this NServiceBus.BusConfiguration busConfiguration, NServiceBus.CriticalErrorAction onCriticalError) { }
    }
    public class static ConfigureError
    {
        public static void SendFailedMessagesTo(this NServiceBus.BusConfiguration config, string errorQueue) { }
    }
    public class static ConfigureFileShareDataBus
    {
        public static NServiceBus.DataBus.DataBusExtentions<NServiceBus.FileShareDataBus> BasePath(this NServiceBus.DataBus.DataBusExtentions<NServiceBus.FileShareDataBus> config, string basePath) { }
    }
    public class static ConfigureHandlerSettings
    {
        public static void InitializeHandlerProperty<THandler>(this NServiceBus.BusConfiguration config, string property, object value) { }
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class static ConfigureInMemoryFaultManagement
    {
        [System.ObsoleteAttribute("This is no longer supported. If you want full control over what happens when a me" +
            "ssage fails (including retries) please override the MoveFaultsToErrorQueue behav" +
            "ior. Will be removed in version 7.0.0.", true)]
        public static void DiscardFailedMessagesInsteadOfSendingToErrorQueue(this NServiceBus.BusConfiguration config) { }
    }
    public class static ConfigureLicenseExtensions
    {
        public static void License(this NServiceBus.BusConfiguration config, string licenseText) { }
        public static void LicensePath(this NServiceBus.BusConfiguration config, string licenseFile) { }
    }
    public class static ConfigurePurging
    {
        public static void PurgeOnStartup(this NServiceBus.BusConfiguration config, bool value) { }
        [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
        public static bool PurgeOnStartup(this NServiceBus.Configure config) { }
    }
    public class static ConfigureQueueCreation
    {
        [System.ObsoleteAttribute("Please use `CreateQueues` instead. Will be removed in version 7.0.0.", true)]
        public static bool CreateQueues(this NServiceBus.Configure config) { }
        public static bool CreateQueues(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static void DoNotCreateQueues(this NServiceBus.BusConfiguration config) { }
    }
    public class static ConfigureRijndaelEncryptionService
    {
        public static void RegisterEncryptionService(this NServiceBus.BusConfiguration config, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Encryption.IEncryptionService> func) { }
        public static void RijndaelEncryptionService(this NServiceBus.BusConfiguration config) { }
        public static void RijndaelEncryptionService(this NServiceBus.BusConfiguration config, string encryptionKey, System.Collections.Generic.List<string> expiredKeys = null) { }
    }
    public class static ConfigureTransportConnectionString
    {
        [System.ObsoleteAttribute("Not available any more. Will be removed in version 7.0.0.", true)]
        public static string TransportConnectionString(this NServiceBus.Configure config) { }
    }
    public abstract class ContainSagaData : NServiceBus.IContainSagaData
    {
        protected ContainSagaData() { }
        public virtual System.Guid Id { get; set; }
        public virtual string OriginalMessageId { get; set; }
        public virtual string Originator { get; set; }
    }
    public class static ContentTypes
    {
        public const string Json = "application/json";
        public const string Xml = "text/xml";
    }
    public class Conventions
    {
        public Conventions() { }
        public void AddSystemMessagesConventions(System.Func<System.Type, bool> definesMessageType) { }
        [System.ObsoleteAttribute("No longer an extension point. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan GetTimeToBeReceived(System.Type messageType) { }
        public bool IsCommandType(System.Type t) { }
        public bool IsDataBusProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEncryptedProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEventType(System.Type t) { }
        [System.ObsoleteAttribute("No longer an extension point. Will be removed in version 7.0.0.", true)]
        public static bool IsExpressMessageType(System.Type t) { }
        public bool IsInSystemConventionList(System.Type t) { }
        public bool IsMessageType(System.Type t) { }
    }
    public class ConventionsBuilder : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.ConventionsBuilder DefiningCommandsAs(System.Func<System.Type, bool> definesCommandType) { }
        public NServiceBus.ConventionsBuilder DefiningDataBusPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesDataBusProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEncryptedPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesEncryptedProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEventsAs(System.Func<System.Type, bool> definesEventType) { }
        public NServiceBus.ConventionsBuilder DefiningMessagesAs(System.Func<System.Type, bool> definesMessageType) { }
    }
    public class static CorrelationContextExtensions
    {
        public static void SetCorrelationId(this NServiceBus.SendOptions options, string correlationId) { }
        public static void SetCorrelationId(this NServiceBus.ReplyOptions options, string correlationId) { }
    }
    public class CriticalError
    {
        public CriticalError(NServiceBus.CriticalErrorAction onCriticalErrorAction) { }
        public virtual void Raise(string errorMessage, System.Exception exception) { }
    }
    public delegate System.Threading.Tasks.Task CriticalErrorAction(NServiceBus.IEndpointInstance endpoint, string error, System.Exception exception);
    public class static CriticalTimeMonitoringConfig
    {
        public static void EnableCriticalTimePerformanceCounter(this NServiceBus.BusConfiguration config) { }
    }
    public class DataBusProperty<T> : NServiceBus.IDataBusProperty, System.Runtime.Serialization.ISerializable
        where T :  class
    {
        public DataBusProperty(T value) { }
        protected DataBusProperty(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public bool HasValue { get; set; }
        public string Key { get; set; }
        public T Value { get; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public object GetValue() { }
        public void SetValue(object valueToSet) { }
    }
    public class static DateTimeExtensions
    {
        public static System.DateTime ToUtcDateTime(string wireFormattedString) { }
        public static string ToWireFormattedString(System.DateTime dateTime) { }
    }
    public class static DelayedDeliveryOptionExtensions
    {
        public static void DelayDeliveryWith(this NServiceBus.SendOptions options, System.TimeSpan delay) { }
        public static void DoNotDeliverBefore(this NServiceBus.SendOptions options, System.DateTime at) { }
    }
    public enum DependencyLifecycle
    {
        SingleInstance = 0,
        InstancePerUnitOfWork = 1,
        InstancePerCall = 2,
    }
    public interface DispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.BehaviorContext
    {
        System.Collections.Generic.IEnumerable<NServiceBus.Transports.TransportOperation> Operations { get; }
    }
    public class static DurableMessagesConfig
    {
        public static void DisableDurableMessages(this NServiceBus.BusConfiguration config) { }
        public static bool DurableMessagesEnabled(this NServiceBus.Settings.ReadOnlySettings settings) { }
        [System.ObsoleteAttribute("Please use `DurableMessagesEnabled` instead. Will be removed in version 7.0.0.", true)]
        public static bool DurableMessagesEnabled(this NServiceBus.Configure config) { }
        public static void EnableDurableMessages(this NServiceBus.BusConfiguration config) { }
    }
    public class static DurableMessagesConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningExpressMessagesAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, bool> definesExpressMessageType) { }
    }
    public class EncryptedValue
    {
        public EncryptedValue() { }
        public string Base64Iv { get; set; }
        public string EncryptedBase64Value { get; set; }
    }
    public sealed class Endpoint
    {
        public Endpoint(string name) { }
        public static System.Threading.Tasks.Task<NServiceBus.IStartableEndpoint> Create(NServiceBus.BusConfiguration configuration) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public static NServiceBus.IInitializableEndpoint Prepare(NServiceBus.BusConfiguration configuration) { }
        public static async System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start(NServiceBus.BusConfiguration configuration) { }
        public override string ToString() { }
    }
    public sealed class EndpointInstance
    {
        public EndpointInstance(string endpoint, string userDiscriminator, string transportDiscriminator) { }
        public EndpointInstance(NServiceBus.Endpoint endpoint, string userDiscriminator, string transportDiscriminator) { }
        public NServiceBus.Endpoint Endpoint { get; }
        public string TransportDiscriminator { get; }
        public string UserDiscriminator { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class ExpressAttribute : System.Attribute
    {
        public ExpressAttribute() { }
    }
    [System.ObsoleteAttribute("Headers are not managed via the send, reply and publishoptions. Will be removed i" +
        "n version 7.0.0.", true)]
    public class static ExtensionMethods
    {
        [System.ObsoleteAttribute("Use a incoming behavior to get access to the current message. Will be removed in " +
            "version 7.0.0.", true)]
        public static object CurrentMessageBeingHandled { get; set; }
        [System.ObsoleteAttribute("Headers are not \'set\' only on the outgoing pipeline. Will be removed in version 7" +
            ".0.0.", true)]
        public static string GetMessageHeader(this NServiceBus.IBus bus, object msg, string key) { }
        [System.ObsoleteAttribute("Headers can be set using the ``.SetHeader` method on the context object passed in" +
            "to your behavior or mutator. Will be removed in version 7.0.0.", true)]
        public static void SetMessageHeader(this NServiceBus.IBusContextFactory bus, object msg, string key, string value) { }
    }
    public class static FileBasedRoutingConfigurationExtensions
    {
        public static NServiceBus.FileRoutingTableSettings UseFileBasedEndpointInstanceLists(this NServiceBus.RoutingSettings config) { }
    }
    public class FileRoutingTableSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public FileRoutingTableSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public void LookForFilesIn(string path) { }
    }
    public class FileShareDataBus : NServiceBus.DataBus.DataBusDefinition
    {
        public FileShareDataBus() { }
        protected internal override System.Type ProvidedByFeature() { }
    }
    [System.ObsoleteAttribute("Please use `BusConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed " +
        "in version 7.0.0.", true)]
    public class First<T>
    {
        public First() { }
    }
    public class static HeaderOptionExtensions
    {
        public static void SetHeader(this NServiceBus.Extensibility.ExtendableOptions context, string key, string value) { }
    }
    public class static Headers
    {
        public const string ContentType = "NServiceBus.ContentType";
        public const string ControlMessageHeader = "NServiceBus.ControlMessage";
        public const string ConversationId = "NServiceBus.ConversationId";
        public const string CorrelationId = "NServiceBus.CorrelationId";
        public const string DestinationSites = "NServiceBus.DestinationSites";
        public const string EnclosedMessageTypes = "NServiceBus.EnclosedMessageTypes";
        public const string FLRetries = "NServiceBus.FLRetries";
        public const string HasLicenseExpired = "$.diagnostics.license.expired";
        public const string HeaderName = "Header";
        public const string HostDisplayName = "$.diagnostics.hostdisplayname";
        public const string HostId = "$.diagnostics.hostid";
        public const string HttpFrom = "NServiceBus.From";
        public const string HttpTo = "NServiceBus.To";
        public const string IsDeferredMessage = "NServiceBus.IsDeferredMessage";
        public const string IsSagaTimeoutMessage = "NServiceBus.IsSagaTimeoutMessage";
        public const string MessageId = "NServiceBus.MessageId";
        public const string MessageIntent = "NServiceBus.MessageIntent";
        public const string NonDurableMessage = "NServiceBus.NonDurableMessage";
        public const string NServiceBusVersion = "NServiceBus.Version";
        public const string OriginatingAddress = "NServiceBus.OriginatingAddress";
        public const string OriginatingEndpoint = "NServiceBus.OriginatingEndpoint";
        public const string OriginatingHostId = "$.diagnostics.originating.hostid";
        public const string OriginatingMachine = "NServiceBus.OriginatingMachine";
        public const string OriginatingSagaId = "NServiceBus.OriginatingSagaId";
        public const string OriginatingSagaType = "NServiceBus.OriginatingSagaType";
        public const string OriginatingSite = "NServiceBus.OriginatingSite";
        public const string ProcessingEnded = "NServiceBus.ProcessingEnded";
        public const string ProcessingEndpoint = "NServiceBus.ProcessingEndpoint";
        public const string ProcessingMachine = "NServiceBus.ProcessingMachine";
        public const string ProcessingStarted = "NServiceBus.ProcessingStarted";
        public const string RelatedTo = "NServiceBus.RelatedTo";
        public const string ReplyToAddress = "NServiceBus.ReplyToAddress";
        public const string Retries = "NServiceBus.Retries";
        public const string ReturnMessageErrorCodeHeader = "NServiceBus.ReturnMessage.ErrorCode";
        public const string RouteTo = "NServiceBus.Header.RouteTo";
        public const string SagaId = "NServiceBus.SagaId";
        public const string SagaType = "NServiceBus.SagaType";
        public const string SubscriberEndpoint = "NServiceBus.SubscriberEndpoint";
        public const string SubscriberTransportAddress = "NServiceBus.SubscriberAddress";
        public const string SubscriptionMessageType = "SubscriptionMessageType";
        public const string TimeSent = "NServiceBus.TimeSent";
        public const string TimeToBeReceived = "NServiceBus.TimeToBeReceived";
        [System.ObsoleteAttribute("The WinIdName header is no longer attached to outgoing message to avoid passing s" +
            "ecurity related information on the wire. Should you rely on the header being pre" +
            "sent you can add a message mutator that sets it. Will be removed in version 7.0." +
            "0.", true)]
        public const string WindowsIdentityName = "WinIdName";
    }
    public class static HostInfoConfigurationExtensions
    {
        public static NServiceBus.HostInfoSettings UniquelyIdentifyRunningInstance(this NServiceBus.BusConfiguration config) { }
    }
    public class HostInfoSettings
    {
        public NServiceBus.HostInfoSettings UsingCustomDisplayName(string displayName) { }
        public NServiceBus.HostInfoSettings UsingCustomIdentifier(System.Guid id) { }
        public NServiceBus.HostInfoSettings UsingInstalledFilePath() { }
        public NServiceBus.HostInfoSettings UsingNames(string instanceName, string hostName) { }
    }
    public interface IAmStartedByMessages<T> : NServiceBus.IHandleMessages<T> { }
    [System.ObsoleteAttribute("Please use `config.UseTransport<MsmqTransport>().SubscriptionAuthorizer(Authorize" +
        "r);` instead. Will be removed in version 7.0.0.", true)]
    public interface IAuthorizeSubscriptions { }
    [System.ObsoleteAttribute("When in context of handler use IMessageHandlingContext. Otherwise use IBusContext" +
        "Factory to create sending context. Will be removed in version 7.0.0.", true)]
    public interface IBus { }
    public interface IBusContext : NServiceBus.Extensibility.IExtendable
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.SubscribeOptions options);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.UnsubscribeOptions options);
    }
    public class static IBusContextExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IBusContext context, object message) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IBusContext context) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IBusContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IBusContext context, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IBusContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IBusContext context, string destination, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IBusContext context, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IBusContext context, object message) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IBusContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Subscribe(this NServiceBus.IBusContext context, System.Type messageType) { }
        public static System.Threading.Tasks.Task Subscribe<T>(this NServiceBus.IBusContext context) { }
        public static System.Threading.Tasks.Task Unsubscribe(this NServiceBus.IBusContext context, System.Type messageType) { }
        public static System.Threading.Tasks.Task Unsubscribe<T>(this NServiceBus.IBusContext context) { }
    }
    public interface IBusContextFactory
    {
        NServiceBus.IBusContext CreateBusContext();
    }
    public class static IBusExtensions
    {
        [System.ObsoleteAttribute("Please use `IMessageHandlerContext.DoNotContinueDispatchingCurrentMessageToHandle" +
            "rs()` provided to message handlers instead. Will be removed in version 7.0.0.", true)]
        public static void DoNotContinueDispatchingCurrentMessageToHandlers(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Please use `IMessageHandlerContext.ForwardCurrentMessageTo(string destination)` p" +
            "rovided to message handlers instead. Will be removed in version 7.0.0.", true)]
        public static void ForwardCurrentMessageTo(this NServiceBus.IBus bus, string destination) { }
        [System.ObsoleteAttribute("Please use `IMessageHandlerContext.HandleCurrentMessageLater()` provided to messa" +
            "ge handlers instead. Will be removed in version 7.0.0.", true)]
        public static void HandleCurrentMessageLater(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Please use `IMessageHandlerContext.Reply(object message)` provided to message han" +
            "dlers instead. Will be removed in version 7.0.0.", true)]
        public static void Reply(this NServiceBus.IBus bus, object message) { }
        [System.ObsoleteAttribute("Please use `IMessageHandlerContext.Reply<T>(Action<T> messageConstructor)` provid" +
            "ed to message handlers instead. Will be removed in version 7.0.0.", true)]
        public static void Reply<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `IMessageHandlerContext.SendLocal(object message)` provided to message" +
            " handlers instead. Will be removed in version 7.0.0.", true)]
        public static void SendLocal(this NServiceBus.IBus bus, object message) { }
        [System.ObsoleteAttribute("Please use `IMessageHandlerContext.SendLocal<T>(Action<T> messageConstructor)` pr" +
            "ovided to message handlers instead. Will be removed in version 7.0.0.", true)]
        public static void SendLocal<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `Subscribe(Type messageType)` instead. Will be removed in version 7.0." +
            "0.", true)]
        public static void Subscribe(this NServiceBus.IBus bus, System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `Subscribe<T>()` instead. Will be removed in version 7.0.0.", true)]
        public static void Subscribe<T>(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Please use `Unsubscribe(Type messageType)` instead. Will be removed in version 7." +
            "0.0.", true)]
        public static void Unsubscribe(this NServiceBus.IBus bus, System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `Unsubscribe<T>()` instead. Will be removed in version 7.0.0.", true)]
        public static void Unsubscribe<T>(this NServiceBus.IBus bus) { }
    }
    [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
    public interface ICallback { }
    public interface ICommand : NServiceBus.IMessage { }
    public interface IConfigureHowToFindSagaWithMessage
    {
        void ConfigureMapping<TSagaEntity, TMessage>(System.Linq.Expressions.Expression<System.Func<TSagaEntity, object>> sagaEntityProperty, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty)
            where TSagaEntity : NServiceBus.IContainSagaData
        ;
    }
    public interface IContainSagaData
    {
        System.Guid Id { get; set; }
        string OriginalMessageId { get; set; }
        string Originator { get; set; }
    }
    public interface IDataBusProperty
    {
        bool HasValue { get; set; }
        string Key { get; set; }
        object GetValue();
        void SetValue(object value);
    }
    public interface IEndpointInstance : NServiceBus.IBusContextFactory
    {
        System.Threading.Tasks.Task Stop();
    }
    public interface IEvent : NServiceBus.IMessage { }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public interface IExcludesBuilder { }
    public interface IHandleMessages<T>
    {
        System.Threading.Tasks.Task Handle(T message, NServiceBus.IMessageHandlerContext context);
    }
    public interface IHandleTimeouts<T>
    {
        System.Threading.Tasks.Task Timeout(T state, NServiceBus.IMessageHandlerContext context);
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public interface IIncludesBuilder { }
    public interface IInitializableEndpoint
    {
        System.Threading.Tasks.Task<NServiceBus.IStartableEndpoint> Initialize();
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public interface IManageMessageHeaders { }
    public interface IMessage { }
    [System.ObsoleteAttribute("Please use `IMessageHandlerContext` provided to message handlers instead. Will be" +
        " removed in version 7.0.0.", true)]
    public interface IMessageContext { }
    public interface IMessageCreator
    {
        T CreateInstance<T>();
        T CreateInstance<T>(System.Action<T> action);
        object CreateInstance(System.Type messageType);
    }
    public interface IMessageHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.IMessageProcessingContext
    {
        NServiceBus.Persistence.SynchronizedStorageSession SynchronizedStorageSession { get; }
        void DoNotContinueDispatchingCurrentMessageToHandlers();
        System.Threading.Tasks.Task HandleCurrentMessageLater();
    }
    public interface IMessageProcessingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext
    {
        System.Collections.Generic.IReadOnlyDictionary<string, string> MessageHeaders { get; }
        string MessageId { get; }
        string ReplyToAddress { get; }
        System.Threading.Tasks.Task ForwardCurrentMessageTo(string destination);
        System.Threading.Tasks.Task Reply(object message, NServiceBus.ReplyOptions options);
        System.Threading.Tasks.Task Reply<T>(System.Action<T> messageConstructor, NServiceBus.ReplyOptions options);
    }
    public class static IMessageProcessingContextExtensions
    {
        public static System.Threading.Tasks.Task Reply(this NServiceBus.IMessageProcessingContext context, object message) { }
        public static System.Threading.Tasks.Task Reply<T>(this NServiceBus.IMessageProcessingContext context, System.Action<T> messageConstructor) { }
    }
    public class static ImmediateDispatchOptionExtensions
    {
        public static void RequireImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public interface IncomingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.IMessageProcessingContext, NServiceBus.Pipeline.BehaviorContext, NServiceBus.Pipeline.Contexts.IncomingContext
    {
        NServiceBus.Transports.IncomingMessage Message { get; }
    }
    public interface INeedInitialization
    {
        void Customize(NServiceBus.BusConfiguration configuration);
    }
    public class InMemoryPersistence : NServiceBus.Persistence.PersistenceDefinition { }
    public class static InstallConfigExtensions
    {
        public static void EnableInstallers(this NServiceBus.BusConfiguration config, string username = null) { }
    }
    [System.ObsoleteAttribute("Use IBusContextFactory to create sending context. Will be removed in version 7.0." +
        "0.", true)]
    public interface ISendOnlyBus : System.IDisposable { }
    [System.ObsoleteAttribute("Please use `BusConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed " +
        "in version 7.0.0.", true)]
    public interface ISpecifyMessageHandlerOrdering { }
    [System.ObsoleteAttribute("Please use `IStartableEndpoint` instead. Will be removed in version 7.0.0.", true)]
    public interface IStartableBus : NServiceBus.IBus
    {
        [System.ObsoleteAttribute("Please use `IStartableEndpoint` instead. Will be removed in version 7.0.0.", true)]
        NServiceBus.IBus Start();
    }
    public interface IStartableEndpoint
    {
        System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start();
    }
    public interface IWantToRunBeforeConfigurationIsFinalized
    {
        void Run(NServiceBus.Settings.SettingsHolder settings);
    }
    public interface IWantToRunWhenBusStartsAndStops
    {
        System.Threading.Tasks.Task Start(NServiceBus.IBusContext context);
        System.Threading.Tasks.Task Stop(NServiceBus.IBusContext context);
    }
    public class JsonSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public JsonSerializer() { }
        protected internal override System.Type ProvidedByFeature() { }
    }
    public class static JsonSerializerConfigurationExtensions
    {
        public static void Encoding(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.JsonSerializer> config, System.Text.Encoding encoding) { }
    }
    public class static LoadMessageHandlersExtentions
    {
        public static void ExecuteTheseHandlersFirst(this NServiceBus.BusConfiguration config, System.Collections.Generic.IEnumerable<System.Type> handlerTypes) { }
        public static void ExecuteTheseHandlersFirst(this NServiceBus.BusConfiguration config, params System.Type[] handlerTypes) { }
        [System.ObsoleteAttribute("Please use `ExecuteTheseHandlersFirst` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static void LoadMessageHandlers<TFirst>(this NServiceBus.BusConfiguration config) { }
        [System.ObsoleteAttribute("Please use `ExecuteTheseHandlersFirst` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static void LoadMessageHandlers<T>(this NServiceBus.BusConfiguration config, NServiceBus.First<T> order) { }
    }
    public sealed class LogicalAddress
    {
        public LogicalAddress(NServiceBus.EndpointInstance endpointInstance, string qualifier) { }
        public LogicalAddress(NServiceBus.EndpointInstance endpointInstance) { }
        public NServiceBus.EndpointInstance EndpointInstance { get; }
        public string Qualifier { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class MessageDeserializationException : System.Runtime.Serialization.SerializationException
    {
        public MessageDeserializationException(string message) { }
        public MessageDeserializationException(string transportMessageId, System.Exception innerException) { }
        protected MessageDeserializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static MessageDrivenSubscriptionsConfigExtensions
    {
        public static void SubscriptionAuthorizer(this NServiceBus.TransportExtensions transportExtensions, NServiceBus.SubscriptionAuthorizer authorizer) { }
        public static void UseLegacyMessageDrivenSubscriptionMode(this NServiceBus.BusConfiguration busConfiguration) { }
    }
    public class static MessageIdExtensions
    {
        public static void SetMessageId(this NServiceBus.Extensibility.ExtendableOptions context, string messageId) { }
    }
    public enum MessageIntentEnum
    {
        Send = 1,
        Publish = 2,
        Subscribe = 3,
        Unsubscribe = 4,
        Reply = 5,
    }
    public class MessageProcessingAbortedException : System.Exception
    {
        public MessageProcessingAbortedException() { }
        protected MessageProcessingAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static MessageProcessingOptimizationExtensions
    {
        public static void LimitMessageProcessingConcurrencyTo(this NServiceBus.BusConfiguration config, int maxConcurrency) { }
    }
    public class static MsmqConfigurationExtensions
    {
        public static void ApplyLabelToMessages(this NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> transportExtensions, NServiceBus.MsmqLabelGenerator labelGenerator) { }
    }
    public delegate string MsmqLabelGenerator(System.Collections.Generic.IReadOnlyDictionary<string, string> headers);
    public class MsmqTransport : NServiceBus.Transports.TransportDefinition
    {
        public MsmqTransport() { }
        public override string ExampleConnectionStringForErrorMessage { get; }
        public override bool RequiresConnectionString { get; }
        protected internal override NServiceBus.Transports.TransportReceivingConfigurationResult ConfigureForReceiving(NServiceBus.Transports.TransportReceivingConfigurationContext context) { }
        protected internal override NServiceBus.Transports.TransportSendingConfigurationResult ConfigureForSending(NServiceBus.Transports.TransportSendingConfigurationContext context) { }
        public override string GetDiscriminatorForThisEndpointInstance(NServiceBus.Settings.ReadOnlySettings settings) { }
        public override NServiceBus.Transports.OutboundRoutingPolicy GetOutboundRoutingPolicy(NServiceBus.Settings.ReadOnlySettings settings) { }
        public override NServiceBus.Transports.IManageSubscriptions GetSubscriptionManager() { }
        public override System.Collections.Generic.IEnumerable<System.Type> GetSupportedDeliveryConstraints() { }
        public override NServiceBus.Transports.TransactionSupport GetTransactionSupport() { }
        public override string ToTransportAddress(NServiceBus.LogicalAddress logicalAddress) { }
    }
    public class NonDurableDelivery : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public NonDurableDelivery() { }
    }
    [System.ObsoleteAttribute("Please use `BusConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed " +
        "in version 7.0.0.", true)]
    public class Order
    {
        public Order() { }
    }
    public class static OutboxConfigExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings EnableOutbox(this NServiceBus.BusConfiguration config) { }
    }
    public class static PersistenceConfig
    {
        public static NServiceBus.PersistenceExtentions<T> UsePersistence<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition { }
        public static NServiceBus.PersistenceExtentions<T, S> UsePersistence<T, S>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition
            where S : NServiceBus.Persistence.StorageType { }
        public static NServiceBus.PersistenceExtentions UsePersistence(this NServiceBus.BusConfiguration config, System.Type definitionType) { }
    }
    public class PersistenceExtentions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public PersistenceExtentions(System.Type definitionType, NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
        [System.ObsoleteAttribute("Please use `UsePersistence<T, S>()` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PersistenceExtentions For(params NServiceBus.Persistence.Storage[] specificStorages) { }
    }
    public class PersistenceExtentions<T> : NServiceBus.PersistenceExtentions
        where T : NServiceBus.Persistence.PersistenceDefinition
    {
        public PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings) { }
        protected PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
        [System.ObsoleteAttribute("Please use `UsePersistence<T, S>()` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PersistenceExtentions<T> For(params NServiceBus.Persistence.Storage[] specificStorages) { }
    }
    public class PersistenceExtentions<T, S> : NServiceBus.PersistenceExtentions<T>
        where T : NServiceBus.Persistence.PersistenceDefinition
        where S : NServiceBus.Persistence.StorageType
    {
        public PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    [System.ObsoleteAttribute("For performance reasons it is no longer possible to instrument the pipeline execu" +
        "tion. Will be removed in version 7.0.0.", true)]
    public class PipelineNotifications
    {
        public PipelineNotifications() { }
    }
    public class static PublishersSettingsExtensions
    {
        public static NServiceBus.Routing.MessageDrivenSubscriptions.Publishers Pubishers(this NServiceBus.BusConfiguration config) { }
    }
    public class PublishOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public PublishOptions() { }
    }
    public class ReplyOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public ReplyOptions() { }
    }
    public class static RoutingOptionExtensions
    {
        public static void OverrideReplyToAddressOfIncomingMessage(this NServiceBus.ReplyOptions option, string destination) { }
        public static void RouteToLocalEndpointInstance(this NServiceBus.SendOptions option) { }
        public static void SetDestination(this NServiceBus.SendOptions option, string destination) { }
    }
    public class RoutingSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.Routing.EndpointInstances EndpointInstances { get; }
        public NServiceBus.Transports.TransportAddresses TransportAddresses { get; }
        public NServiceBus.Routing.UnicastRoutingTable UnicastRoutingTable { get; }
        public void SetMessageDistributionStrategy(NServiceBus.Routing.DistributionStrategy distributionStrategy, System.Func<System.Type, bool> typeMatchingRule) { }
    }
    public class static RoutingSettingsExtensions
    {
        public static NServiceBus.RoutingSettings Routing(this NServiceBus.BusConfiguration config) { }
    }
    public abstract class Saga
    {
        protected Saga() { }
        public bool Completed { get; }
        public NServiceBus.IContainSagaData Entity { get; set; }
        protected internal abstract void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
        protected void MarkAsComplete() { }
        protected System.Threading.Tasks.Task ReplyToOriginator(NServiceBus.IMessageHandlerContext context, object message) { }
        [System.ObsoleteAttribute("Please use `ReplyToOriginator(IMessageHandlerContext, object)` instead. Will be r" +
            "emoved in version 7.0.0.", true)]
        protected void ReplyToOriginator(object message) { }
        [System.ObsoleteAttribute("Construct your message and pass it to the non Action overload. Please use `ReplyT" +
            "oOriginator(IMessageHandlerContext, object)` instead. Will be removed in version" +
            " 7.0.0.", true)]
        protected virtual void ReplyToOriginator<TMessage>(System.Action<TMessage> messageConstructor) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTime at)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
        [System.ObsoleteAttribute("Please use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, DateTime)" +
            "` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at) { }
        [System.ObsoleteAttribute("Construct your message and pass it to the non Action overload. Please use `Reques" +
            "tTimeout<TTimeoutMessageType>(IMessageHandlerContext DateTime, TTimeoutMessageTy" +
            "pe)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at, System.Action<TTimeoutMessageType> action) { }
        [System.ObsoleteAttribute("Please use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, DateTime," +
            " TTimeoutMessageType)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        [System.ObsoleteAttribute("Please use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan)" +
            "` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within) { }
        [System.ObsoleteAttribute("Construct your message and pass it to the non Action overload. Please use `Saga.R" +
            "equestTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan, TTimeoutMes" +
            "sageType)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within, System.Action<TTimeoutMessageType> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan," +
            " TTimeoutMessageType)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
    }
    public abstract class Saga<TSagaData> : NServiceBus.Saga
        where TSagaData : NServiceBus.IContainSagaData, new ()
    {
        protected Saga() { }
        public TSagaData Data { get; set; }
        protected internal override void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration) { }
        protected abstract void ConfigureHowToFindSaga(NServiceBus.SagaPropertyMapper<TSagaData> mapper);
    }
    public class SagaPropertyMapper<TSagaData>
        where TSagaData : NServiceBus.IContainSagaData
    {
        public NServiceBus.ToSagaExpression<TSagaData, TMessage> ConfigureMapping<TMessage>(System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
    }
    public abstract class SatelliteBehavior : NServiceBus.Pipeline.PipelineTerminator<NServiceBus.IncomingPhysicalMessageContext>
    {
        protected SatelliteBehavior() { }
    }
    public class static ScaleOutExtentions
    {
        public static NServiceBus.Settings.ScaleOutSettings ScaleOut(this NServiceBus.BusConfiguration config) { }
    }
    [System.ObsoleteAttribute("Use extension methods provided on ISendOnlyBus. Will be removed in version 7.0.0." +
        "", true)]
    public class Schedule
    {
        public Schedule() { }
    }
    public class static ScheduleBusExtensions
    {
        [System.ObsoleteAttribute("Please use `ScheduleEvery(this IBusContext context, TimeSpan timeSpan, Func<IBusC" +
            "ontext, Task> task)` instead. Will be removed in version 7.0.0.", true)]
        public static void ScheduleEvery(this NServiceBus.IBusContext context, System.TimeSpan timeSpan, System.Action task) { }
        [System.ObsoleteAttribute("Please use `ScheduleEvery(this IBusContext context, TimeSpan timeSpan, string nam" +
            "e, Func<IBusContext, Task> task)` instead. Will be removed in version 7.0.0.", true)]
        public static void ScheduleEvery(this NServiceBus.IBusContext context, System.TimeSpan timeSpan, string name, System.Action task) { }
        public static System.Threading.Tasks.Task ScheduleEvery(this NServiceBus.IBusContext context, System.TimeSpan timeSpan, System.Func<NServiceBus.IBusContext, System.Threading.Tasks.Task> task) { }
        public static System.Threading.Tasks.Task ScheduleEvery(this NServiceBus.IBusContext context, System.TimeSpan timeSpan, string name, System.Func<NServiceBus.IBusContext, System.Threading.Tasks.Task> task) { }
    }
    public class static SecondLevelRetriesConfigExtensions
    {
        public static NServiceBus.SecondLevelRetries.Config.SecondLevelRetriesSettings SecondLevelRetries(this NServiceBus.BusConfiguration config) { }
    }
    public class SendOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SendOptions() { }
    }
    public class static SerializationConfigExtensions
    {
        public static void AddDeserializer<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtentions<T> UseSerialization<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static void UseSerialization(this NServiceBus.BusConfiguration config, System.Type serializerType) { }
    }
    public class static SerializationContextExtensions
    {
        public static bool ShouldSkipSerialization(this NServiceBus.Pipeline.OutgoingPipeline.OutgoingLogicalMessageContext context) { }
        public static void SkipSerialization(this NServiceBus.Pipeline.OutgoingPipeline.OutgoingLogicalMessageContext context) { }
    }
    public class static SettingsExtentions
    {
        public static NServiceBus.EndpointInstance EndpointInstanceName(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static NServiceBus.Endpoint EndpointName(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static System.Collections.Generic.IList<System.Type> GetAvailableTypes(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static T GetConfigSection<T>(this NServiceBus.Settings.ReadOnlySettings settings)
            where T :  class, new () { }
        public static string LocalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static NServiceBus.LogicalAddress RootLogicalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public class static SLAMonitoringConfig
    {
        public static void EnableSLAPerformanceCounter(this NServiceBus.BusConfiguration config, System.TimeSpan sla) { }
        public static void EnableSLAPerformanceCounter(this NServiceBus.BusConfiguration config) { }
    }
    public class static StaticHeadersConfigExtensions
    {
        public static void AddHeaderToAllOutgoingMessages(this NServiceBus.BusConfiguration config, string key, string value) { }
    }
    public class SubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SubscribeOptions() { }
    }
    public delegate bool SubscriptionAuthorizer(NServiceBus.IncomingPhysicalMessageContext context);
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class TimeToBeReceivedAttribute : System.Attribute
    {
        public TimeToBeReceivedAttribute(string timeSpan) { }
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class static TimeToBeReceivedConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningTimeToBeReceivedAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, System.TimeSpan> retrieveTimeToBeReceived) { }
    }
    public class ToSagaExpression<TSagaData, TMessage>
        where TSagaData : NServiceBus.IContainSagaData
    {
        public ToSagaExpression(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
        public void ToSaga(System.Linq.Expressions.Expression<System.Func<TSagaData, object>> sagaEntityProperty) { }
    }
    public class static TransactionSettingsExtentions
    {
        public static NServiceBus.Settings.TransactionSettings Transactions(this NServiceBus.BusConfiguration config) { }
    }
    public class TransportExtensions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions AddAddressTranslationException(NServiceBus.EndpointInstance endpointInstance, string transportAddress) { }
        public NServiceBus.TransportExtensions AddAddressTranslationRule(System.Func<NServiceBus.EndpointInstance, string> rule) { }
        public NServiceBus.TransportExtensions ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions ConnectionString(System.Func<string> connectionString) { }
        public NServiceBus.TransportExtensions ConnectionStringName(string name) { }
    }
    public class TransportExtensions<T> : NServiceBus.TransportExtensions
        where T : NServiceBus.Transports.TransportDefinition
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(System.Func<string> connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionStringName(string name) { }
    }
    [System.ObsoleteAttribute("Not used anymore, use `OutgoingMessage` or `IncomingMessage` instead. Will be rem" +
        "oved in version 7.0.0.", true)]
    public class TransportMessage
    {
        public TransportMessage() { }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.Body\' or \'OutgoingMessage.Body\' instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public byte[] Body { get; set; }
        [System.ObsoleteAttribute("Use the value of the \'NServiceBus.CorrelationId\' header instead. Will be removed " +
            "in version 7.0.0.", true)]
        public string CorrelationId { get; set; }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.Headers\' or \'OutgoingMesssage.Headers\' inst" +
            "ead. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.MessageId\' or \'OutgoingMesssage.MessageId\' " +
            "instead. Will be removed in version 7.0.0.", true)]
        public string Id { get; }
        [System.ObsoleteAttribute("Please use `GetMessageIntent(this IncomingMessage message)` instead. Will be remo" +
            "ved in version 7.0.0.", true)]
        public NServiceBus.MessageIntentEnum MessageIntent { get; }
        [System.ObsoleteAttribute(@"For sending purposes use `DeliveryConstraintContextExtensions.AddDeliveryConstraint(new NonDurableDelivery())` to set NonDurable delivery or `NonDurableDelivery constraint;DeliveryConstraintContextExtensions.TryGetDeliveryConstraint(out constraint)` to read wether NonDurable delivery is set. When receiving look at the new 'NServiceBus.NonDurableMessage' header. Will be removed in version 7.0.0.", true)]
        public bool Recoverable { get; set; }
        [System.ObsoleteAttribute("Please use `GetReplyToAddress(this IncomingMessage message)` instead. Will be rem" +
            "oved in version 7.0.0.", true)]
        public string ReplyToAddress { get; }
        [System.ObsoleteAttribute(@"For sending purposes use `DeliveryConstraintContextExtensions.AddDeliveryConstraint(new DiscardIfNotReceivedBefore(timeToBeReceived))` to set the `TimeToBeReceived` or `DiscardIfNotReceivedBefore constraint;DeliveryConstraintContextExtensions.TryGetDeliveryConstraint(out constraint)` to read the `TimeToBeReceived`. When receiving look at the new 'NServiceBus.TimeToBeReceived' header. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan TimeToBeReceived { get; set; }
    }
    public sealed class UnicastRoutingTarget
    {
        public NServiceBus.Endpoint Endpoint { get; }
        public NServiceBus.EndpointInstance Instance { get; }
        public string TransportAddress { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public static NServiceBus.UnicastRoutingTarget ToAnonymousInstance(NServiceBus.Endpoint endpoint, string transportAddress) { }
        public static NServiceBus.UnicastRoutingTarget ToEndpointInstance(NServiceBus.EndpointInstance instance) { }
        public static NServiceBus.UnicastRoutingTarget ToTransportAddress(string transportAddress) { }
    }
    public class UnsubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public UnsubscribeOptions() { }
    }
    public class static UseDataBusExtensions
    {
        public static NServiceBus.DataBus.DataBusExtentions<T> UseDataBus<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.DataBus.DataBusDefinition, new () { }
        public static NServiceBus.DataBus.DataBusExtentions UseDataBus(this NServiceBus.BusConfiguration config, System.Type dataBusType) { }
    }
    public class static UseTransportExtensions
    {
        public static NServiceBus.TransportExtensions<T> UseTransport<T>(this NServiceBus.BusConfiguration busConfiguration)
            where T : NServiceBus.Transports.TransportDefinition, new () { }
        public static NServiceBus.TransportExtensions UseTransport(this NServiceBus.BusConfiguration busConfiguration, System.Type transportDefinitionType) { }
    }
    public class WireEncryptedString : System.Runtime.Serialization.ISerializable
    {
        public WireEncryptedString() { }
        public WireEncryptedString(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        [System.ObsoleteAttribute("No longer required. Will be removed in version 7.0.0.", true)]
        public string Base64Iv { get; set; }
        [System.ObsoleteAttribute("No longer required. Will be removed in version 7.0.0.", true)]
        public string EncryptedBase64Value { get; set; }
        public NServiceBus.EncryptedValue EncryptedValue { get; set; }
        public string Value { get; set; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static XmlSerializationExtentions
    {
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> DontWrapRawXml(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config) { }
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> Namespace(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config, string namespaceToUse) { }
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> SanitizeInput(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config) { }
    }
    public class XmlSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public XmlSerializer() { }
        protected internal override System.Type ProvidedByFeature() { }
    }
}
namespace NServiceBus.Audit
{
    public interface AuditContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.BehaviorContext
    {
        string AuditAddress { get; }
        NServiceBus.Transports.OutgoingMessage Message { get; }
    }
    public class static AuditContextExtensions
    {
        public static void AddAuditData(this NServiceBus.Audit.AuditContext context, string key, string value) { }
    }
}
namespace NServiceBus.AutomaticSubscriptions.Config
{
    public class AutoSubscribeSettings
    {
        public void AutoSubscribePlainMessages() { }
        public void DoNotAutoSubscribeSagas() { }
        [System.ObsoleteAttribute("Transports with support for centralized pubsub will default this to true. Can saf" +
            "ely be removed. Will be removed in version 7.0.0.", true)]
        public void DoNotRequireExplicitRouting() { }
    }
}
namespace NServiceBus.Config
{
    public class AuditConfig : System.Configuration.ConfigurationSection
    {
        public AuditConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("OverrideTimeToBeReceived", IsRequired=false)]
        public System.TimeSpan OverrideTimeToBeReceived { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("QueueName", IsRequired=false)]
        public string QueueName { get; set; }
    }
    [System.ObsoleteAttribute("Use the feature concept instead via A class which inherits from `NServiceBus.Feat" +
        "ures.Feature` and use `configuration.EnableFeature<YourClass>()`. Will be remove" +
        "d in version 7.0.0.", true)]
    public interface IWantToRunWhenConfigurationIsComplete { }
    public class Logging : System.Configuration.ConfigurationSection
    {
        public Logging() { }
        [System.Configuration.ConfigurationPropertyAttribute("Threshold", DefaultValue="Info", IsRequired=true)]
        public string Threshold { get; set; }
    }
    public class MasterNodeConfig : System.Configuration.ConfigurationSection
    {
        public MasterNodeConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("Node", IsRequired=true)]
        public string Node { get; set; }
    }
    public class MessageEndpointMapping : System.Configuration.ConfigurationElement, System.IComparable<NServiceBus.Config.MessageEndpointMapping>
    {
        public MessageEndpointMapping() { }
        [System.Configuration.ConfigurationPropertyAttribute("Assembly", IsRequired=false)]
        public string AssemblyName { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Endpoint", IsRequired=true)]
        public string Endpoint { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Messages", IsRequired=false)]
        public string Messages { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Namespace", IsRequired=false)]
        public string Namespace { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Type", IsRequired=false)]
        public string TypeFullName { get; set; }
        public int CompareTo(NServiceBus.Config.MessageEndpointMapping other) { }
        public void Configure(System.Action<System.Type, string> mapTypeToEndpoint) { }
    }
    public class MessageEndpointMappingCollection : System.Configuration.ConfigurationElementCollection
    {
        public MessageEndpointMappingCollection() { }
        public new string AddElementName { get; set; }
        public new string ClearElementName { get; set; }
        public override System.Configuration.ConfigurationElementCollectionType CollectionType { get; }
        public new int Count { get; }
        public NServiceBus.Config.MessageEndpointMapping this[int index] { get; set; }
        public NServiceBus.Config.MessageEndpointMapping this[string Name] { get; }
        public new string RemoveElementName { get; }
        public void Add(NServiceBus.Config.MessageEndpointMapping mapping) { }
        protected override void BaseAdd(System.Configuration.ConfigurationElement element) { }
        public void Clear() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement(string elementName) { }
        protected override object GetElementKey(System.Configuration.ConfigurationElement element) { }
        public int IndexOf(NServiceBus.Config.MessageEndpointMapping mapping) { }
        public override bool IsReadOnly() { }
        public void Remove(NServiceBus.Config.MessageEndpointMapping mapping) { }
        public void Remove(string name) { }
        public void RemoveAt(int index) { }
    }
    public class MessageForwardingInCaseOfFaultConfig : System.Configuration.ConfigurationSection
    {
        public MessageForwardingInCaseOfFaultConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("ErrorQueue", IsRequired=true)]
        public string ErrorQueue { get; set; }
    }
    public class MsmqSubscriptionStorageConfig : System.Configuration.ConfigurationSection
    {
        public MsmqSubscriptionStorageConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("Queue", IsRequired=true)]
        public string Queue { get; set; }
    }
    public class RijndaelEncryptionServiceConfig : System.Configuration.ConfigurationSection
    {
        public RijndaelEncryptionServiceConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("ExpiredKeys", IsRequired=false)]
        public NServiceBus.Config.RijndaelExpiredKeyCollection ExpiredKeys { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Key", IsRequired=true)]
        public string Key { get; set; }
    }
    public class RijndaelExpiredKey : System.Configuration.ConfigurationElement, System.IComparable<NServiceBus.Config.RijndaelExpiredKey>
    {
        public RijndaelExpiredKey() { }
        [System.Configuration.ConfigurationPropertyAttribute("Key", IsRequired=true)]
        public string Key { get; set; }
    }
    public class RijndaelExpiredKeyCollection : System.Configuration.ConfigurationElementCollection
    {
        public RijndaelExpiredKeyCollection() { }
        public override System.Configuration.ConfigurationElementCollectionType CollectionType { get; }
        public NServiceBus.Config.RijndaelExpiredKey this[int index] { get; set; }
        public NServiceBus.Config.RijndaelExpiredKey this[string key] { get; }
        public void Add(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        protected override void BaseAdd(System.Configuration.ConfigurationElement element) { }
        public void Clear() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement(string elementName) { }
        protected override object GetElementKey(System.Configuration.ConfigurationElement element) { }
        public int IndexOf(NServiceBus.Config.RijndaelExpiredKey encryptionKey) { }
        public override bool IsReadOnly() { }
        public void Remove(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        public void Remove(string name) { }
        public void RemoveAt(int index) { }
    }
    public class SecondLevelRetriesConfig : System.Configuration.ConfigurationSection
    {
        public SecondLevelRetriesConfig() { }
        public bool Enabled { get; set; }
        public int NumberOfRetries { get; set; }
        public System.TimeSpan TimeIncrease { get; set; }
    }
    public class TransportConfig : System.Configuration.ConfigurationSection
    {
        public TransportConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("MaximumConcurrencyLevel", DefaultValue=0, IsRequired=false)]
        public int MaximumConcurrencyLevel { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MaximumMessageThroughputPerSecond", DefaultValue=-1, IsRequired=false)]
        public int MaximumMessageThroughputPerSecond { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MaxRetries", DefaultValue=5, IsRequired=false)]
        public int MaxRetries { get; set; }
    }
    public class UnicastBusConfig : System.Configuration.ConfigurationSection
    {
        public UnicastBusConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("DistributorControlAddress", IsRequired=false)]
        public string DistributorControlAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("DistributorDataAddress", IsRequired=false)]
        public string DistributorDataAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("ForwardReceivedMessagesTo", IsRequired=false)]
        public string ForwardReceivedMessagesTo { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MessageEndpointMappings", IsRequired=false)]
        public NServiceBus.Config.MessageEndpointMappingCollection MessageEndpointMappings { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("TimeoutManagerAddress", IsRequired=false)]
        public string TimeoutManagerAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("TimeToBeReceivedOnForwardedMessages", IsRequired=false)]
        public System.TimeSpan TimeToBeReceivedOnForwardedMessages { get; set; }
    }
}
namespace NServiceBus.Config.ConfigurationSource
{
    public class DefaultConfigurationSource : NServiceBus.Config.ConfigurationSource.IConfigurationSource
    {
        public DefaultConfigurationSource() { }
    }
    public interface IConfigurationSource
    {
        T GetConfiguration<T>()
            where T :  class, new ();
    }
    public interface IProvideConfiguration<T>
    {
        T GetConfiguration();
    }
}
namespace NServiceBus.Configuration.AdvanceExtensibility
{
    public class static AdvanceExtensibilityExtensions
    {
        public static NServiceBus.Settings.SettingsHolder GetSettings(this NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings config) { }
    }
    public abstract class ExposeSettings
    {
        protected ExposeSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.ConsistencyGuarantees
{
    public enum ConsistencyGuarantee
    {
        AtMostOnce = 1,
        AtLeastOnce = 2,
        ExactlyOnce = 3,
    }
    public class static ConsistencyGuaranteeSettingsExtensions
    {
        public static NServiceBus.Transports.TransactionSupport GetRequiredTransactionSupportForReceives(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
}
namespace NServiceBus.Container
{
    public class ContainerCustomizations
    {
        public NServiceBus.Settings.SettingsHolder Settings { get; }
    }
    public abstract class ContainerDefinition
    {
        protected ContainerDefinition() { }
        public abstract NServiceBus.ObjectBuilder.Common.IContainer CreateContainer(NServiceBus.Settings.ReadOnlySettings settings);
    }
}
namespace NServiceBus.DataBus
{
    public abstract class DataBusDefinition
    {
        protected DataBusDefinition() { }
        protected internal abstract System.Type ProvidedByFeature();
    }
    public class DataBusExtentions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public DataBusExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class DataBusExtentions<T> : NServiceBus.DataBus.DataBusExtentions
        where T : NServiceBus.DataBus.DataBusDefinition
    {
        public DataBusExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public interface IDataBus
    {
        System.Threading.Tasks.Task<System.IO.Stream> Get(string key);
        System.Threading.Tasks.Task<string> Put(System.IO.Stream stream, System.TimeSpan timeToBeReceived);
        System.Threading.Tasks.Task Start();
    }
    public interface IDataBusSerializer
    {
        object Deserialize(System.IO.Stream stream);
        void Serialize(object databusProperty, System.IO.Stream stream);
    }
}
namespace NServiceBus.DelayedDelivery
{
    public class DelayDeliveryWith : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DelayDeliveryWith(System.TimeSpan delay) { }
        public System.TimeSpan Delay { get; }
    }
    public abstract class DelayedDeliveryConstraint : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        protected DelayedDeliveryConstraint() { }
    }
    public class DoNotDeliverBefore : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DoNotDeliverBefore(System.DateTime at) { }
        public System.DateTime At { get; }
    }
}
namespace NServiceBus.DeliveryConstraints
{
    public abstract class DeliveryConstraint
    {
        protected DeliveryConstraint() { }
    }
    public class static DeliveryConstraintContextExtensions
    {
        public static void AddDeliveryConstraint(this NServiceBus.TransportDispatch.RoutingContext context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static void AddDeliveryConstraint(this NServiceBus.Pipeline.OutgoingPipeline.OutgoingLogicalMessageContext context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> GetDeliveryConstraints(this NServiceBus.TransportDispatch.RoutingContext context) { }
        public static void RemoveDeliveryConstaint(this NServiceBus.TransportDispatch.RoutingContext context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static bool TryGetDeliveryConstraint<T>(this NServiceBus.TransportDispatch.RoutingContext context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
        public static bool TryGetDeliveryConstraint<T>(this NServiceBus.Pipeline.OutgoingPipeline.OutgoingLogicalMessageContext context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
    }
}
namespace NServiceBus.Encryption
{
    public interface IEncryptionService
    {
        string Decrypt(NServiceBus.EncryptedValue encryptedValue);
        NServiceBus.EncryptedValue Encrypt(string value);
    }
}
namespace NServiceBus.Extensibility
{
    public class ContextBag : NServiceBus.Extensibility.ReadOnlyContextBag
    {
        public ContextBag(NServiceBus.Extensibility.ContextBag parentBag = null) { }
        public T Get<T>() { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public void Remove<T>() { }
        public void Set<T>(T t) { }
        public void Set<T>(string key, T t) { }
        public bool TryGet<T>(out T result) { }
        public bool TryGet<T>(string key, out T result) { }
    }
    public abstract class ExtendableOptions
    {
        protected ExtendableOptions() { }
    }
    public class static ExtendableOptionsExtensions
    {
        public static NServiceBus.Extensibility.ContextBag GetExtensions(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public interface IExtendable
    {
        NServiceBus.Extensibility.ContextBag Extensions { get; }
    }
    public interface ReadOnlyContextBag
    {
        T Get<T>();
        bool TryGet<T>(out T result);
        bool TryGet<T>(string key, out T result);
    }
}
namespace NServiceBus.Faults
{
    public class ErrorsNotifications
    {
        public ErrorsNotifications() { }
        public event System.EventHandler<NServiceBus.Faults.SecondLevelRetry> MessageHasBeenSentToSecondLevelRetries;
        public event System.EventHandler<NServiceBus.Faults.FirstLevelRetry> MessageHasFailedAFirstLevelRetryAttempt;
        public event System.EventHandler<NServiceBus.Faults.FailedMessage> MessageSentToErrorQueue;
    }
    public struct FailedMessage
    {
        public FailedMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static FaultsHeaderKeys
    {
        public const string FailedQ = "NServiceBus.FailedQ";
    }
    public struct FirstLevelRetry
    {
        public FirstLevelRetry(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public int RetryAttempt { get; }
    }
    [System.ObsoleteAttribute(@"IManageMessageFailures is no longer an extension point. If you want full control over what happens when a message fails (including retries) please override the MoveFaultsToErrorQueue behavior. If you just want to get notified when messages are being moved please use BusNotifications.Errors.MessageSentToErrorQueue.Subscribe(e=>{}). Will be removed in version 7.0.0.", true)]
    public interface IManageMessageFailures { }
    public struct SecondLevelRetry
    {
        public SecondLevelRetry(System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public int RetryAttempt { get; }
    }
}
namespace NServiceBus.Features
{
    public class Audit : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class AutoSubscribe : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class BestPracticeEnforcement : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class CriticalTimeMonitoring : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class DataBus : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Encryptor : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public abstract class Feature
    {
        protected Feature() { }
        public bool IsActive { get; }
        public bool IsEnabledByDefault { get; }
        public string Name { get; }
        public string Version { get; }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> settings) { }
        protected void DependsOn<T>()
            where T : NServiceBus.Features.Feature { }
        protected void DependsOn(string featureName) { }
        protected void DependsOnAtLeastOne(params System.Type[] features) { }
        protected void DependsOnAtLeastOne(params string[] featureNames) { }
        protected void DependsOnOptionally(string featureName) { }
        protected void DependsOnOptionally(System.Type featureType) { }
        protected void DependsOnOptionally<T>()
            where T : NServiceBus.Features.Feature { }
        protected void EnableByDefault() { }
        protected void Prerequisite(System.Func<NServiceBus.Features.FeatureConfigurationContext, bool> condition, string description) { }
        [System.ObsoleteAttribute("Please use `FeatureConfigurationContext.RegisterStartupTask` instead. Will be rem" +
            "oved in version 7.0.0.", true)]
        protected void RegisterStartupTask<T>()
            where T : NServiceBus.Features.FeatureStartupTask { }
        protected internal abstract void Setup(NServiceBus.Features.FeatureConfigurationContext context);
        public override string ToString() { }
    }
    public class FeatureConfigurationContext
    {
        public NServiceBus.ObjectBuilder.IConfigureComponents Container { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        public NServiceBus.Settings.ReadOnlySettings Settings { get; }
        public NServiceBus.Pipeline.PipelineSettings AddSatellitePipeline(string name, string qualifier, NServiceBus.Transports.TransactionSupport requiredTransactionSupport, NServiceBus.Transports.PushRuntimeSettings runtimeSettings, out string transportAddress) { }
        public void RegisterStartupTask<TTask>(TTask startupTask)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<NServiceBus.ObjectBuilder.IBuilder, TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
    }
    public class FeatureDiagnosticData
    {
        public FeatureDiagnosticData() { }
        public bool Active { get; }
        public System.Collections.Generic.IReadOnlyList<System.Collections.Generic.IReadOnlyList<string>> Dependencies { get; }
        public bool DependenciesAreMeet { get; set; }
        public bool EnabledByDefault { get; }
        public string Name { get; }
        public NServiceBus.Features.PrerequisiteStatus PrerequisiteStatus { get; }
        public System.Collections.Generic.IReadOnlyList<string> StartupTasks { get; }
        public string Version { get; }
    }
    public class FeaturesReport
    {
        public System.Collections.Generic.IReadOnlyList<NServiceBus.Features.FeatureDiagnosticData> Features { get; }
    }
    public abstract class FeatureStartupTask
    {
        protected FeatureStartupTask() { }
        [System.ObsoleteAttribute("Please use `OnStart(IBusContext context)` instead. Will be removed in version 7.0" +
            ".0.", true)]
        protected virtual void OnStart() { }
        protected abstract System.Threading.Tasks.Task OnStart(NServiceBus.IBusContext context);
        [System.ObsoleteAttribute("Please use `OnStop(IBusContext context)` instead. Will be removed in version 7.0." +
            "0.", true)]
        protected virtual void OnStop() { }
        protected virtual System.Threading.Tasks.Task OnStop(NServiceBus.IBusContext context) { }
    }
    public enum FeatureState
    {
        Disabled = 0,
        Enabled = 1,
        Active = 2,
        Deactivated = 3,
    }
    public class FirstLevelRetries : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class ForwardReceivedMessages : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryGatewayPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryOutboxPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySagaPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryTimeoutPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class JsonSerialization : NServiceBus.Serialization.ConfigureSerialization
    {
        protected override System.Type GetSerializerType(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MessageDrivenSubscriptions : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MsmqSubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Outbox : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class PrerequisiteStatus
    {
        public bool IsSatisfied { get; }
        public System.Collections.Generic.List<string> Reasons { get; }
    }
    public class Sagas : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Scheduler : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class SecondLevelRetries : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Use the ConfigureSerialization Feature class instead. Please use `ConfigureSerial" +
        "ization` instead. Will be removed in version 7.0.0.", true)]
    public class static SerializationFeatureHelper { }
    public class static SettingsExtentions
    {
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault<T>(this NServiceBus.Settings.SettingsHolder settings)
            where T : NServiceBus.Features.Feature { }
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault(this NServiceBus.Settings.SettingsHolder settings, System.Type featureType) { }
        public static bool IsFeatureActive(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
        public static bool IsFeatureEnabled(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
    }
    public class SLAMonitoring : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class StorageDrivenPublishing
    {
        public StorageDrivenPublishing() { }
    }
    public class TimeoutManager : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class TimeoutManagerBasedDeferral
    {
        public TimeoutManagerBasedDeferral() { }
    }
    public class XmlSerialization : NServiceBus.Serialization.ConfigureSerialization
    {
        protected override System.Type GetSerializerType(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
}
namespace NServiceBus.Gateway.Deduplication
{
    public interface IDeduplicateMessages
    {
        System.Threading.Tasks.Task<bool> DeduplicateMessage(string clientId, System.DateTime timeReceived, NServiceBus.Extensibility.ContextBag context);
    }
}
namespace NServiceBus.Hosting.Helpers
{
    public class AssemblyScanner
    {
        public AssemblyScanner() { }
        public AssemblyScanner(string baseDirectoryToScan) { }
        [System.ObsoleteAttribute("This method is no longer required since deep scanning of assemblies is done to de" +
            "tect an NServiceBus reference. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.List<System.Reflection.Assembly> MustReferenceAtLeastOneAssembly { get; }
        public bool ThrowExceptions { get; set; }
        public NServiceBus.Hosting.Helpers.AssemblyScannerResults GetScannableAssemblies() { }
    }
    public class AssemblyScannerResults
    {
        public AssemblyScannerResults() { }
        public System.Collections.Generic.List<System.Reflection.Assembly> Assemblies { get; }
        public bool ErrorsThrownDuringScanning { get; }
        public System.Collections.Generic.List<NServiceBus.Hosting.Helpers.SkippedFile> SkippedFiles { get; }
        public System.Collections.Generic.List<System.Type> Types { get; }
    }
    public class SkippedFile
    {
        public string FilePath { get; }
        public string SkipReason { get; }
    }
}
namespace NServiceBus.Hosting
{
    public class HostInformation
    {
        public HostInformation(System.Guid hostId, string displayName) { }
        public HostInformation(System.Guid hostId, string displayName, System.Collections.Generic.Dictionary<string, string> properties) { }
        public string DisplayName { get; }
        public System.Guid HostId { get; }
        public System.Collections.Generic.Dictionary<string, string> Properties { get; }
    }
}
namespace NServiceBus.InMemory.Outbox
{
    public class static InMemoryOutboxSettingsExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings TimeToKeepDeduplicationData(this NServiceBus.Outbox.OutboxSettings settings, System.TimeSpan time) { }
    }
}
namespace NServiceBus.Installation
{
    public interface INeedToInstallSomething
    {
        System.Threading.Tasks.Task Install(string identity);
    }
}
namespace NServiceBus.Logging
{
    public class DefaultFactory : NServiceBus.Logging.LoggingFactoryDefinition
    {
        public DefaultFactory() { }
        public void Directory(string directory) { }
        protected internal override NServiceBus.Logging.ILoggerFactory GetLoggingFactory() { }
        public void Level(NServiceBus.Logging.LogLevel level) { }
    }
    public interface ILog
    {
        bool IsDebugEnabled { get; }
        bool IsErrorEnabled { get; }
        bool IsFatalEnabled { get; }
        bool IsInfoEnabled { get; }
        bool IsWarnEnabled { get; }
        void Debug(string message);
        void Debug(string message, System.Exception exception);
        void DebugFormat(string format, params object[] args);
        void Error(string message);
        void Error(string message, System.Exception exception);
        void ErrorFormat(string format, params object[] args);
        void Fatal(string message);
        void Fatal(string message, System.Exception exception);
        void FatalFormat(string format, params object[] args);
        void Info(string message);
        void Info(string message, System.Exception exception);
        void InfoFormat(string format, params object[] args);
        void Warn(string message);
        void Warn(string message, System.Exception exception);
        void WarnFormat(string format, params object[] args);
    }
    public interface ILoggerFactory
    {
        NServiceBus.Logging.ILog GetLogger(System.Type type);
        NServiceBus.Logging.ILog GetLogger(string name);
    }
    public abstract class LoggingFactoryDefinition
    {
        protected LoggingFactoryDefinition() { }
        protected internal abstract NServiceBus.Logging.ILoggerFactory GetLoggingFactory();
    }
    public enum LogLevel
    {
        Debug = 0,
        Info = 1,
        Warn = 2,
        Error = 3,
        Fatal = 4,
    }
    public class static LogManager
    {
        public static NServiceBus.Logging.ILog GetLogger<T>() { }
        public static NServiceBus.Logging.ILog GetLogger(System.Type type) { }
        public static NServiceBus.Logging.ILog GetLogger(string name) { }
        public static T Use<T>()
            where T : NServiceBus.Logging.LoggingFactoryDefinition, new () { }
        public static void UseFactory(NServiceBus.Logging.ILoggerFactory loggerFactory) { }
    }
}
namespace NServiceBus.MessageInterfaces
{
    public interface IMessageMapper : NServiceBus.IMessageCreator
    {
        System.Type GetMappedTypeFor(System.Type t);
        System.Type GetMappedTypeFor(string typeName);
        void Initialize(System.Collections.Generic.IEnumerable<System.Type> types);
    }
}
namespace NServiceBus.MessageInterfaces.MessageMapper.Reflection
{
    public class MessageMapper : NServiceBus.IMessageCreator, NServiceBus.MessageInterfaces.IMessageMapper
    {
        public MessageMapper() { }
        public T CreateInstance<T>(System.Action<T> action) { }
        public T CreateInstance<T>() { }
        public object CreateInstance(System.Type t) { }
        public System.Type GetMappedTypeFor(System.Type t) { }
        public System.Type GetMappedTypeFor(string typeName) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> types) { }
    }
}
namespace NServiceBus.MessageMutator
{
    [System.ObsoleteAttribute("Just have your mutator implement both IMutateOutgoingMessages and IMutateIncoming" +
        "Messages. Will be removed in version 7.0.0.", true)]
    public interface IMessageMutator { }
    public interface IMutateIncomingMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingMessageContext context);
    }
    public interface IMutateIncomingTransportMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingTransportMessageContext context);
    }
    public interface IMutateOutgoingMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingMessageContext context);
    }
    public interface IMutateOutgoingTransportMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingTransportMessageContext context);
    }
    [System.ObsoleteAttribute("Just have your mutator implement both IMutateIncomingTransportMessages and IMutat" +
        "eOutgoingTransportMessages. Will be removed in version 7.0.0.", true)]
    public interface IMutateTransportMessages : NServiceBus.MessageMutator.IMutateIncomingTransportMessages, NServiceBus.MessageMutator.IMutateOutgoingTransportMessages { }
    public class MutateIncomingMessageContext
    {
        public MutateIncomingMessageContext(object message, System.Collections.Generic.IDictionary<string, string> headers) { }
        public System.Collections.Generic.IDictionary<string, string> Headers { get; }
        public object Message { get; set; }
    }
    public class MutateIncomingTransportMessageContext
    {
        public MutateIncomingTransportMessageContext(byte[] body, System.Collections.Generic.IDictionary<string, string> headers) { }
        public byte[] Body { get; set; }
        public System.Collections.Generic.IDictionary<string, string> Headers { get; }
    }
    public class MutateOutgoingMessageContext
    {
        public MutateOutgoingMessageContext(object outgoingMessage, System.Collections.Generic.IDictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; set; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<, > incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
    public class MutateOutgoingTransportMessageContext
    {
        public MutateOutgoingTransportMessageContext(byte[] outgoingBody, object outgoingMessage, System.Collections.Generic.IDictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public byte[] OutgoingBody { get; set; }
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<, > incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
}
namespace NServiceBus.ObjectBuilder.Common
{
    public interface IContainer : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        NServiceBus.ObjectBuilder.Common.IContainer BuildChildContainer();
        void Configure(System.Type component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void Configure<T>(System.Func<T> component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureProperty(System.Type component, string property, object value);
        bool HasComponent(System.Type componentType);
        void RegisterSingleton(System.Type lookupType, object instance);
        void Release(object instance);
    }
}
namespace NServiceBus.ObjectBuilder
{
    public interface IBuilder : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        T Build<T>();
        System.Collections.Generic.IEnumerable<T> BuildAll<T>();
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        void BuildAndDispatch(System.Type typeToBuild, System.Action<object> action);
        NServiceBus.ObjectBuilder.IBuilder CreateChildBuilder();
        void Release(object instance);
    }
    public interface IComponentConfig
    {
        NServiceBus.ObjectBuilder.IComponentConfig ConfigureProperty(string name, object value);
    }
    public interface IComponentConfig<T>
    {
        NServiceBus.ObjectBuilder.IComponentConfig<T> ConfigureProperty(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value);
    }
    public interface IConfigureComponents
    {
        NServiceBus.ObjectBuilder.IComponentConfig ConfigureComponent(System.Type concreteComponent, NServiceBus.DependencyLifecycle dependencyLifecycle);
        NServiceBus.ObjectBuilder.IComponentConfig<T> ConfigureComponent<T>(NServiceBus.DependencyLifecycle dependencyLifecycle);
        NServiceBus.ObjectBuilder.IComponentConfig<T> ConfigureComponent<T>(System.Func<T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        NServiceBus.ObjectBuilder.IComponentConfig<T> ConfigureComponent<T>(System.Func<NServiceBus.ObjectBuilder.IBuilder, T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        NServiceBus.ObjectBuilder.IConfigureComponents ConfigureProperty<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value);
        NServiceBus.ObjectBuilder.IConfigureComponents ConfigureProperty<T>(string propertyName, object value);
        bool HasComponent<T>();
        bool HasComponent(System.Type componentType);
        NServiceBus.ObjectBuilder.IConfigureComponents RegisterSingleton(System.Type lookupType, object instance);
        NServiceBus.ObjectBuilder.IConfigureComponents RegisterSingleton<T>(T instance);
    }
}
namespace NServiceBus.Outbox
{
    public interface IOutboxStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxTransaction> BeginTransaction(NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxMessage> Get(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task SetAsDispatched(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Store(NServiceBus.Outbox.OutboxMessage message, NServiceBus.Outbox.OutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context);
    }
    public class OutboxMessage
    {
        public OutboxMessage(string messageId, System.Collections.Generic.IList<NServiceBus.Outbox.TransportOperation> operations) { }
        public string MessageId { get; }
        public System.Collections.Generic.IList<NServiceBus.Outbox.TransportOperation> TransportOperations { get; }
    }
    public class OutboxSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        [System.ObsoleteAttribute("Please use `InMemoryOutboxSettingsExtensions.TimeToKeepDeduplicationData(TimeSpan" +
            " time)` instead. Will be removed in version 7.0.0.", true)]
        public void TimeToKeepDeduplicationData(System.TimeSpan time) { }
    }
    public interface OutboxTransaction : System.IDisposable
    {
        System.Threading.Tasks.Task Commit();
    }
    public class TransportOperation
    {
        public TransportOperation(string messageId, System.Collections.Generic.Dictionary<string, string> options, byte[] body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public System.Collections.Generic.Dictionary<string, string> Options { get; }
    }
}
namespace NServiceBus.OutgoingPipeline
{
    public interface OutgoingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.Pipeline.BehaviorContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        string MessageId { get; }
    }
    public class OutgoingLogicalMessage
    {
        public OutgoingLogicalMessage(object message) { }
        public OutgoingLogicalMessage(System.Type messageType, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
    }
    public interface OutgoingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.OutgoingPipeline.OutgoingContext, NServiceBus.Pipeline.BehaviorContext
    {
        byte[] Body { get; set; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
    }
    public interface OutgoingPublishContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.OutgoingPipeline.OutgoingContext, NServiceBus.Pipeline.BehaviorContext
    {
        NServiceBus.OutgoingPipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface OutgoingReplyContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.OutgoingPipeline.OutgoingContext, NServiceBus.Pipeline.BehaviorContext
    {
        NServiceBus.OutgoingPipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface OutgoingSendContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.OutgoingPipeline.OutgoingContext, NServiceBus.Pipeline.BehaviorContext
    {
        NServiceBus.OutgoingPipeline.OutgoingLogicalMessage Message { get; }
    }
}
namespace NServiceBus.Performance.TimeToBeReceived
{
    public class DiscardIfNotReceivedBefore : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public DiscardIfNotReceivedBefore(System.TimeSpan maxTime) { }
        public System.TimeSpan MaxTime { get; }
    }
}
namespace NServiceBus.Persistence
{
    public interface CompletableSynchronizedStorageSession : NServiceBus.Persistence.SynchronizedStorageSession, System.IDisposable
    {
        System.Threading.Tasks.Task CompleteAsync();
    }
    public interface ISynchronizedStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> OpenSession(NServiceBus.Extensibility.ContextBag contextBag);
    }
    public interface ISynchronizedStorageAdapter
    {
        bool TryAdapt(NServiceBus.Outbox.OutboxTransaction transaction, out NServiceBus.Persistence.CompletableSynchronizedStorageSession session);
        bool TryAdapt(NServiceBus.Transports.TransportTransaction transportTransaction, out NServiceBus.Persistence.CompletableSynchronizedStorageSession session);
    }
    public abstract class PersistenceDefinition
    {
        protected PersistenceDefinition() { }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> action) { }
        [System.ObsoleteAttribute("Please use `HasSupportFor<T>()` instead. Will be removed in version 7.0.0.", true)]
        public bool HasSupportFor(NServiceBus.Persistence.Storage storage) { }
        public bool HasSupportFor<T>()
            where T : NServiceBus.Persistence.StorageType { }
        public bool HasSupportFor(System.Type storageType) { }
        protected void Supports<T>(System.Action<NServiceBus.Settings.SettingsHolder> action)
            where T : NServiceBus.Persistence.StorageType { }
        [System.ObsoleteAttribute("Please use `Supports<T>()` instead. Will be removed in version 7.0.0.", true)]
        protected void Supports(NServiceBus.Persistence.Storage storage, System.Action<NServiceBus.Settings.SettingsHolder> action) { }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.Persistence.StorageType` instead. Will be removed in vers" +
        "ion 7.0.0.", true)]
    public enum Storage
    {
        Timeouts = 1,
        Subscriptions = 2,
        Sagas = 3,
        GatewayDeduplication = 4,
        Outbox = 5,
    }
    public abstract class StorageType
    {
        public override string ToString() { }
        public sealed class GatewayDeduplication : NServiceBus.Persistence.StorageType { }
        public sealed class Outbox : NServiceBus.Persistence.StorageType { }
        public sealed class Sagas : NServiceBus.Persistence.StorageType { }
        public sealed class Subscriptions : NServiceBus.Persistence.StorageType { }
        public sealed class Timeouts : NServiceBus.Persistence.StorageType { }
    }
    public interface SynchronizedStorageSession { }
}
namespace NServiceBus.Persistence.Legacy
{
    public class MsmqPersistence : NServiceBus.Persistence.PersistenceDefinition { }
}
namespace NServiceBus.Pipeline
{
    public abstract class Behavior<TContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TContext, TContext>
        where TContext : NServiceBus.Pipeline.BehaviorContext
    {
        protected Behavior() { }
        protected NServiceBus.Unicast.Transport.PipelineInfo PipelineInfo { get; }
        public virtual System.Threading.Tasks.Task Cooldown() { }
        public void Initialize(NServiceBus.Unicast.Transport.PipelineInfo pipelineInfo) { }
        public abstract System.Threading.Tasks.Task Invoke(TContext context, System.Func<System.Threading.Tasks.Task> next);
        public System.Threading.Tasks.Task Invoke(TContext context, System.Func<TContext, System.Threading.Tasks.Task> next) { }
        public virtual System.Threading.Tasks.Task Warmup() { }
    }
    public interface BehaviorContext : NServiceBus.Extensibility.IExtendable
    {
        NServiceBus.ObjectBuilder.IBuilder Builder { get; }
    }
    public interface IBehavior
    {
        System.Threading.Tasks.Task Cooldown();
        void Initialize(NServiceBus.Unicast.Transport.PipelineInfo pipelineInfo);
        System.Threading.Tasks.Task Warmup();
    }
    [System.ObsoleteAttribute("Please use `Behavior<T>` instead. Will be removed in version 7.0.0.", true)]
    public interface IBehavior<in TContext> { }
    public interface IBehavior<in TIn, out TOut> : NServiceBus.Pipeline.IBehavior
        where in TIn : NServiceBus.Pipeline.BehaviorContext
        where out TOut : NServiceBus.Pipeline.BehaviorContext
    {
        System.Threading.Tasks.Task Invoke(TIn context, System.Func<TOut, System.Threading.Tasks.Task> next);
    }
    public interface IPipelineTerminator { }
    [System.ObsoleteAttribute("You can no longer get access to the pipeline context via DI. Please use a behavio" +
        "r to get access instead. Will be removed in version 7.0.0.", true)]
    public class PipelineExecutor
    {
        public PipelineExecutor() { }
    }
    public class PipelineSettings
    {
        public NServiceBus.Pipeline.StepRegistrationSequence Register(string stepId, System.Type behavior, string description) { }
        public NServiceBus.Pipeline.StepRegistrationSequence Register(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type behavior, string description) { }
        public void Register<TRegisterStep>()
            where TRegisterStep : NServiceBus.Pipeline.RegisterStep, new () { }
        public void Register(NServiceBus.Pipeline.RegisterStep registration) { }
        public void Remove(string stepId) { }
        public void Remove(NServiceBus.Pipeline.WellKnownStep wellKnownStep) { }
        public void Replace(string stepId, System.Type newBehavior, string description = null) { }
        public void Replace(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type newBehavior, string description = null) { }
    }
    public abstract class PipelineTerminator<T> : NServiceBus.Pipeline.StageConnector<T, NServiceBus.Pipeline.PipelineTerminator<T>.TerminatingContext>, NServiceBus.Pipeline.IPipelineTerminator
        where T : NServiceBus.Pipeline.BehaviorContext
    {
        protected PipelineTerminator() { }
        public virtual System.Threading.Tasks.Task Invoke(T context, System.Func<NServiceBus.Pipeline.PipelineTerminator<T>.TerminatingContext, System.Threading.Tasks.Task> next) { }
        protected abstract System.Threading.Tasks.Task Terminate(T context);
        public interface TerminatingContext<T> : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.BehaviorContext
            where T : NServiceBus.Pipeline.BehaviorContext { }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{StepId}({BehaviorType.FullName}) - {Description}")]
    public abstract class RegisterStep
    {
        protected RegisterStep(string stepId, System.Type behavior, string description) { }
        public System.Type BehaviorType { get; }
        public string Description { get; }
        public string StepId { get; }
        public void InsertAfter(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertAfter(string id) { }
        public void InsertAfterIfExists(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertAfterIfExists(string id) { }
        public void InsertBefore(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertBefore(string id) { }
        public void InsertBeforeIfExists(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertBeforeIfExists(string id) { }
        public virtual bool IsEnabled(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public abstract class StageConnector<TFrom, TTo> : NServiceBus.IStageConnector, NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFrom, TTo>
        where TFrom : NServiceBus.Pipeline.BehaviorContext
        where TTo : NServiceBus.Pipeline.BehaviorContext
    {
        protected StageConnector() { }
        protected NServiceBus.Unicast.Transport.PipelineInfo PipelineInfo { get; }
        public virtual System.Threading.Tasks.Task Cooldown() { }
        public void Initialize(NServiceBus.Unicast.Transport.PipelineInfo pipelineInfo) { }
        public abstract System.Threading.Tasks.Task Invoke(TFrom context, System.Func<TTo, System.Threading.Tasks.Task> next);
        public virtual System.Threading.Tasks.Task Warmup() { }
    }
    public class StepRegistrationSequence
    {
        public NServiceBus.Pipeline.StepRegistrationSequence Register(string stepId, System.Type behavior, string description) { }
        public NServiceBus.Pipeline.StepRegistrationSequence Register(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type behavior, string description) { }
    }
    public class WellKnownStep
    {
        public static readonly NServiceBus.Pipeline.WellKnownStep AuditProcessedMessage;
        [System.ObsoleteAttribute("The child container creation is now an integral part of the pipeline invocation a" +
            "nd no longer a separate behavior. Will be removed in version 7.0.0.", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep CreateChildContainer;
        [System.ObsoleteAttribute("The dispatch step is the terminating step in v6 so any dependency on it can safel" +
            "y be removed. Will be removed in version 7.0.0.", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep DispatchMessageToTransport;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforcePublishBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceReplyBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceSendBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceSubscribeBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceUnsubscribeBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep ExecuteUnitOfWork;
        public static NServiceBus.Pipeline.WellKnownStep HostInformation;
        public static readonly NServiceBus.Pipeline.WellKnownStep InvokeHandlers;
        public static readonly NServiceBus.Pipeline.WellKnownStep InvokeSaga;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateIncomingMessages;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateIncomingTransportMessage;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateOutgoingMessages;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateOutgoingTransportMessage;
        public static NServiceBus.Pipeline.WellKnownStep ProcessingStatistics;
    }
}
namespace NServiceBus.Pipeline.Contexts
{
    public interface IncomingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.IMessageProcessingContext, NServiceBus.Pipeline.BehaviorContext { }
    public interface IncomingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.IMessageProcessingContext, NServiceBus.Pipeline.BehaviorContext, NServiceBus.Pipeline.Contexts.IncomingContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        NServiceBus.Unicast.Messages.LogicalMessage Message { get; }
        bool MessageHandled { get; set; }
    }
    public interface InvokeHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.IMessageHandlerContext, NServiceBus.IMessageProcessingContext, NServiceBus.Pipeline.BehaviorContext, NServiceBus.Pipeline.Contexts.IncomingContext
    {
        bool HandleCurrentMessageLaterWasCalled { get; }
        bool HandlerInvocationAborted { get; }
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        object MessageBeingHandled { get; }
        NServiceBus.Unicast.Behaviors.MessageHandler MessageHandler { get; }
        NServiceBus.Unicast.Messages.MessageMetadata MessageMetadata { get; }
    }
    [System.ObsoleteAttribute("Please use `OutgoingLogicalMessage` instead. Will be removed in version 7.0.0.", true)]
    public class OutgoingContext
    {
        public OutgoingContext() { }
    }
    public interface TransportReceiveContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.BehaviorContext
    {
        NServiceBus.Transports.IncomingMessage Message { get; }
    }
}
namespace NServiceBus.Pipeline.Outgoing
{
    public class static TransportMessageContextExtensions
    {
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.OutgoingPipeline.OutgoingReplyContext context, out NServiceBus.Transports.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.OutgoingPipeline.OutgoingLogicalMessageContext context, out NServiceBus.Transports.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.OutgoingPipeline.OutgoingPhysicalMessageContext context, out NServiceBus.Transports.IncomingMessage message) { }
    }
}
namespace NServiceBus.Pipeline.OutgoingPipeline
{
    public interface OutgoingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IBusContext, NServiceBus.OutgoingPipeline.OutgoingContext, NServiceBus.Pipeline.BehaviorContext
    {
        NServiceBus.OutgoingPipeline.OutgoingLogicalMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessageInstance(object newInstance);
    }
}
namespace NServiceBus.Routing
{
    public abstract class AddressTag
    {
        protected AddressTag() { }
    }
    public class AllInstancesDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public AllInstancesDistributionStrategy() { }
        public override System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> allInstances) { }
    }
    public abstract class DistributionStrategy
    {
        protected DistributionStrategy() { }
        public abstract System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> allInstances);
    }
    public class EndpointInstances
    {
        public EndpointInstances() { }
        public void AddDynamic(System.Func<NServiceBus.Endpoint, System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstance>> dynamicRule) { }
        public void AddStatic(NServiceBus.Endpoint endpoint, params NServiceBus.EndpointInstance[] instances) { }
    }
    public interface IUnicastRoute
    {
        System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> Resolve(System.Func<NServiceBus.Endpoint, System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstance>> instanceResolver);
    }
    public class MulticastAddressTag : NServiceBus.Routing.AddressTag
    {
        public MulticastAddressTag(System.Type messageType) { }
        public System.Type MessageType { get; }
    }
    public class MulticastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public MulticastRoutingStrategy(System.Type messageType) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public abstract class RoutingStrategy
    {
        protected RoutingStrategy() { }
        public abstract NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers);
    }
    public class SingleInstanceRoundRobinDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public SingleInstanceRoundRobinDistributionStrategy() { }
        [System.Runtime.CompilerServices.IteratorStateMachineAttribute(typeof(NServiceBus.Routing.SingleInstanceRoundRobinDistributionStrategy.<SelectDestination>d__3))]
        public override System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.UnicastRoutingTarget> currentAllInstances) { }
    }
    public interface SubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.BehaviorContext
    {
        System.Type EventType { get; }
    }
    public class UnicastAddressTag : NServiceBus.Routing.AddressTag
    {
        public UnicastAddressTag(string destination) { }
        public string Destination { get; }
    }
    public class UnicastRoute : NServiceBus.Routing.IUnicastRoute
    {
        public UnicastRoute(NServiceBus.Endpoint endpoint) { }
        public UnicastRoute(NServiceBus.EndpointInstance instance) { }
        public UnicastRoute(string physicalAddress) { }
    }
    public class UnicastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public UnicastRoutingStrategy(string destination) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public class UnicastRoutingTable
    {
        public UnicastRoutingTable() { }
        public void AddDynamic(System.Func<System.Collections.Generic.List<System.Type>, NServiceBus.Extensibility.ContextBag, System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Routing.IUnicastRoute>>> dynamicRule) { }
        public void AddDynamic(System.Func<System.Collections.Generic.List<System.Type>, NServiceBus.Extensibility.ContextBag, System.Collections.Generic.IEnumerable<NServiceBus.Routing.IUnicastRoute>> dynamicRule) { }
        public void RouteToAddress(System.Type messageType, string destinationAddress) { }
        public void RouteToEndpoint(System.Type messageType, NServiceBus.Endpoint destination) { }
        public void RouteToEndpoint(System.Type messageType, string destination) { }
    }
    public interface UnsubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.BehaviorContext
    {
        System.Type EventType { get; }
    }
}
namespace NServiceBus.Routing.Legacy
{
    public class static ConfigureMSMQDistributor
    {
        public static void EnlistWithLegacyMSMQDistributor(this NServiceBus.BusConfiguration config, string masterNodeAddress, string masterNodeControlAddress, int capacity) { }
    }
}
namespace NServiceBus.Routing.MessageDrivenSubscriptions
{
    public class PublisherAddress
    {
        public PublisherAddress(NServiceBus.Endpoint endpoint) { }
        public PublisherAddress(params NServiceBus.EndpointInstance[] instances) { }
        public PublisherAddress(params string[] addresses) { }
    }
    public class Publishers
    {
        public Publishers() { }
        public void AddDynamic(System.Func<System.Type, NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress> dynamicRule, string description = null) { }
        public void AddStatic(NServiceBus.Endpoint publisher, System.Type eventType) { }
        public void AddStatic(string publisherAddress, System.Type eventType) { }
        public void AddStatic(NServiceBus.Endpoint publisher, System.Reflection.Assembly eventAssembly, string eventNamespace = null) { }
    }
}
namespace NServiceBus.Routing.StorageDrivenPublishing
{
    [System.ObsoleteAttribute("No longer an extension point, if you want to list events without subscribers you " +
        "can take a dependency on ISubscriptionStorage and query it for the event types y" +
        "ou want to check. Will be removed in version 7.0.0.", true)]
    public class SubscribersForEvent
    {
        public SubscribersForEvent(System.Collections.Generic.List<string> subscribers, System.Type eventType) { }
        public System.Type EventType { get; }
        public System.Collections.Generic.IEnumerable<string> Subscribers { get; }
    }
}
namespace NServiceBus.Sagas
{
    public class ActiveSagaInstance
    {
        [System.ObsoleteAttribute("Please use `context.MessageHandler.Instance` instead. Will be removed in version " +
            "7.0.0.", true)]
        public NServiceBus.Saga Instance { get; }
        public bool IsNew { get; }
        public bool NotFound { get; }
        public string SagaId { get; }
        [System.ObsoleteAttribute("Please use `.Metadata.SagaType` instead. Will be removed in version 7.0.0.", true)]
        public System.Type SagaType { get; }
        public void AttachNewEntity(NServiceBus.IContainSagaData sagaEntity) { }
    }
    public interface IFinder { }
    public abstract class IFindSagas<T>
        where T : NServiceBus.IContainSagaData
    {
        protected IFindSagas() { }
        public interface Using<T, M> : NServiceBus.Sagas.IFinder
            where T : NServiceBus.IContainSagaData
        {
            System.Threading.Tasks.Task<T> FindBy(M message, NServiceBus.Persistence.SynchronizedStorageSession storageSession, NServiceBus.Extensibility.ReadOnlyContextBag context);
        }
    }
    public interface IHandleSagaNotFound
    {
        System.Threading.Tasks.Task Handle(object message, NServiceBus.IMessageProcessingContext context);
    }
    public interface ISagaPersister
    {
        System.Threading.Tasks.Task Complete(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(System.Guid sagaId, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context)
            where TSagaData : NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(string propertyName, object propertyValue, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context)
            where TSagaData : NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task Save(NServiceBus.IContainSagaData sagaData, NServiceBus.Sagas.SagaCorrelationProperty correlationProperty, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Update(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
    }
    public class SagaCorrelationProperty
    {
        public SagaCorrelationProperty(string name, object value) { }
        public string Name { get; }
        public static NServiceBus.Sagas.SagaCorrelationProperty None { get; }
        public object Value { get; }
    }
    public class SagaFinderDefinition
    {
        public SagaFinderDefinition(System.Type type, string messageType, System.Collections.Generic.Dictionary<string, object> properties) { }
        public string MessageType { get; }
        public System.Collections.Generic.Dictionary<string, object> Properties { get; }
        public System.Type Type { get; }
    }
    public class SagaMessage
    {
        public SagaMessage(string messageType, bool isAllowedToStart) { }
        public bool IsAllowedToStartSaga { get; }
        public string MessageType { get; }
    }
    public class SagaMetadata
    {
        public SagaMetadata(string name, System.Type sagaType, string entityName, System.Type sagaEntityType, NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata correlationProperty, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> messages, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> finders) { }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> AssociatedMessages { get; }
        public string EntityName { get; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> Finders { get; }
        public string Name { get; }
        public System.Type SagaEntityType { get; }
        public System.Type SagaType { get; }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType) { }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType, System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
        public bool IsMessageAllowedToStartTheSaga(string messageType) { }
        public bool TryGetCorrelationProperty(out NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata property) { }
        public bool TryGetFinder(string messageType, out NServiceBus.Sagas.SagaFinderDefinition finderDefinition) { }
        public class CorrelationPropertyMetadata
        {
            public CorrelationPropertyMetadata(string name, System.Type type) { }
            public string Name { get; }
            public System.Type Type { get; }
        }
    }
    public class SagaMetadataCollection : System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMetadata>, System.Collections.IEnumerable
    {
        public SagaMetadataCollection() { }
        public NServiceBus.Sagas.SagaMetadata Find(System.Type sagaType) { }
        public NServiceBus.Sagas.SagaMetadata FindByEntity(System.Type entityType) { }
        public System.Collections.Generic.IEnumerator<NServiceBus.Sagas.SagaMetadata> GetEnumerator() { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
    }
    [System.ObsoleteAttribute("There is no need for this attribute anymore, all mapped properties are automatica" +
        "lly correlated. Will be removed in version 7.0.0.", true)]
    public sealed class UniqueAttribute : System.Attribute
    {
        public UniqueAttribute() { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Collections.Generic.IDictionary<string, object> GetUniqueProperties(NServiceBus.IContainSagaData entity) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> GetUniqueProperties(System.Type type) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Reflection.PropertyInfo GetUniqueProperty(System.Type type) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Nullable<System.Collections.Generic.KeyValuePair<string, object>> GetUniqueProperty(NServiceBus.IContainSagaData entity) { }
    }
}
namespace NServiceBus.Satellites
{
    [System.ObsoleteAttribute(@"ISatellite is no longer an extension point. In order to create a satellite one must create a feature that uses AddSatellitePipeline() method and a class that inherits from SatelliteBehavior that is used for processing the messages. Will be removed in version 7.0.0.", true)]
    public interface IAdvancedSatellite { }
    [System.ObsoleteAttribute(@"ISatellite is no longer an extension point. In order to create a satellite one must create a feature that uses AddSatellitePipeline() method and a class that inherits from SatelliteBehavior that is used for processing the messages. Will be removed in version 7.0.0.", true)]
    public interface ISatellite { }
}
namespace NServiceBus.SecondLevelRetries.Config
{
    public class SecondLevelRetriesSettings
    {
        [System.ObsoleteAttribute("Please use `CustomRetryPolicy(Func<IncomingMessage, TimeSpan> customPolicy)` inst" +
            "ead. Will be removed in version 7.0.0.", true)]
        public void CustomRetryPolicy(System.Func<NServiceBus.TransportMessage, System.TimeSpan> customPolicy) { }
        public void CustomRetryPolicy(System.Func<NServiceBus.Transports.IncomingMessage, System.TimeSpan> customPolicy) { }
    }
}
namespace NServiceBus.Serialization
{
    public abstract class ConfigureSerialization : NServiceBus.Features.Feature
    {
        protected ConfigureSerialization() { }
        protected abstract System.Type GetSerializerType(NServiceBus.Features.FeatureConfigurationContext context);
        protected virtual void RegisterSerializer(NServiceBus.Features.FeatureConfigurationContext context, System.Type serializerType) { }
        protected internal void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public interface IMessageSerializer
    {
        string ContentType { get; }
        object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypes = null);
        void Serialize(object message, System.IO.Stream stream);
    }
    public abstract class SerializationDefinition
    {
        protected SerializationDefinition() { }
        protected internal abstract System.Type ProvidedByFeature();
    }
    public class SerializationExtentions<T> : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
        where T : NServiceBus.Serialization.SerializationDefinition
    {
        public SerializationExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.Serializers.Json
{
    public class JsonMessageSerializer : NServiceBus.Serialization.IMessageSerializer
    {
        public JsonMessageSerializer(NServiceBus.MessageInterfaces.IMessageMapper messageMapper) { }
        public string ContentType { get; }
        public System.Text.Encoding Encoding { get; set; }
        public object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypes) { }
        public object DeserializeObject(string value, System.Type type) { }
        public void Serialize(object message, System.IO.Stream stream) { }
        public string SerializeObject(object value) { }
    }
}
namespace NServiceBus.Serializers.XML
{
    public class XmlMessageSerializer : NServiceBus.Serialization.IMessageSerializer
    {
        public XmlMessageSerializer(NServiceBus.MessageInterfaces.IMessageMapper mapper, NServiceBus.Conventions conventions) { }
        public string ContentType { get; }
        public string Namespace { get; set; }
        public bool SanitizeInput { get; set; }
        public bool SkipWrappingRawXml { get; set; }
        public object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypesToDeserialize = null) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public void InitType(System.Type t) { }
        public void Serialize(object message, System.IO.Stream stream) { }
    }
}
namespace NServiceBus.Settings
{
    public interface ReadOnlySettings
    {
        void ApplyTo<T>(NServiceBus.ObjectBuilder.IComponentConfig config);
        void ApplyTo(System.Type componentType, NServiceBus.ObjectBuilder.IComponentConfig config);
        T Get<T>();
        T Get<T>(string key);
        object Get(string key);
        T GetOrDefault<T>();
        T GetOrDefault<T>(string key);
        bool HasExplicitValue(string key);
        bool HasExplicitValue<T>();
        bool HasSetting(string key);
        bool HasSetting<T>();
        bool TryGet<T>(out T val);
        bool TryGet<T>(string key, out T val);
    }
    public class ScaleOutSettings
    {
        public void UniqueQueuePerEndpointInstance() { }
        public void UniqueQueuePerEndpointInstance(string discriminator) { }
        [System.ObsoleteAttribute("This is the default starting with V6. Will be removed in version 7.0.0.", true)]
        public void UseSingleBrokerQueue() { }
        [System.ObsoleteAttribute("Please use `UniqueQueuePerEndpointInstance` instead. Will be removed in version 7" +
            ".0.0.", true)]
        public void UseUniqueBrokerQueuePerMachine() { }
    }
    public class SettingsHolder : NServiceBus.Settings.ReadOnlySettings
    {
        public SettingsHolder() { }
        public void ApplyTo<T>(NServiceBus.ObjectBuilder.IComponentConfig config) { }
        public void ApplyTo(System.Type componentType, NServiceBus.ObjectBuilder.IComponentConfig config) { }
        public T Get<T>(string key) { }
        public T Get<T>() { }
        public object Get(string key) { }
        public T GetOrDefault<T>() { }
        public T GetOrDefault<T>(string key) { }
        public bool HasExplicitValue(string key) { }
        public bool HasExplicitValue<T>() { }
        public bool HasSetting(string key) { }
        public bool HasSetting<T>() { }
        public void Set(string key, object value) { }
        public void Set<T>(object value) { }
        public void Set<T>(System.Action value) { }
        public void SetDefault<T>(object value) { }
        public void SetDefault<T>(System.Action value) { }
        public void SetDefault(string key, object value) { }
        public void SetProperty<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        public void SetPropertyDefault<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        public bool TryGet<T>(out T val) { }
        public bool TryGet<T>(string key, out T val) { }
    }
    public class TransactionSettings
    {
        public NServiceBus.Settings.TransactionSettings DefaultTimeout(System.TimeSpan defaultTimeout) { }
        public NServiceBus.Settings.TransactionSettings Disable() { }
        public NServiceBus.Settings.TransactionSettings DisableDistributedTransactions() { }
        [System.ObsoleteAttribute(@"No longer relevant since transaction scopes are no longer used by non DTC transports \r\nto do delayed dispatch. If running in DTC mode with MSMQ or SQLServer you should opt out \r\nfrom DTC Transactions using .DisableDistributedTransactions() since it would give you better \r\nperformance. Should you still want to suppress the ambient transaction you can create your own \r\nbehavior that wraps the pipeline in a suppressed transaction scope. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings DoNotWrapHandlersExecutionInATransactionScope() { }
        public NServiceBus.Settings.TransactionSettings Enable() { }
        public NServiceBus.Settings.TransactionSettings EnableDistributedTransactions() { }
        public NServiceBus.Settings.TransactionSettings IsolationLevel(System.Transactions.IsolationLevel isolationLevel) { }
        public NServiceBus.Settings.TransactionSettings WrapHandlersExecutionInATransactionScope() { }
    }
}
namespace NServiceBus.Support
{
    public class static RuntimeEnvironment
    {
        public static string MachineName { get; }
        public static System.Func<string> MachineNameAction { get; set; }
    }
}
namespace NServiceBus.Timeout.Core
{
    public interface IPersistTimeouts
    {
        System.Threading.Tasks.Task Add(NServiceBus.Timeout.Core.TimeoutData timeout, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutData> Peek(string timeoutId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task RemoveTimeoutBy(System.Guid sagaId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<bool> TryRemove(string timeoutId, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IQueryTimeouts
    {
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutsChunk> GetNextChunk(System.DateTime startSlice);
    }
    public class TimeoutData
    {
        [System.ObsoleteAttribute("Not used anymore. Will be removed in version 7.0.0.", true)]
        public const string OriginalReplyToAddress = "NServiceBus.Timeout.ReplyToAddress";
        public TimeoutData() { }
        public string Destination { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
        public string Id { get; set; }
        public string OwningTimeoutManager { get; set; }
        public System.Guid SagaId { get; set; }
        public byte[] State { get; set; }
        public System.DateTime Time { get; set; }
        [System.ObsoleteAttribute("Use new SendOptions() instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Unicast.SendOptions ToSendOptions(NServiceBus.Address replyToAddress) { }
        [System.ObsoleteAttribute("Use new SendOptions() instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Unicast.SendOptions ToSendOptions(string replyToAddress) { }
        public override string ToString() { }
        [System.ObsoleteAttribute("Use new OutgoingMessage(timeoutData.State) instead. Will be removed in version 7." +
            "0.0.", true)]
        public NServiceBus.TransportMessage ToTransportMessage() { }
    }
    public class TimeoutsChunk
    {
        public TimeoutsChunk(System.Collections.Generic.IEnumerable<NServiceBus.Timeout.Core.TimeoutsChunk.Timeout> dueTimeouts, System.DateTime nextTimeToQuery) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Timeout.Core.TimeoutsChunk.Timeout> DueTimeouts { get; }
        public System.DateTime NextTimeToQuery { get; }
        public class Timeout
        {
            public Timeout(string id, System.DateTime dueTime) { }
            public System.DateTime DueTime { get; }
            public string Id { get; }
        }
    }
}
namespace NServiceBus.TransportDispatch
{
    public interface RoutingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.BehaviorContext
    {
        NServiceBus.Transports.OutgoingMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; set; }
    }
}
namespace NServiceBus.Transports
{
    public enum DispatchConsistency
    {
        Default = 1,
        Isolated = 2,
    }
    public class DispatchOptions
    {
        public DispatchOptions(NServiceBus.Routing.AddressTag addressTag, NServiceBus.Transports.DispatchConsistency requiredDispatchConsistency, System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public NServiceBus.Routing.AddressTag AddressTag { get; }
        public System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public NServiceBus.Transports.DispatchConsistency RequiredDispatchConsistency { get; set; }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public interface IAuditMessages { }
    public interface ICancelDeferredMessages
    {
        System.Threading.Tasks.Task CancelDeferredMessages(string messageKey, NServiceBus.Pipeline.BehaviorContext context);
    }
    public interface ICreateQueues
    {
        System.Threading.Tasks.Task CreateQueueIfNecessary(NServiceBus.Transports.QueueBindings queueBindings, string identity);
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface IDeferMessages
    {
        [System.ObsoleteAttribute("Please use `ICancelDeferredMessages` instead. Will be removed in version 7.0.0.", true)]
        void ClearDeferredMessages(string headerKey, string headerValue);
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.Transport.IPushMessages` instead. Will be removed in vers" +
        "ion 7.0.0.", true)]
    public interface IDequeueMessages
    {
        void Init(NServiceBus.Address address, NServiceBus.Unicast.Transport.TransactionSettings transactionSettings, System.Func<NServiceBus.TransportMessage, bool> tryProcessMessage, System.Action<NServiceBus.TransportMessage, System.Exception> endProcessMessage);
        void Start(int maximumConcurrencyLevel);
        void Stop();
    }
    public interface IDispatchMessages
    {
        System.Threading.Tasks.Task Dispatch(System.Collections.Generic.IEnumerable<NServiceBus.Transports.TransportOperation> outgoingMessages, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IManageSubscriptions
    {
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
    }
    public class IncomingMessage
    {
        public IncomingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.IO.Stream bodyStream) { }
        public byte[] Body { get; set; }
        public System.IO.Stream BodyStream { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static IncomingMessageExtensions
    {
        public static NServiceBus.MessageIntentEnum GetMesssageIntent(this NServiceBus.Transports.IncomingMessage message) { }
        public static string GetReplyToAddress(this NServiceBus.Transports.IncomingMessage message) { }
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface IPublishMessages { }
    public interface IPushMessages
    {
        System.Threading.Tasks.Task Init(System.Func<NServiceBus.Transports.PushContext, System.Threading.Tasks.Task> pipe, NServiceBus.CriticalError criticalError, NServiceBus.Transports.PushSettings settings);
        void Start(NServiceBus.Transports.PushRuntimeSettings limitations);
        System.Threading.Tasks.Task Stop();
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface ISendMessages
    {
        void Send(NServiceBus.TransportMessage message, NServiceBus.Unicast.SendOptions sendOptions);
    }
    public class OutboundRoutingPolicy
    {
        public OutboundRoutingPolicy(NServiceBus.Transports.OutboundRoutingType sends, NServiceBus.Transports.OutboundRoutingType publishes, NServiceBus.Transports.OutboundRoutingType replies) { }
        public NServiceBus.Transports.OutboundRoutingType Publishes { get; }
        public NServiceBus.Transports.OutboundRoutingType Replies { get; }
        public NServiceBus.Transports.OutboundRoutingType Sends { get; }
    }
    public enum OutboundRoutingType
    {
        Unicast = 0,
        Multicast = 1,
    }
    public class OutgoingMessage
    {
        public OutgoingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class PushContext
    {
        public PushContext(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.IO.Stream bodyStream, NServiceBus.Transports.TransportTransaction transportTransaction, NServiceBus.Extensibility.ContextBag context) { }
        public System.IO.Stream BodyStream { get; }
        public NServiceBus.Extensibility.ContextBag Context { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public NServiceBus.Transports.TransportTransaction TransportTransaction { get; }
    }
    public class PushRuntimeSettings
    {
        public PushRuntimeSettings(int maxConcurrency = 100) { }
        public static NServiceBus.Transports.PushRuntimeSettings Default { get; }
        public int MaxConcurrency { get; }
    }
    public class PushSettings
    {
        public PushSettings(string inputQueue, string errorQueue, bool purgeOnStartup, NServiceBus.Transports.TransactionSupport requiredTransactionSupport) { }
        public string ErrorQueue { get; }
        public string InputQueue { get; }
        public bool PurgeOnStartup { get; }
        public NServiceBus.Transports.TransactionSupport RequiredTransactionSupport { get; }
    }
    public class QueueBindings
    {
        public QueueBindings() { }
        public System.Collections.Generic.IReadOnlyCollection<string> ReceivingAddresses { get; }
        public System.Collections.Generic.IReadOnlyCollection<string> SendingAddresses { get; }
        public void BindReceiving(string address) { }
        public void BindSending(string transportAddress) { }
    }
    public class StartupCheckResult
    {
        public static readonly NServiceBus.Transports.StartupCheckResult Success;
        public string ErrorMessage { get; }
        public bool Succeeded { get; }
        public static NServiceBus.Transports.StartupCheckResult Failed(string errorMessage) { }
    }
    public enum TransactionSupport
    {
        None = 0,
        SingleQueue = 1,
        MultiQueue = 2,
        Distributed = 3,
    }
    public class TransportAddresses
    {
        public TransportAddresses() { }
        public void AddRule(System.Func<NServiceBus.EndpointInstance, string> dynamicRule) { }
        public void AddSpecialCase(NServiceBus.EndpointInstance endpointInstance, string physicalAddress) { }
    }
    public abstract class TransportDefinition
    {
        protected TransportDefinition() { }
        public abstract string ExampleConnectionStringForErrorMessage { get; }
        [System.ObsoleteAttribute("Please use `GetOutboundRoutingPolicy` instead. Will be removed in version 7.0.0.", true)]
        public bool HasNativePubSubSupport { get; set; }
        [System.ObsoleteAttribute("Please use `GetOutboundRoutingPolicy` instead. Will be removed in version 7.0.0.", true)]
        public bool HasSupportForCentralizedPubSub { get; set; }
        [System.ObsoleteAttribute("GetTransactionSupport. Will be removed in version 7.0.0.", true)]
        public System.Nullable<bool> HasSupportForDistributedTransactions { get; set; }
        [System.ObsoleteAttribute("Please use `GetTransactionSupport` instead. Will be removed in version 7.0.0.", true)]
        public bool HasSupportForMultiQueueNativeTransactions { get; set; }
        public bool RequireOutboxConsent { get; set; }
        public virtual bool RequiresConnectionString { get; }
        protected internal abstract NServiceBus.Transports.TransportReceivingConfigurationResult ConfigureForReceiving(NServiceBus.Transports.TransportReceivingConfigurationContext context);
        protected internal abstract NServiceBus.Transports.TransportSendingConfigurationResult ConfigureForSending(NServiceBus.Transports.TransportSendingConfigurationContext context);
        public abstract string GetDiscriminatorForThisEndpointInstance(NServiceBus.Settings.ReadOnlySettings settings);
        public abstract NServiceBus.Transports.OutboundRoutingPolicy GetOutboundRoutingPolicy(NServiceBus.Settings.ReadOnlySettings settings);
        public abstract NServiceBus.Transports.IManageSubscriptions GetSubscriptionManager();
        public abstract System.Collections.Generic.IEnumerable<System.Type> GetSupportedDeliveryConstraints();
        public abstract NServiceBus.Transports.TransactionSupport GetTransactionSupport();
        public abstract string ToTransportAddress(NServiceBus.LogicalAddress logicalAddress);
    }
    public class TransportOperation
    {
        public TransportOperation(NServiceBus.Transports.OutgoingMessage message, NServiceBus.Transports.DispatchOptions dispatchOptions) { }
        public NServiceBus.Transports.DispatchOptions DispatchOptions { get; }
        public NServiceBus.Transports.OutgoingMessage Message { get; }
    }
    public class TransportReceivingConfigurationContext
    {
        public string ConnectionString { get; }
        public NServiceBus.Settings.ReadOnlySettings Settings { get; }
    }
    public class TransportReceivingConfigurationResult
    {
        public TransportReceivingConfigurationResult(System.Func<NServiceBus.Transports.IPushMessages> messagePumpFactory, System.Func<NServiceBus.Transports.ICreateQueues> queueCreatorFactory, System.Func<System.Threading.Tasks.Task<NServiceBus.Transports.StartupCheckResult>> preStartupCheck) { }
    }
    public class TransportSendingConfigurationContext
    {
        public string ConnectionString { get; }
        public NServiceBus.Settings.ReadOnlySettings Settings { get; }
    }
    public class TransportSendingConfigurationResult
    {
        public TransportSendingConfigurationResult(System.Func<NServiceBus.Transports.IDispatchMessages> dispatcherFactory, System.Func<System.Threading.Tasks.Task<NServiceBus.Transports.StartupCheckResult>> preStartupCheck) { }
    }
    public class TransportTransaction : NServiceBus.Extensibility.ContextBag
    {
        public TransportTransaction() { }
    }
}
namespace NServiceBus.Transports.Msmq.Config
{
    public class MsmqSettings
    {
        public MsmqSettings() { }
        public System.TimeSpan TimeToReachQueue { get; set; }
        public bool UseConnectionCache { get; set; }
        public bool UseDeadLetterQueue { get; set; }
        public bool UseJournalQueue { get; set; }
        public bool UseTransactionalQueues { get; set; }
    }
}
namespace NServiceBus.Transports.Msmq
{
    public class HeaderInfo
    {
        public HeaderInfo() { }
        public string Key { get; set; }
        public string Value { get; set; }
    }
    [System.ObsoleteAttribute("No longer available, resolve an instance of IPushMessages from the container inst" +
        "ead. Will be removed in version 7.0.0.", true)]
    public class MsmqDequeueStrategy
    {
        public MsmqDequeueStrategy() { }
    }
    public class MsmqMessageSender : NServiceBus.Transports.IDispatchMessages
    {
        public MsmqMessageSender(NServiceBus.Transports.Msmq.Config.MsmqSettings settings, NServiceBus.MsmqLabelGenerator messageLabelGenerator) { }
        public System.Threading.Tasks.Task Dispatch(System.Collections.Generic.IEnumerable<NServiceBus.Transports.TransportOperation> transportOperations, NServiceBus.Extensibility.ContextBag context) { }
    }
    [System.ObsoleteAttribute("The msmq transaction is now available via the pipeline context. Will be removed i" +
        "n version 7.0.0.", true)]
    public class MsmqUnitOfWork
    {
        public MsmqUnitOfWork() { }
    }
}
namespace NServiceBus.Unicast.Behaviors
{
    public class MessageHandler
    {
        [System.ObsoleteAttribute("Please use `MessageHandler(Action<object, object, object> invocation, Type handle" +
            "rType)` instead. Will be removed in version 7.0.0.", true)]
        public MessageHandler() { }
        public System.Type HandlerType { get; }
        public object Instance { get; set; }
        [System.ObsoleteAttribute("Please use `MessageHandler.Invoke` instead. Will be removed in version 7.0.0.", true)]
        public System.Action<object, object> Invocation { get; set; }
        public System.Threading.Tasks.Task Invoke(object message, NServiceBus.IMessageHandlerContext handlerContext) { }
    }
}
namespace NServiceBus.Unicast
{
    public class static BuilderExtensions
    {
        public static void ForEach<T>(this NServiceBus.ObjectBuilder.IBuilder builder, System.Action<T> action) { }
    }
    [System.ObsoleteAttribute("No longer used, please use the new callbacks api described in the v6 upgrade guid" +
        "e. Will be removed in version 7.0.0.", true)]
    public class BusAsyncResult
    {
        public BusAsyncResult() { }
    }
    public class DeliveryMessageOptions
    {
        public DeliveryMessageOptions() { }
        [System.ObsoleteAttribute("Use the ConsistencyGuarantee class instead. Will be removed in version 7.0.0.", true)]
        public bool EnlistInReceiveTransaction { get; set; }
        [System.ObsoleteAttribute("Use context.TryGetDeliveryConstraint<NonDurableDelivery> instead. Will be removed" +
            " in version 7.0.0.", true)]
        public System.Nullable<bool> NonDurable { get; set; }
        [System.ObsoleteAttribute("Use context.TryGetDeliveryConstraint<DiscardIfNotReceivedBefore> instead. Will be" +
            " removed in version 7.0.0.", true)]
        public System.Nullable<System.TimeSpan> TimeToBeReceived { get; set; }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.UnicastBus.DeliveryMessageOptions` instead. Will be remov" +
        "ed in version 7.0.0.", true)]
    public abstract class DeliveryOptions
    {
        protected DeliveryOptions() { }
        [System.ObsoleteAttribute("Turn best practices check off using configuration.DisableFeature<BestPracticeEnfo" +
            "rcement>(). Will be removed in version 7.0.0.", true)]
        public bool EnforceMessagingBestPractices { get; set; }
        [System.ObsoleteAttribute("Reply to address can be get/set using the `NServiceBus.ReplyToAddress` header. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public string ReplyToAddress { get; set; }
    }
    [System.ObsoleteAttribute("Not a public API. Please use `MessageHandlerRegistry` instead. Will be removed in" +
        " version 7.0.0.", true)]
    public interface IMessageHandlerRegistry { }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class MessageContext
    {
        public MessageContext() { }
    }
    public class MessageEventArgs : System.EventArgs
    {
        public MessageEventArgs(object msg) { }
        public object Message { get; }
    }
    public class MessageHandlerRegistry
    {
        [System.ObsoleteAttribute("Please use `MessageHandlerRegistry.RegisterHandler(Type handlerType)` instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public void CacheMethodForHandler(System.Type handler, System.Type messageType) { }
        public void Clear() { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Behaviors.MessageHandler> GetHandlersFor(System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `MessageHandlerRegistry.GetHandlersFor(Type messageType)` instead. Wil" +
            "l be removed in version 7.0.0.", true)]
        public System.Collections.Generic.IEnumerable<System.Type> GetHandlerTypes(System.Type messageType) { }
        public System.Collections.Generic.IEnumerable<System.Type> GetMessageTypes() { }
        [System.ObsoleteAttribute("Please use `MessageHandler.Invoke(object message, object context)` instead. Will " +
            "be removed in version 7.0.0.", true)]
        public void InvokeHandle(object handler, object message) { }
        [System.ObsoleteAttribute("Please use `MessageHandler.Invoke(object message, object context)` instead. Will " +
            "be removed in version 7.0.0.", true)]
        public void InvokeTimeout(object handler, object state) { }
        public void RegisterHandler(System.Type handlerType) { }
    }
    public class MessagesEventArgs : System.EventArgs
    {
        public MessagesEventArgs(object[] messages) { }
        public object[] Messages { get; }
    }
    [System.ObsoleteAttribute("Use context.Intent to detect of the message is a event being published and use co" +
        "ntext.MessageType to get the actual event type. Will be removed in version 7.0.0" +
        ".", true)]
    public class PublishOptions : NServiceBus.Unicast.DeliveryOptions
    {
        public PublishOptions() { }
    }
    [System.ObsoleteAttribute("Not used anymore, use the \'NServiceBus.MessageIntent\' header to detect if the mes" +
        "sage is a reply. Will be removed in version 7.0.0.", true)]
    public class ReplyOptions
    {
        public ReplyOptions() { }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.UnicastBus.SendMessageOptions` instead. Will be removed i" +
        "n version 7.0.0.", true)]
    public class SendOptions : NServiceBus.Unicast.DeliveryOptions
    {
        [System.ObsoleteAttribute("Please use `SendMessageOptions(string)` instead. Will be removed in version 7.0.0" +
            ".", true)]
        public SendOptions(NServiceBus.Address destination) { }
        [System.ObsoleteAttribute("Reply to address can be get/set using the `NServiceBus.CorrelationId` header. Wil" +
            "l be removed in version 7.0.0.", true)]
        public string CorrelationId { get; set; }
        [System.ObsoleteAttribute("Please use `DelayDeliveryFor` instead. Will be removed in version 7.0.0.", true)]
        public System.Nullable<System.TimeSpan> DelayDeliveryWith { get; set; }
    }
    [System.ObsoleteAttribute("UnicastBus has been made internal. Use IBusContextFactory to interact with the bu" +
        "s from outside of the handler. Will be removed in version 7.0.0.", true)]
    public class UnicastBus
    {
        public UnicastBus() { }
    }
}
namespace NServiceBus.Unicast.Messages
{
    public class LogicalMessage
    {
        public object Instance { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Unicast.Messages.MessageMetadata Metadata { get; }
        public void UpdateMessageInstance(object newInstance) { }
    }
    public class LogicalMessageFactory
    {
        public LogicalMessageFactory(NServiceBus.Unicast.Messages.MessageMetadataRegistry messageMetadataRegistry, NServiceBus.MessageInterfaces.IMessageMapper messageMapper) { }
        public NServiceBus.Unicast.Messages.LogicalMessage Create(object message) { }
        public NServiceBus.Unicast.Messages.LogicalMessage Create(System.Type messageType, object message) { }
    }
    public class MessageMetadata
    {
        public System.Collections.Generic.IEnumerable<System.Type> MessageHierarchy { get; }
        public System.Type MessageType { get; }
        [System.ObsoleteAttribute("You can access Recoverable via the DeliveryConstraints collection on the outgoing" +
            " context, the new constraint is called NonDurableDelivery. Will be removed in ve" +
            "rsion 7.0.0.", true)]
        public bool Recoverable { get; }
        [System.ObsoleteAttribute("You can access TTBR via the DeliveryConstraints collection on the outgoing contex" +
            "t. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class MessageMetadataRegistry
    {
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(System.Type messageType) { }
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(string messageTypeIdentifier) { }
    }
}
namespace NServiceBus.Unicast.Queuing
{
    [System.ObsoleteAttribute("Please use `QueueBindings` instead. Will be removed in version 7.0.0.", true)]
    public interface IWantQueueCreated { }
    public class QueueNotFoundException : System.Exception
    {
        public QueueNotFoundException() { }
        [System.ObsoleteAttribute("Please use `QueueNotFoundException(string queue, string message, Exception inner)" +
            "` instead. Will be removed in version 7.0.0.", true)]
        public QueueNotFoundException(NServiceBus.Address queue, string message, System.Exception inner) { }
        public QueueNotFoundException(string queue, string message, System.Exception inner) { }
        protected QueueNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public string Queue { get; set; }
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
}
namespace NServiceBus.Unicast.Routing
{
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class StaticMessageRouter
    {
        public StaticMessageRouter() { }
        [System.ObsoleteAttribute("Please use `config.AutoSubscribe().AutoSubscribePlainMessages()` instead. Will be" +
            " removed in version 7.0.0.", true)]
        public bool SubscribeToPlainMessages { get; set; }
    }
}
namespace NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions
{
    public interface IInitializableSubscriptionStorage : NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.ISubscriptionStorage
    {
        void Init();
    }
    public interface ISubscriptionStorage
    {
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber>> GetSubscriberAddressesForMessage(System.Collections.Generic.IReadOnlyCollection<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Subscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
    }
    public class Subscriber
    {
        public Subscriber(string transportAddress, NServiceBus.Endpoint endpoint) { }
        public NServiceBus.Endpoint Endpoint { get; }
        public string TransportAddress { get; }
    }
}
namespace NServiceBus.Unicast.Subscriptions
{
    public class MessageType
    {
        public MessageType(System.Type type) { }
        public MessageType(string messageTypeString) { }
        public MessageType(string typeName, string versionString) { }
        public MessageType(string typeName, System.Version version) { }
        public string TypeName { get; }
        public System.Version Version { get; }
        public bool Equals(NServiceBus.Unicast.Subscriptions.MessageType other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class SubscriptionEventArgs
    {
        public SubscriptionEventArgs() { }
    }
}
namespace NServiceBus.Unicast.Transport
{
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class static ControlMessage { }
    public class static ControlMessageFactory
    {
        public static NServiceBus.Transports.OutgoingMessage Create(NServiceBus.MessageIntentEnum intent) { }
    }
    [System.ObsoleteAttribute("Use the pipeline to catch failures. Will be removed in version 7.0.0.", true)]
    public class FailedMessageProcessingEventArgs : System.EventArgs
    {
        public FailedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class FinishedMessageProcessingEventArgs : System.EventArgs
    {
        public FinishedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("Please use `IPushMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface ITransport { }
    public class PipelineInfo
    {
        public PipelineInfo(string name, string transportAddress) { }
        public string Name { get; }
        public string TransportAddress { get; }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class StartedMessageProcessingEventArgs
    {
        public StartedMessageProcessingEventArgs() { }
    }
    public class TransactionSettings
    {
        [System.ObsoleteAttribute("No longer used. Will be removed in version 7.0.0.", true)]
        public TransactionSettings(bool isTransactional, System.TimeSpan transactionTimeout, System.Transactions.IsolationLevel isolationLevel, bool suppressDistributedTransactions, bool doNotWrapHandlersExecutionInATransactionScope) { }
        [System.ObsoleteAttribute("DoNotWrapHandlersExecutionInATransactionScope is no longer used here. Please use " +
            "settings.GetOrDefault<bool>(\'Transactions.DoNotWrapHandlersExecutionInATransacti" +
            "onScope\') instead. Will be removed in version 7.0.0.", true)]
        public bool DoNotWrapHandlersExecutionInATransactionScope { get; set; }
        public System.Transactions.IsolationLevel IsolationLevel { get; set; }
        [System.ObsoleteAttribute("IsTransactional is no longer used here. Please use `context.Settings.GetRequiredT" +
            "ransactionSupportForReceives() != TransactionSupport.None` instead. Will be remo" +
            "ved in version 7.0.0.", true)]
        public bool IsTransactional { get; set; }
        [System.ObsoleteAttribute("SuppressDistributedTransactions is no longer used here. Please use `context.Setti" +
            "ngs.GetRequiredTransactionSupportForReceives() != TransactionSupport.Distributed" +
            "` instead. Will be removed in version 7.0.0.", true)]
        public bool SuppressDistributedTransactions { get; set; }
        public System.TimeSpan TransactionTimeout { get; set; }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportMessageAvailableEventArgs
    {
        public TransportMessageAvailableEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportMessageReceivedEventArgs
    {
        public TransportMessageReceivedEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportReceiver
    {
        public TransportReceiver() { }
    }
}
namespace NServiceBus.UnitOfWork
{
    public interface IManageUnitsOfWork
    {
        System.Threading.Tasks.Task Begin();
        System.Threading.Tasks.Task End(System.Exception ex = null);
    }
}