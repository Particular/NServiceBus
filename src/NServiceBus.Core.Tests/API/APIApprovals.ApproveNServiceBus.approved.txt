[assembly: System.CLSCompliantAttribute(true)]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.AcceptanceTesting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Core.Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Hosting.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.PerformanceTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"ReturnToSourceQueue, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.5.1", FrameworkDisplayName=".NET Framework 4.5.1")]
namespace NServiceBus
{
    [System.ObsoleteAttribute("Use the string based overloads. Will be removed in version 7.0.0.", true)]
    public class Address
    {
        public Address() { }
    }
    public enum AddressMode
    {
        Local = 0,
        Remote = 1,
    }
    [System.ObsoleteAttribute("Please use `BusConfiguration.ExcludeAssemblies` instead. Will be removed in versi" +
        "on 7.0.0.", true)]
    public class AllAssemblies : NServiceBus.IExcludesBuilder, NServiceBus.IIncludesBuilder
    {
        public AllAssemblies() { }
    }
    public class static AutoSubscribeSettingsExtensions
    {
        public static NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings AutoSubscribe(this NServiceBus.BusConfiguration config) { }
    }
    public class BatchDispatchContext : NServiceBus.Pipeline.BehaviorContext
    {
        public BatchDispatchContext(System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> operations, NServiceBus.Pipeline.BehaviorContext parentContext) { }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> Operations { get; }
    }
    public class static BestPracticesOptionExtensions
    {
        public static void DoNotEnforceBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.OutgoingPipeline.OutgoingReplyContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.OutgoingPipeline.OutgoingSendContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Routing.SubscribeContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.OutgoingPipeline.OutgoingPublishContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Routing.UnsubscribeContext context) { }
    }
    public class static Bus
    {
        public static NServiceBus.IStartableBus Create(NServiceBus.BusConfiguration configuration) { }
        public static NServiceBus.ISendOnlyBus CreateSendOnly(NServiceBus.BusConfiguration configuration) { }
    }
    [System.ObsoleteAttribute("No longer used, please use the new callbacks api described in the v6 upgrade guid" +
        "e. Will be removed in version 7.0.0.", true)]
    public class BusAsyncResultEventArgs : System.EventArgs
    {
        public BusAsyncResultEventArgs() { }
        public string MessageId { get; set; }
        public NServiceBus.Unicast.BusAsyncResult Result { get; set; }
    }
    public class BusConfiguration : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public BusConfiguration() { }
        [System.ObsoleteAttribute("Please use `SetOutgoingHeaders(string key,string value)` instead. Will be removed" +
            " in version 7.0.0.", true)]
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        [System.ObsoleteAttribute("Please use `ExcludeAssemblies` instead. Will be removed in version 7.0.0.", true)]
        public void AssembliesToScan(System.Collections.Generic.IEnumerable<System.Reflection.Assembly> assemblies) { }
        [System.ObsoleteAttribute("Please use `ExcludeAssemblies` instead. Will be removed in version 7.0.0.", true)]
        public void AssembliesToScan(params System.Reflection.Assembly[] assemblies) { }
        public NServiceBus.ConventionsBuilder Conventions() { }
        public void CustomConfigurationSource(NServiceBus.Config.ConfigurationSource.IConfigurationSource configurationSource) { }
        public void EndpointName(string name) { }
        public void ExcludeAssemblies(params string[] assemblies) { }
        public void ExcludeTypes(params System.Type[] types) { }
        [System.ObsoleteAttribute("Please use `UseCustomLogicalToTransportAddressTranslation` instead. Will be remov" +
            "ed in version 7.0.0.", true)]
        public void OverrideLocalAddress(string queue) { }
        public void OverridePublicReturnAddress(string address) { }
        [System.ObsoleteAttribute("Please use `OverridePublicReturnAddress(string address)` instead. Will be removed" +
            " in version 7.0.0.", true)]
        public void OverridePublicReturnAddress(NServiceBus.Address address) { }
        public void RegisterComponents(System.Action<NServiceBus.ObjectBuilder.IConfigureComponents> registration) { }
        [System.ObsoleteAttribute("Please use `ExcludeAssemblies` instead. Will be removed in version 7.0.0.", true)]
        public void ScanAssembliesInDirectory(string probeDirectory) { }
        public void ScanAssembliesInNestedDirectories() { }
        [System.ObsoleteAttribute("Please use `ExcludeTypes` instead. Will be removed in version 7.0.0.", true)]
        public void TypesToScan(System.Collections.Generic.IEnumerable<System.Type> typesToScan) { }
        public void UseContainer<T>(System.Action<NServiceBus.Container.ContainerCustomizations> customizations = null)
            where T : NServiceBus.Container.ContainerDefinition, new () { }
        public void UseContainer(System.Type definitionType) { }
        public void UseContainer(NServiceBus.ObjectBuilder.Common.IContainer builder) { }
        public void UseCustomLogicalToTransportAddressTranslation(System.Func<NServiceBus.LogicalAddress, string, string> translation) { }
    }
    public class BusNotifications : System.IDisposable
    {
        public BusNotifications() { }
        public NServiceBus.Faults.ErrorsNotifications Errors { get; }
        public NServiceBus.Pipeline.PipelineNotifications Pipeline { get; }
    }
    [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
    public class CompletionResult
    {
        public CompletionResult() { }
    }
    public class static ConfigurationBuilderExtensions
    {
        public static void DisableFeature<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void DisableFeature(this NServiceBus.BusConfiguration config, System.Type featureType) { }
        public static void EnableFeature<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void EnableFeature(this NServiceBus.BusConfiguration config, System.Type featureType) { }
    }
    public class static ConfigurationTimeoutExtensions
    {
        public static void TimeToWaitBeforeTriggeringCriticalErrorOnTimeoutOutages(this NServiceBus.BusConfiguration config, System.TimeSpan timeToWait) { }
    }
    public class Configure
    {
        public NServiceBus.ObjectBuilder.IBuilder Builder { get; }
        [System.ObsoleteAttribute("Please use `ReadOnlySettings.LocalAddress()` instead. Will be removed in version " +
            "7.0.0.", true)]
        public string LocalAddress { get; }
        [System.ObsoleteAttribute("Static headers is no longer accessible via this object. Will be removed in versio" +
            "n 7.0.0.", true)]
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public NServiceBus.Settings.SettingsHolder Settings { get; }
        public System.Collections.Generic.IList<System.Type> TypesToScan { get; }
    }
    public class static ConfigureAudit
    {
        public static void AuditProcessedMessagesTo(this NServiceBus.BusConfiguration config, string auditQueue, System.Nullable<System.TimeSpan> timeToBeReceived = null) { }
    }
    public class static ConfigureCriticalErrorAction
    {
        public static void DefineCriticalErrorAction(this NServiceBus.BusConfiguration busConfiguration, System.Action<string, System.Exception> onCriticalError) { }
    }
    public class static ConfigureError
    {
        public static void SendFailedMessagesTo(this NServiceBus.BusConfiguration config, string errorQueue) { }
    }
    public class static ConfigureFileShareDataBus
    {
        public static NServiceBus.DataBus.DataBusExtentions<NServiceBus.FileShareDataBus> BasePath(this NServiceBus.DataBus.DataBusExtentions<NServiceBus.FileShareDataBus> config, string basePath) { }
    }
    public class static ConfigureHandlerSettings
    {
        public static void InitializeHandlerProperty<THandler>(this NServiceBus.BusConfiguration config, string property, object value) { }
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class static ConfigureInMemoryFaultManagement
    {
        [System.ObsoleteAttribute("This is no longer supported. If you want full control over what happens when a me" +
            "ssage fails (including retries) please override the MoveFaultsToErrorQueue behav" +
            "ior. Will be removed in version 7.0.0.", true)]
        public static void DiscardFailedMessagesInsteadOfSendingToErrorQueue(this NServiceBus.BusConfiguration config) { }
    }
    public class static ConfigureLicenseExtensions
    {
        public static void License(this NServiceBus.BusConfiguration config, string licenseText) { }
        public static void LicensePath(this NServiceBus.BusConfiguration config, string licenseFile) { }
    }
    public class static ConfigurePurging
    {
        public static void PurgeOnStartup(this NServiceBus.BusConfiguration config, bool value) { }
        [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
        public static bool PurgeOnStartup(this NServiceBus.Configure config) { }
    }
    public class static ConfigureQueueCreation
    {
        public static bool CreateQueues(this NServiceBus.Configure config) { }
        public static void DoNotCreateQueues(this NServiceBus.BusConfiguration config) { }
    }
    public class static ConfigureRijndaelEncryptionService
    {
        public static void RegisterEncryptionService(this NServiceBus.BusConfiguration config, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Encryption.IEncryptionService> func) { }
        public static void RijndaelEncryptionService(this NServiceBus.BusConfiguration config) { }
        public static void RijndaelEncryptionService(this NServiceBus.BusConfiguration config, string encryptionKey, System.Collections.Generic.List<string> expiredKeys = null) { }
    }
    public class static ConfigureTransportConnectionString
    {
        public static string TransportConnectionString(this NServiceBus.Configure config) { }
    }
    public abstract class ContainSagaData : NServiceBus.IContainSagaData
    {
        protected ContainSagaData() { }
        public virtual System.Guid Id { get; set; }
        public virtual string OriginalMessageId { get; set; }
        public virtual string Originator { get; set; }
    }
    public class static ContentTypes
    {
        public const string Json = "application/json";
        public const string Xml = "text/xml";
    }
    public class Conventions
    {
        public Conventions() { }
        public void AddSystemMessagesConventions(System.Func<System.Type, bool> definesMessageType) { }
        [System.ObsoleteAttribute("No longer an extension point. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan GetTimeToBeReceived(System.Type messageType) { }
        public bool IsCommandType(System.Type t) { }
        public bool IsDataBusProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEncryptedProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEventType(System.Type t) { }
        [System.ObsoleteAttribute("No longer an extension point. Will be removed in version 7.0.0.", true)]
        public static bool IsExpressMessageType(System.Type t) { }
        public bool IsInSystemConventionList(System.Type t) { }
        public bool IsMessageType(System.Type t) { }
    }
    public class ConventionsBuilder : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.ConventionsBuilder DefiningCommandsAs(System.Func<System.Type, bool> definesCommandType) { }
        public NServiceBus.ConventionsBuilder DefiningDataBusPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesDataBusProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEncryptedPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesEncryptedProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEventsAs(System.Func<System.Type, bool> definesEventType) { }
        public NServiceBus.ConventionsBuilder DefiningMessagesAs(System.Func<System.Type, bool> definesMessageType) { }
    }
    public class static CorrelationContextExtensions
    {
        public static void SetCorrelationId(this NServiceBus.SendOptions options, string correlationId) { }
        public static void SetCorrelationId(this NServiceBus.ReplyOptions options, string correlationId) { }
    }
    public class CriticalError
    {
        public CriticalError(System.Action<string, System.Exception> onCriticalErrorAction, NServiceBus.ObjectBuilder.IBuilder builder) { }
        public virtual void Raise(string errorMessage, System.Exception exception) { }
    }
    public class static CriticalTimeMonitoringConfig
    {
        public static void EnableCriticalTimePerformanceCounter(this NServiceBus.BusConfiguration config) { }
    }
    public class DataBusProperty<T> : NServiceBus.IDataBusProperty, System.Runtime.Serialization.ISerializable
        where T :  class
    {
        public DataBusProperty(T value) { }
        protected DataBusProperty(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public bool HasValue { get; set; }
        public string Key { get; set; }
        public T Value { get; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public object GetValue() { }
        public void SetValue(object valueToSet) { }
    }
    public class static DateTimeExtensions
    {
        public static System.DateTime ToUtcDateTime(string wireFormattedString) { }
        public static string ToWireFormattedString(System.DateTime dateTime) { }
    }
    public class static DelayedDeliveryOptionExtensions
    {
        public static void DelayDeliveryWith(this NServiceBus.SendOptions options, System.TimeSpan delay) { }
        public static void DoNotDeliverBefore(this NServiceBus.SendOptions options, System.DateTime at) { }
    }
    public enum DependencyLifecycle
    {
        SingleInstance = 0,
        InstancePerUnitOfWork = 1,
        InstancePerCall = 2,
    }
    public class DispatchContext : NServiceBus.Pipeline.BehaviorContext
    {
        public DispatchContext(System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transports.TransportOperation> operations, NServiceBus.Pipeline.BehaviorContext parentContext) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Transports.TransportOperation> Operations { get; }
    }
    public class static DurableMessagesConfig
    {
        public static void DisableDurableMessages(this NServiceBus.BusConfiguration config) { }
        public static bool DurableMessagesEnabled(this NServiceBus.Configure config) { }
        public static void EnableDurableMessages(this NServiceBus.BusConfiguration config) { }
    }
    public class static DurableMessagesConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningExpressMessagesAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, bool> definesExpressMessageType) { }
    }
    public class EncryptedValue
    {
        public EncryptedValue() { }
        public string Base64Iv { get; set; }
        public string EncryptedBase64Value { get; set; }
    }
    public sealed class EndpointInstanceName
    {
        public EndpointInstanceName(NServiceBus.EndpointName endpointName, string userDiscriminator, string transportDiscriminator) { }
        public NServiceBus.EndpointName EndpointName { get; }
        public string TransportDiscriminator { get; }
        public string UserDiscriminator { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public sealed class EndpointName
    {
        public EndpointName(string name) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class ExpressAttribute : System.Attribute
    {
        public ExpressAttribute() { }
    }
    [System.ObsoleteAttribute("Headers are not managed via the send, reply and publishoptions. Will be removed i" +
        "n version 7.0.0.", true)]
    public class static ExtensionMethods
    {
        [System.ObsoleteAttribute("Use a incoming behavior to get access to the current message. Will be removed in " +
            "version 7.0.0.", true)]
        public static object CurrentMessageBeingHandled { get; set; }
        [System.ObsoleteAttribute("Headers are not \'set\' only on the outgoing pipeline. Will be removed in version 7" +
            ".0.0.", true)]
        public static string GetMessageHeader(this NServiceBus.IBus bus, object msg, string key) { }
        [System.ObsoleteAttribute("Headers can be set using the ``.SetHeader` method on the context object passed in" +
            "to your behavior or mutator. Will be removed in version 7.0.0.", true)]
        public static void SetMessageHeader(this NServiceBus.ISendOnlyBus bus, object msg, string key, string value) { }
    }
    public class static FileBasedRoutingConfigurationExtensions
    {
        public static NServiceBus.FileRoutingTableSettings UseFileBasedEndpointInstanceLists(this NServiceBus.RoutingSettings config) { }
    }
    public class FileRoutingTableSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public FileRoutingTableSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public void LookForFilesIn(string path) { }
    }
    public class FileShareDataBus : NServiceBus.DataBus.DataBusDefinition
    {
        public FileShareDataBus() { }
        protected internal override System.Type ProvidedByFeature() { }
    }
    [System.ObsoleteAttribute("Please use `BusConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed " +
        "in version 7.0.0.", true)]
    public class First<T>
    {
        public First() { }
    }
    public class static HeaderOptionExtensions
    {
        public static void SetHeader(this NServiceBus.Extensibility.ExtendableOptions context, string key, string value) { }
    }
    public class static Headers
    {
        public const string ContentType = "NServiceBus.ContentType";
        public const string ControlMessageHeader = "NServiceBus.ControlMessage";
        public const string ConversationId = "NServiceBus.ConversationId";
        public const string CorrelationId = "NServiceBus.CorrelationId";
        public const string DestinationSites = "NServiceBus.DestinationSites";
        public const string EnclosedMessageTypes = "NServiceBus.EnclosedMessageTypes";
        public const string FLRetries = "NServiceBus.FLRetries";
        public const string HasLicenseExpired = "$.diagnostics.license.expired";
        public const string HeaderName = "Header";
        public const string HostDisplayName = "$.diagnostics.hostdisplayname";
        public const string HostId = "$.diagnostics.hostid";
        public const string HttpFrom = "NServiceBus.From";
        public const string HttpTo = "NServiceBus.To";
        public const string IsDeferredMessage = "NServiceBus.IsDeferredMessage";
        public const string IsSagaTimeoutMessage = "NServiceBus.IsSagaTimeoutMessage";
        public const string MessageId = "NServiceBus.MessageId";
        public const string MessageIntent = "NServiceBus.MessageIntent";
        public const string NonDurableMessage = "NServiceBus.NonDurableMessage";
        public const string NServiceBusVersion = "NServiceBus.Version";
        public const string OriginatingAddress = "NServiceBus.OriginatingAddress";
        public const string OriginatingEndpoint = "NServiceBus.OriginatingEndpoint";
        public const string OriginatingHostId = "$.diagnostics.originating.hostid";
        public const string OriginatingMachine = "NServiceBus.OriginatingMachine";
        public const string OriginatingSagaId = "NServiceBus.OriginatingSagaId";
        public const string OriginatingSagaType = "NServiceBus.OriginatingSagaType";
        public const string OriginatingSite = "NServiceBus.OriginatingSite";
        public const string ProcessingEnded = "NServiceBus.ProcessingEnded";
        public const string ProcessingEndpoint = "NServiceBus.ProcessingEndpoint";
        public const string ProcessingMachine = "NServiceBus.ProcessingMachine";
        public const string ProcessingStarted = "NServiceBus.ProcessingStarted";
        public const string RelatedTo = "NServiceBus.RelatedTo";
        public const string ReplyToAddress = "NServiceBus.ReplyToAddress";
        public const string Retries = "NServiceBus.Retries";
        public const string ReturnMessageErrorCodeHeader = "NServiceBus.ReturnMessage.ErrorCode";
        public const string RouteTo = "NServiceBus.Header.RouteTo";
        public const string SagaId = "NServiceBus.SagaId";
        public const string SagaType = "NServiceBus.SagaType";
        public const string SendVia = "NServiceBus.SendVia";
        public const string SubscriptionMessageType = "SubscriptionMessageType";
        public const string TimeSent = "NServiceBus.TimeSent";
        public const string TimeToBeReceived = "NServiceBus.TimeToBeReceived";
        public const string UltimateDestination = "NServiceBus.UltimateDestination";
        public const string WindowsIdentityName = "WinIdName";
    }
    public class static HostInfoConfigurationExtensions
    {
        public static NServiceBus.HostInfoSettings UniquelyIdentifyRunningInstance(this NServiceBus.BusConfiguration config) { }
    }
    public class HostInfoSettings
    {
        public NServiceBus.HostInfoSettings UsingCustomDisplayName(string displayName) { }
        public NServiceBus.HostInfoSettings UsingCustomIdentifier(System.Guid id) { }
        public NServiceBus.HostInfoSettings UsingInstalledFilePath() { }
        public NServiceBus.HostInfoSettings UsingNames(string instanceName, string hostName) { }
    }
    public interface IAmStartedByMessages<T> : NServiceBus.IHandleMessages<T> { }
    [System.ObsoleteAttribute("This feature has been removed. To support authorization on a per subscription mes" +
        "sage type use a pipeline step instead. Will be removed in version 7.0.0.", true)]
    public interface IAuthorizeSubscriptions
    {
        bool AuthorizeSubscribe(string messageType, string clientEndpoint, System.Collections.Generic.IDictionary<string, string> headers);
        bool AuthorizeUnsubscribe(string messageType, string clientEndpoint, System.Collections.Generic.IDictionary<string, string> headers);
    }
    public interface IBus : NServiceBus.ISendOnlyBus, System.IDisposable
    {
        NServiceBus.IMessageContext CurrentMessageContext { get; }
        [System.ObsoleteAttribute("Please use `SendLocalAsync(object message, SendLocalOptions options)` instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        NServiceBus.ICallback Defer(System.TimeSpan delay, object message);
        [System.ObsoleteAttribute("Please use `SendLocalAsync(object message, SendLocalOptions options)` instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        NServiceBus.ICallback Defer(System.DateTime processAt, object message);
        void DoNotContinueDispatchingCurrentMessageToHandlers();
        System.Threading.Tasks.Task ForwardCurrentMessageToAsync(string destination);
        System.Threading.Tasks.Task HandleCurrentMessageLaterAsync();
        System.Threading.Tasks.Task ReplyAsync(object message, NServiceBus.ReplyOptions options);
        System.Threading.Tasks.Task ReplyAsync<T>(System.Action<T> messageConstructor, NServiceBus.ReplyOptions options);
        [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
        void Return<T>(T errorEnum);
        System.Threading.Tasks.Task SubscribeAsync(System.Type eventType, NServiceBus.SubscribeOptions options);
        System.Threading.Tasks.Task UnsubscribeAsync(System.Type eventType, NServiceBus.UnsubscribeOptions options);
    }
    public class static IBusExtensions
    {
        [System.ObsoleteAttribute("Please use `ForwardCurrentMessageToAsync(string destination)` instead. Will be re" +
            "moved in version 7.0.0.", true)]
        public static void ForwardCurrentMessageTo(this NServiceBus.IBus bus, string destination) { }
        [System.ObsoleteAttribute("Please use `HandleCurrentMessageLaterAsync()` instead. Will be removed in version" +
            " 7.0.0.", true)]
        public static void HandleCurrentMessageLater(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Please use `ReplyAsync(object message)` instead. Will be removed in version 7.0.0" +
            ".", true)]
        public static void Reply(this NServiceBus.IBus bus, object message) { }
        [System.ObsoleteAttribute("Please use `ReplyAsync<T>(Action<T> messageConstructor)` instead. Will be removed" +
            " in version 7.0.0.", true)]
        public static void Reply<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task ReplyAsync(this NServiceBus.IBus bus, object message) { }
        public static System.Threading.Tasks.Task ReplyAsync<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `SendLocalAsync(object message)` instead. Will be removed in version 7" +
            ".0.0.", true)]
        public static void SendLocal(this NServiceBus.IBus bus, object message) { }
        [System.ObsoleteAttribute("Please use `SendLocalAsync<T>(Action<T> messageConstructor)` instead. Will be rem" +
            "oved in version 7.0.0.", true)]
        public static void SendLocal<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocalAsync(this NServiceBus.IBus bus, object message) { }
        public static System.Threading.Tasks.Task SendLocalAsync<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `SubscribeAsync(Type messageType)` instead. Will be removed in version" +
            " 7.0.0.", true)]
        public static void Subscribe(this NServiceBus.IBus bus, System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `SubscribeAsync<T>()` instead. Will be removed in version 7.0.0.", true)]
        public static void Subscribe<T>(this NServiceBus.IBus bus) { }
        public static System.Threading.Tasks.Task SubscribeAsync(this NServiceBus.IBus bus, System.Type messageType) { }
        public static System.Threading.Tasks.Task SubscribeAsync<T>(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Please use `UnsubscribeAsync(Type messageType)` instead. Will be removed in versi" +
            "on 7.0.0.", true)]
        public static void Unsubscribe(this NServiceBus.IBus bus, System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `UnsubscribeAsync<T>()` instead. Will be removed in version 7.0.0.", true)]
        public static void Unsubscribe<T>(this NServiceBus.IBus bus) { }
        public static System.Threading.Tasks.Task UnsubscribeAsync(this NServiceBus.IBus bus, System.Type messageType) { }
        public static System.Threading.Tasks.Task UnsubscribeAsync<T>(this NServiceBus.IBus bus) { }
    }
    [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
    public interface ICallback { }
    public interface ICommand : NServiceBus.IMessage { }
    public interface IConfigureHowToFindSagaWithMessage
    {
        void ConfigureMapping<TSagaEntity, TMessage>(System.Linq.Expressions.Expression<System.Func<TSagaEntity, object>> sagaEntityProperty, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty)
            where TSagaEntity : NServiceBus.IContainSagaData
        ;
    }
    public interface IContainSagaData
    {
        System.Guid Id { get; set; }
        string OriginalMessageId { get; set; }
        string Originator { get; set; }
    }
    public interface IDataBusProperty
    {
        bool HasValue { get; set; }
        string Key { get; set; }
        object GetValue();
        void SetValue(object value);
    }
    public interface IEvent : NServiceBus.IMessage { }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public interface IExcludesBuilder { }
    public interface IHandleMessages<T>
    {
        System.Threading.Tasks.Task Handle(T message);
    }
    public interface IHandleTimeouts<T>
    {
        System.Threading.Tasks.Task Timeout(T state);
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public interface IIncludesBuilder { }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public interface IManageMessageHeaders
    {
        System.Func<object, string, string> GetHeaderAction { get; }
        System.Action<object, string, string> SetHeaderAction { get; }
    }
    public interface IMessage { }
    public interface IMessageContext
    {
        System.Collections.Generic.IDictionary<string, string> Headers { get; }
        string Id { get; }
        string ReplyToAddress { get; }
    }
    public interface IMessageCreator
    {
        T CreateInstance<T>();
        T CreateInstance<T>(System.Action<T> action);
        object CreateInstance(System.Type messageType);
    }
    public class static ImmediateDispatchOptionExtensions
    {
        public static void RequireImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public interface INeedInitialization
    {
        void Customize(NServiceBus.BusConfiguration configuration);
    }
    public class InMemoryPersistence : NServiceBus.Persistence.PersistenceDefinition { }
    public class static InstallConfigExtensions
    {
        public static void EnableInstallers(this NServiceBus.BusConfiguration config, string username = null) { }
    }
    public interface ISendOnlyBus : System.IDisposable
    {
        System.Threading.Tasks.Task PublishAsync(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task PublishAsync<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task SendAsync(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task SendAsync<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
    }
    public class static ISendOnlyBusExtensions
    {
        [System.ObsoleteAttribute("Please use `PublishAsync(object message)` instead. Will be removed in version 7.0" +
            ".0.", true)]
        public static void Publish(this NServiceBus.ISendOnlyBus bus, object message) { }
        [System.ObsoleteAttribute("Please use `PublishAsync()` instead. Will be removed in version 7.0.0.", true)]
        public static void Publish<T>(this NServiceBus.ISendOnlyBus bus) { }
        [System.ObsoleteAttribute("Please use `PublishAsyn<T>(Action<T> messageConstructor)` instead. Will be remove" +
            "d in version 7.0.0.", true)]
        public static void Publish<T>(this NServiceBus.ISendOnlyBus bus, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task PublishAsync(this NServiceBus.ISendOnlyBus bus, object message) { }
        public static System.Threading.Tasks.Task PublishAsync<T>(this NServiceBus.ISendOnlyBus bus) { }
        public static System.Threading.Tasks.Task PublishAsync<T>(this NServiceBus.ISendOnlyBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `SendAsync(object message)` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static void Send(this NServiceBus.ISendOnlyBus bus, object message) { }
        [System.ObsoleteAttribute("Please use `SendAsync<T>(Action<T> messageConstructor)` instead. Will be removed " +
            "in version 7.0.0.", true)]
        public static void Send<T>(this NServiceBus.ISendOnlyBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Please use `SendAsync(string destination, object message)` instead. Will be remov" +
            "ed in version 7.0.0.", true)]
        public static void Send(this NServiceBus.ISendOnlyBus bus, string destination, object message) { }
        [System.ObsoleteAttribute("Please use `SendAsync<T>(string destination, Action<T> messageConstructor)` inste" +
            "ad. Will be removed in version 7.0.0.", true)]
        public static void Send<T>(this NServiceBus.ISendOnlyBus bus, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendAsync(this NServiceBus.ISendOnlyBus bus, object message) { }
        public static System.Threading.Tasks.Task SendAsync<T>(this NServiceBus.ISendOnlyBus bus, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendAsync(this NServiceBus.ISendOnlyBus bus, string destination, object message) { }
        public static System.Threading.Tasks.Task SendAsync<T>(this NServiceBus.ISendOnlyBus bus, string destination, System.Action<T> messageConstructor) { }
    }
    [System.ObsoleteAttribute("Please use `BusConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed " +
        "in version 7.0.0.", true)]
    public interface ISpecifyMessageHandlerOrdering
    {
        void SpecifyOrder(NServiceBus.Order order);
    }
    public interface IStartableBus : NServiceBus.IBus, NServiceBus.ISendOnlyBus, System.IDisposable
    {
        System.Threading.Tasks.Task<NServiceBus.IBus> StartAsync();
    }
    public class static IStartableBusExtensions
    {
        [System.ObsoleteAttribute("Please use `StartAsync()` instead. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.IBus Start(this NServiceBus.IStartableBus bus) { }
    }
    public interface IWantToRunBeforeConfigurationIsFinalized
    {
        void Run(NServiceBus.Configure config);
    }
    public interface IWantToRunWhenBusStartsAndStops
    {
        System.Threading.Tasks.Task StartAsync();
        System.Threading.Tasks.Task StopAsync();
    }
    public class static IWantToRunWhenBusStartsAndStopsExtensions_obsoletes
    {
        [System.ObsoleteAttribute("Please use `StartAsync()` instead. Will be removed in version 7.0.0.", true)]
        public static void Start(this NServiceBus.IWantToRunWhenBusStartsAndStops runnable) { }
        [System.ObsoleteAttribute("Please use `StopAsync()` instead. Will be removed in version 7.0.0.", true)]
        public static void Stop(this NServiceBus.IWantToRunWhenBusStartsAndStops runnable) { }
    }
    public class JsonSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public JsonSerializer() { }
        protected internal override System.Type ProvidedByFeature() { }
    }
    public class static JsonSerializerConfigurationExtensions
    {
        public static void Encoding(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.JsonSerializer> config, System.Text.Encoding encoding) { }
    }
    public class static LoadMessageHandlersExtentions
    {
        public static void ExecuteTheseHandlersFirst(this NServiceBus.BusConfiguration config, System.Collections.Generic.IEnumerable<System.Type> handlerTypes) { }
        public static void ExecuteTheseHandlersFirst(this NServiceBus.BusConfiguration config, params System.Type[] handlerTypes) { }
        [System.ObsoleteAttribute("Please use `ExecuteTheseHandlersFirst` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static void LoadMessageHandlers<TFirst>(this NServiceBus.BusConfiguration config) { }
        [System.ObsoleteAttribute("Please use `ExecuteTheseHandlersFirst` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static void LoadMessageHandlers<T>(this NServiceBus.BusConfiguration config, NServiceBus.First<T> order) { }
    }
    public sealed class LogicalAddress
    {
        public LogicalAddress(NServiceBus.EndpointInstanceName endpointInstanceName, string qualifier) { }
        public LogicalAddress(NServiceBus.EndpointInstanceName endpointInstanceName) { }
        public NServiceBus.EndpointInstanceName EndpointInstanceName { get; }
        public string Qualifier { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class MessageDeserializationException : System.Runtime.Serialization.SerializationException
    {
        public MessageDeserializationException(string message) { }
        public MessageDeserializationException(string transportMessageId, System.Exception innerException) { }
        protected MessageDeserializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static MessageIdExtensions
    {
        public static string GetMessageId(this NServiceBus.OutgoingPipeline.OutgoingPhysicalMessageContext context) { }
        public static string GetMessageId(this NServiceBus.Pipeline.Contexts.OutgoingLogicalMessageContext context) { }
        public static void SetMessageId(this NServiceBus.Extensibility.ExtendableOptions context, string messageId) { }
    }
    public enum MessageIntentEnum
    {
        Send = 1,
        Publish = 2,
        Subscribe = 3,
        Unsubscribe = 4,
        Reply = 5,
    }
    public class static MessageProcessingOptimizationExtensions
    {
        public static void LimitMessageProcessingConcurrencyTo(this NServiceBus.BusConfiguration config, int maxConcurrency) { }
    }
    public class static MsmqConfigurationExtensions
    {
        public static void ApplyLabelToMessages(this NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> transportExtensions, NServiceBus.MsmqLabelGenerator generateLabel) { }
    }
    public delegate string MsmqLabelGenerator(System.Collections.Generic.IReadOnlyDictionary<string, string> headers);
    public class MsmqTransport : NServiceBus.Transports.TransportDefinition
    {
        public MsmqTransport() { }
        protected internal override void Configure(NServiceBus.BusConfiguration config) { }
        public override string GetDiscriminatorForThisEndpointInstance() { }
        public override NServiceBus.Transports.OutboundRoutingPolicy GetOutboundRoutingPolicy(NServiceBus.Settings.ReadOnlySettings settings) { }
        public override NServiceBus.Transports.IManageSubscriptions GetSubscriptionManager() { }
        public override System.Collections.Generic.IEnumerable<System.Type> GetSupportedDeliveryConstraints() { }
        public override NServiceBus.Transports.TransactionSupport GetTransactionSupport() { }
        public override string ToTransportAddress(NServiceBus.LogicalAddress logicalAddress) { }
    }
    public class NonDurableDelivery : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public NonDurableDelivery() { }
    }
    [System.ObsoleteAttribute("Please use `BusConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed " +
        "in version 7.0.0.", true)]
    public class Order
    {
        public Order() { }
        public System.Collections.Generic.IEnumerable<System.Type> Types { get; set; }
        public void Specify<T>(NServiceBus.First<T> ordering) { }
        public void Specify(params System.Type[] priorityHandlers) { }
        public void SpecifyFirst<T>() { }
    }
    public class static OutboxConfigExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings EnableOutbox(this NServiceBus.BusConfiguration config) { }
    }
    public class static PersistenceConfig
    {
        public static NServiceBus.PersistenceExtentions<T> UsePersistence<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition { }
        public static NServiceBus.PersistenceExtentions<T, S> UsePersistence<T, S>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition
            where S : NServiceBus.Persistence.StorageType { }
        public static NServiceBus.PersistenceExtentions UsePersistence(this NServiceBus.BusConfiguration config, System.Type definitionType) { }
    }
    public class PersistenceExtentions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public PersistenceExtentions(System.Type definitionType, NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
        [System.ObsoleteAttribute("Please use `UsePersistence<T, S>()` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PersistenceExtentions For(params NServiceBus.Persistence.Storage[] specificStorages) { }
    }
    public class PersistenceExtentions<T> : NServiceBus.PersistenceExtentions
        where T : NServiceBus.Persistence.PersistenceDefinition
    {
        public PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings) { }
        protected PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
        [System.ObsoleteAttribute("Please use `UsePersistence<T, S>()` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PersistenceExtentions<T> For(params NServiceBus.Persistence.Storage[] specificStorages) { }
    }
    public class PersistenceExtentions<T, S> : NServiceBus.PersistenceExtentions<T>
        where T : NServiceBus.Persistence.PersistenceDefinition
        where S : NServiceBus.Persistence.StorageType
    {
        public PersistenceExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class PhysicalMessageProcessingContext : NServiceBus.Pipeline.Contexts.IncomingContext
    {
        public PhysicalMessageProcessingContext(NServiceBus.Transports.IncomingMessage message, NServiceBus.Pipeline.BehaviorContext parentContext) { }
        public NServiceBus.Transports.IncomingMessage Message { get; }
    }
    public class PipelineDiagnostics
    {
        public PipelineDiagnostics() { }
        public System.IObservable<NServiceBus.Pipeline.StepStarted> Steps { get; }
    }
    public class static PublishersSettingsExtensions
    {
        public static NServiceBus.Routing.MessageDrivenSubscriptions.Publishers Pubishers(this NServiceBus.BusConfiguration config) { }
    }
    public class PublishOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public PublishOptions() { }
    }
    public class ReplyOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public ReplyOptions() { }
    }
    public class static RoutingOptionExtensions
    {
        public static void OverrideReplyToAddressOfIncomingMessage(this NServiceBus.ReplyOptions option, string destination) { }
        public static void RouteToLocalEndpointInstance(this NServiceBus.SendOptions option) { }
        public static void SetDestination(this NServiceBus.SendOptions option, string destination) { }
    }
    public class RoutingSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.Routing.DistributionPolicy DistributionPolicy { get; }
        public NServiceBus.Routing.EndpointInstances EndpointInstances { get; }
        public NServiceBus.Routing.UnicastRoutingTable UnicastRoutingTable { get; }
    }
    public class static RoutingSettingsExtensions
    {
        public static NServiceBus.RoutingSettings Routing(this NServiceBus.BusConfiguration config) { }
    }
    public abstract class Saga
    {
        protected Saga() { }
        public NServiceBus.IBus Bus { get; set; }
        public bool Completed { get; }
        public NServiceBus.IContainSagaData Entity { get; set; }
        protected internal abstract void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
        protected void MarkAsComplete() { }
        [System.ObsoleteAttribute("Please use `ReplyToOriginator(object message)` instead. Will be removed in versio" +
            "n 7.0.0.", true)]
        protected void ReplyToOriginator(object message) { }
        [System.ObsoleteAttribute("Construct your message and pass it to the non Action overload. Please use `ReplyT" +
            "oOriginatorAsync(object message)` instead. Will be removed in version 7.0.0.", true)]
        protected virtual void ReplyToOriginator<TMessage>(System.Action<TMessage> messageConstructor)
            where TMessage : new() { }
        protected System.Threading.Tasks.Task ReplyToOriginatorAsync(object message) { }
        [System.ObsoleteAttribute("Please use `RequestTimeoutAsync<TTimeoutMessageType>(DateTime at)` instead. Will " +
            "be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at)
            where TTimeoutMessageType : new() { }
        [System.ObsoleteAttribute("Construct your message and pass it to the non Action overload. Please use `Reques" +
            "tTimeoutAsync<TTimeoutMessageType>(DateTime, TTimeoutMessageType)` instead. Will" +
            " be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at, System.Action<TTimeoutMessageType> action)
            where TTimeoutMessageType : new() { }
        [System.ObsoleteAttribute("Please use `RequestTimeoutAsync<TTimeoutMessageType>(DateTime at, TTimeoutMessage" +
            "Type timeoutMessage)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        [System.ObsoleteAttribute("Please use `RequestTimeoutAsync<TTimeoutMessageType>(TimeSpan within)` instead. W" +
            "ill be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within)
            where TTimeoutMessageType : new() { }
        [System.ObsoleteAttribute("Construct your message and pass it to the non Action overload. Please use `Saga.R" +
            "equestTimeoutAsync<TTimeoutMessageType>(TimeSpan, TTimeoutMessageType)` instead." +
            " Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within, System.Action<TTimeoutMessageType> messageConstructor)
            where TTimeoutMessageType : new() { }
        [System.ObsoleteAttribute("Please use `RequestTimeoutAsync<TTimeoutMessageType>(TimeSpan within, TTimeoutMes" +
            "sageType timeoutMessage)` instead. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
        protected System.Threading.Tasks.Task RequestTimeoutAsync<TTimeoutMessageType>(System.DateTime at)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeoutAsync<TTimeoutMessageType>(System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        protected System.Threading.Tasks.Task RequestTimeoutAsync<TTimeoutMessageType>(System.TimeSpan within)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeoutAsync<TTimeoutMessageType>(System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
    }
    public abstract class Saga<TSagaData> : NServiceBus.Saga
        where TSagaData : NServiceBus.IContainSagaData, new ()
    {
        protected Saga() { }
        public TSagaData Data { get; set; }
        protected internal override void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration) { }
        protected abstract void ConfigureHowToFindSaga(NServiceBus.SagaPropertyMapper<TSagaData> mapper);
    }
    public class SagaPropertyMapper<TSagaData>
        where TSagaData : NServiceBus.IContainSagaData
    {
        public NServiceBus.ToSagaExpression<TSagaData, TMessage> ConfigureMapping<TMessage>(System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
    }
    public abstract class SatelliteBehavior : NServiceBus.Pipeline.PipelineTerminator<NServiceBus.PhysicalMessageProcessingContext>
    {
        protected SatelliteBehavior() { }
    }
    public class static ScaleOutExtentions
    {
        public static NServiceBus.Settings.ScaleOutSettings ScaleOut(this NServiceBus.BusConfiguration config) { }
    }
    public class Schedule
    {
        public Schedule(NServiceBus.ObjectBuilder.IBuilder builder) { }
        public void Every(System.TimeSpan timeSpan, System.Action task) { }
        public void Every(System.TimeSpan timeSpan, string name, System.Action task) { }
    }
    public class static SecondLevelRetriesConfigExtensions
    {
        public static NServiceBus.SecondLevelRetries.Config.SecondLevelRetriesSettings SecondLevelRetries(this NServiceBus.BusConfiguration config) { }
    }
    public class SendOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SendOptions() { }
    }
    public class static SerializationConfigExtensions
    {
        public static void AddDeserializer<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtentions<T> UseSerialization<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static void UseSerialization(this NServiceBus.BusConfiguration config, System.Type serializerType) { }
    }
    public class static SerializationContextExtensions
    {
        public static void SkipSerialization(this NServiceBus.Pipeline.Contexts.OutgoingLogicalMessageContext context) { }
    }
    public class static SettingsExtentions
    {
        public static NServiceBus.EndpointInstanceName EndpointInstanceName(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static NServiceBus.EndpointName EndpointName(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static System.Collections.Generic.IList<System.Type> GetAvailableTypes(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static T GetConfigSection<T>(this NServiceBus.Settings.ReadOnlySettings settings)
            where T :  class, new () { }
        public static string LocalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static NServiceBus.LogicalAddress RootLogicalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public class static SLAMonitoringConfig
    {
        public static void EnableSLAPerformanceCounter(this NServiceBus.BusConfiguration config, System.TimeSpan sla) { }
        public static void EnableSLAPerformanceCounter(this NServiceBus.BusConfiguration config) { }
    }
    public class static StaticHeadersConfigExtensions
    {
        public static void AddHeaderToAllOutgoingMessages(this NServiceBus.BusConfiguration config, string key, string value) { }
    }
    public class SubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SubscribeOptions() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class TimeToBeReceivedAttribute : System.Attribute
    {
        public TimeToBeReceivedAttribute(string timeSpan) { }
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class static TimeToBeReceivedConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningTimeToBeReceivedAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, System.TimeSpan> retrieveTimeToBeReceived) { }
    }
    public class ToSagaExpression<TSagaData, TMessage>
        where TSagaData : NServiceBus.IContainSagaData
    {
        public ToSagaExpression(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
        public void ToSaga(System.Linq.Expressions.Expression<System.Func<TSagaData, object>> sagaEntityProperty) { }
    }
    public class static TransactionSettingsExtentions
    {
        public static NServiceBus.Settings.TransactionSettings Transactions(this NServiceBus.BusConfiguration config) { }
    }
    public class TransportExtensions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions AddAddressTranslationException(NServiceBus.EndpointInstanceName endpointInstance, string transportAddress) { }
        public NServiceBus.TransportExtensions AddAddressTranslationRule(System.Func<NServiceBus.EndpointInstanceName, string> rule) { }
        public NServiceBus.TransportExtensions ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions ConnectionString(System.Func<string> connectionString) { }
        public NServiceBus.TransportExtensions ConnectionStringName(string name) { }
    }
    public class TransportExtensions<T> : NServiceBus.TransportExtensions
        where T : NServiceBus.Transports.TransportDefinition
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(System.Func<string> connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionStringName(string name) { }
    }
    public class TransportMessage
    {
        [System.ObsoleteAttribute("Not used anymore, you most likely should use a `OutgoingMessage` instead. Will be" +
            " removed in version 7.0.0.", true)]
        public TransportMessage() { }
        [System.ObsoleteAttribute("Not used anymore, you most likely should use a `IncomingMessage` instead. Will be" +
            " removed in version 7.0.0.", true)]
        public TransportMessage(string existingId, System.Collections.Generic.Dictionary<string, string> existingHeaders) { }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.Body\' instead. Will be removed in version 7" +
            ".0.0.", true)]
        public byte[] Body { get; set; }
        [System.ObsoleteAttribute("Use the value of the \'NServiceBus.CorrelationId\' header instead. Will be removed " +
            "in version 7.0.0.", true)]
        public string CorrelationId { get; set; }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.Headers\' or \'OutgoingMesssage.Headers\' inst" +
            "ead. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.MessageId\' or \'OutgoingMesssage.MessageId\' " +
            "instead. Will be removed in version 7.0.0.", true)]
        public string Id { get; }
        [System.ObsoleteAttribute("Please use `GetMessageIntent(this IncomingMessage message)` instead. Will be remo" +
            "ved in version 7.0.0.", true)]
        public NServiceBus.MessageIntentEnum MessageIntent { get; }
        [System.ObsoleteAttribute("For sending purposes use DeliveryMessageOptions.NonDurable (note the negation). W" +
            "hen receiving look at the new \'NServiceBus.NonDurableMessage\' header. Will be re" +
            "moved in version 7.0.0.", true)]
        public bool Recoverable { get; set; }
        [System.ObsoleteAttribute("Please use `GetReplyToAddress(this IncomingMessage message)` instead. Will be rem" +
            "oved in version 7.0.0.", true)]
        public string ReplyToAddress { get; }
        [System.ObsoleteAttribute("For sending purposes use DeliveryMessageOptions.TimeToBeReceived. When receiving " +
            "look at the new \'NServiceBus.TimeToBeReceived\' header. Will be removed in versio" +
            "n 7.0.0.", true)]
        public System.TimeSpan TimeToBeReceived { get; set; }
    }
    public class UnsubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public UnsubscribeOptions() { }
    }
    public class static UseDataBusExtensions
    {
        public static NServiceBus.DataBus.DataBusExtentions<T> UseDataBus<T>(this NServiceBus.BusConfiguration config)
            where T : NServiceBus.DataBus.DataBusDefinition, new () { }
        public static NServiceBus.DataBus.DataBusExtentions UseDataBus(this NServiceBus.BusConfiguration config, System.Type dataBusType) { }
    }
    public class static UseTransportExtensions
    {
        public static NServiceBus.TransportExtensions<T> UseTransport<T>(this NServiceBus.BusConfiguration busConfiguration)
            where T : NServiceBus.Transports.TransportDefinition, new () { }
        public static NServiceBus.TransportExtensions UseTransport(this NServiceBus.BusConfiguration busConfiguration, System.Type transportDefinitionType) { }
    }
    public class WireEncryptedString : System.Runtime.Serialization.ISerializable
    {
        public WireEncryptedString() { }
        public WireEncryptedString(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        [System.ObsoleteAttribute("No longer required. Will be removed in version 7.0.0.", true)]
        public string Base64Iv { get; set; }
        [System.ObsoleteAttribute("No longer required. Will be removed in version 7.0.0.", true)]
        public string EncryptedBase64Value { get; set; }
        public NServiceBus.EncryptedValue EncryptedValue { get; set; }
        public string Value { get; set; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static XmlSerializationExtentions
    {
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> DontWrapRawXml(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config) { }
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> Namespace(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config, string namespaceToUse) { }
        public static NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> SanitizeInput(this NServiceBus.Serialization.SerializationExtentions<NServiceBus.XmlSerializer> config) { }
    }
    public class XmlSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public XmlSerializer() { }
        protected internal override System.Type ProvidedByFeature() { }
    }
}
namespace NServiceBus.Audit
{
    public class AuditContext : NServiceBus.Pipeline.BehaviorContext
    {
        public AuditContext(NServiceBus.Transports.OutgoingMessage message, string auditAddress, NServiceBus.Pipeline.BehaviorContext parent) { }
        public string AuditAddress { get; }
        public NServiceBus.Transports.OutgoingMessage Message { get; }
    }
    public class static AuditContextExtensions
    {
        public static void AddAuditData(this NServiceBus.Audit.AuditContext context, string key, string value) { }
    }
}
namespace NServiceBus.AutomaticSubscriptions.Config
{
    public class AutoSubscribeSettings
    {
        public void AutoSubscribePlainMessages() { }
        public void DoNotAutoSubscribeSagas() { }
        [System.ObsoleteAttribute("Transports with support for centralized pubsub will default this to true. Can saf" +
            "ely be removed. Will be removed in version 7.0.0.", true)]
        public void DoNotRequireExplicitRouting() { }
    }
}
namespace NServiceBus.Config
{
    public class AuditConfig : System.Configuration.ConfigurationSection
    {
        public AuditConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("OverrideTimeToBeReceived", IsRequired=false)]
        public System.TimeSpan OverrideTimeToBeReceived { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("QueueName", IsRequired=false)]
        public string QueueName { get; set; }
    }
    [System.ObsoleteAttribute("Use the feature concept instead via A class which inherits from `NServiceBus.Feat" +
        "ures.Feature` and use `configuration.EnableFeature<YourClass>()`. Will be remove" +
        "d in version 7.0.0.", true)]
    public interface IWantToRunWhenConfigurationIsComplete
    {
        void Run(NServiceBus.Configure config);
    }
    public class Logging : System.Configuration.ConfigurationSection
    {
        public Logging() { }
        [System.Configuration.ConfigurationPropertyAttribute("Threshold", DefaultValue="Info", IsRequired=true)]
        public string Threshold { get; set; }
    }
    public class MasterNodeConfig : System.Configuration.ConfigurationSection
    {
        public MasterNodeConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("Node", IsRequired=true)]
        public string Node { get; set; }
    }
    public class MessageEndpointMapping : System.Configuration.ConfigurationElement, System.IComparable<NServiceBus.Config.MessageEndpointMapping>
    {
        public MessageEndpointMapping() { }
        [System.Configuration.ConfigurationPropertyAttribute("Assembly", IsRequired=false)]
        public string AssemblyName { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Endpoint", IsRequired=true)]
        public string Endpoint { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Messages", IsRequired=false)]
        public string Messages { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Namespace", IsRequired=false)]
        public string Namespace { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Type", IsRequired=false)]
        public string TypeFullName { get; set; }
        public int CompareTo(NServiceBus.Config.MessageEndpointMapping other) { }
        public void Configure(System.Action<System.Type, string> mapTypeToEndpoint) { }
    }
    public class MessageEndpointMappingCollection : System.Configuration.ConfigurationElementCollection
    {
        public MessageEndpointMappingCollection() { }
        public new string AddElementName { get; set; }
        public new string ClearElementName { get; set; }
        public override System.Configuration.ConfigurationElementCollectionType CollectionType { get; }
        public new int Count { get; }
        public NServiceBus.Config.MessageEndpointMapping this[int index] { get; set; }
        public NServiceBus.Config.MessageEndpointMapping this[string Name] { get; }
        public new string RemoveElementName { get; }
        public void Add(NServiceBus.Config.MessageEndpointMapping mapping) { }
        protected override void BaseAdd(System.Configuration.ConfigurationElement element) { }
        public void Clear() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement(string elementName) { }
        protected override object GetElementKey(System.Configuration.ConfigurationElement element) { }
        public int IndexOf(NServiceBus.Config.MessageEndpointMapping mapping) { }
        public override bool IsReadOnly() { }
        public void Remove(NServiceBus.Config.MessageEndpointMapping mapping) { }
        public void Remove(string name) { }
        public void RemoveAt(int index) { }
    }
    public class MessageForwardingInCaseOfFaultConfig : System.Configuration.ConfigurationSection
    {
        public MessageForwardingInCaseOfFaultConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("ErrorQueue", IsRequired=true)]
        public string ErrorQueue { get; set; }
    }
    public class MsmqSubscriptionStorageConfig : System.Configuration.ConfigurationSection
    {
        public MsmqSubscriptionStorageConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("Queue", IsRequired=true)]
        public string Queue { get; set; }
    }
    public class RijndaelEncryptionServiceConfig : System.Configuration.ConfigurationSection
    {
        public RijndaelEncryptionServiceConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("ExpiredKeys", IsRequired=false)]
        public NServiceBus.Config.RijndaelExpiredKeyCollection ExpiredKeys { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Key", IsRequired=true)]
        public string Key { get; set; }
    }
    public class RijndaelExpiredKey : System.Configuration.ConfigurationElement, System.IComparable<NServiceBus.Config.RijndaelExpiredKey>
    {
        public RijndaelExpiredKey() { }
        [System.Configuration.ConfigurationPropertyAttribute("Key", IsRequired=true)]
        public string Key { get; set; }
    }
    public class RijndaelExpiredKeyCollection : System.Configuration.ConfigurationElementCollection
    {
        public RijndaelExpiredKeyCollection() { }
        public override System.Configuration.ConfigurationElementCollectionType CollectionType { get; }
        public NServiceBus.Config.RijndaelExpiredKey this[int index] { get; set; }
        public NServiceBus.Config.RijndaelExpiredKey this[string key] { get; }
        public void Add(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        protected override void BaseAdd(System.Configuration.ConfigurationElement element) { }
        public void Clear() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement(string elementName) { }
        protected override object GetElementKey(System.Configuration.ConfigurationElement element) { }
        public int IndexOf(NServiceBus.Config.RijndaelExpiredKey encryptionKey) { }
        public override bool IsReadOnly() { }
        public void Remove(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        public void Remove(string name) { }
        public void RemoveAt(int index) { }
    }
    public class SecondLevelRetriesConfig : System.Configuration.ConfigurationSection
    {
        public SecondLevelRetriesConfig() { }
        public bool Enabled { get; set; }
        public int NumberOfRetries { get; set; }
        public System.TimeSpan TimeIncrease { get; set; }
    }
    public class TransportConfig : System.Configuration.ConfigurationSection
    {
        public TransportConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("MaximumConcurrencyLevel", DefaultValue=0, IsRequired=false)]
        public int MaximumConcurrencyLevel { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MaximumMessageThroughputPerSecond", DefaultValue=-1, IsRequired=false)]
        public int MaximumMessageThroughputPerSecond { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MaxRetries", DefaultValue=5, IsRequired=false)]
        public int MaxRetries { get; set; }
    }
    public class UnicastBusConfig : System.Configuration.ConfigurationSection
    {
        public UnicastBusConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("DistributorControlAddress", IsRequired=false)]
        public string DistributorControlAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("DistributorDataAddress", IsRequired=false)]
        public string DistributorDataAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("ForwardReceivedMessagesTo", IsRequired=false)]
        public string ForwardReceivedMessagesTo { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MessageEndpointMappings", IsRequired=false)]
        public NServiceBus.Config.MessageEndpointMappingCollection MessageEndpointMappings { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("TimeoutManagerAddress", IsRequired=false)]
        public string TimeoutManagerAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("TimeToBeReceivedOnForwardedMessages", IsRequired=false)]
        public System.TimeSpan TimeToBeReceivedOnForwardedMessages { get; set; }
    }
}
namespace NServiceBus.Config.ConfigurationSource
{
    public class DefaultConfigurationSource : NServiceBus.Config.ConfigurationSource.IConfigurationSource
    {
        public DefaultConfigurationSource() { }
    }
    public interface IConfigurationSource
    {
        T GetConfiguration<T>()
            where T :  class, new ();
    }
    public interface IProvideConfiguration<T>
    {
        T GetConfiguration();
    }
}
namespace NServiceBus.Configuration.AdvanceExtensibility
{
    public class static AdvanceExtensibilityExtensions
    {
        public static NServiceBus.Settings.SettingsHolder GetSettings(this NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings config) { }
    }
    public abstract class ExposeSettings
    {
        protected ExposeSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.ConsistencyGuarantees
{
    public enum ConsistencyGuarantee
    {
        AtMostOnce = 1,
        AtLeastOnce = 2,
        ExactlyOnce = 3,
    }
    public class static ConsistencyGuaranteeSettingsExtensions
    {
        public static NServiceBus.Transports.TransactionSupport GetRequiredTransactionSupportForReceives(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
}
namespace NServiceBus.Container
{
    public class ContainerCustomizations
    {
        public NServiceBus.Settings.SettingsHolder Settings { get; }
    }
    public abstract class ContainerDefinition
    {
        protected ContainerDefinition() { }
        public abstract NServiceBus.ObjectBuilder.Common.IContainer CreateContainer(NServiceBus.Settings.ReadOnlySettings settings);
    }
}
namespace NServiceBus.DataBus
{
    public abstract class DataBusDefinition
    {
        protected DataBusDefinition() { }
        protected internal abstract System.Type ProvidedByFeature();
    }
    public class DataBusExtentions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public DataBusExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class DataBusExtentions<T> : NServiceBus.DataBus.DataBusExtentions
        where T : NServiceBus.DataBus.DataBusDefinition
    {
        public DataBusExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public interface IDataBus
    {
        System.Threading.Tasks.Task<System.IO.Stream> Get(string key);
        System.Threading.Tasks.Task<string> Put(System.IO.Stream stream, System.TimeSpan timeToBeReceived);
        System.Threading.Tasks.Task Start();
    }
    public interface IDataBusSerializer
    {
        object Deserialize(System.IO.Stream stream);
        void Serialize(object databusProperty, System.IO.Stream stream);
    }
}
namespace NServiceBus.DelayedDelivery
{
    public class DelayDeliveryWith : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DelayDeliveryWith(System.TimeSpan delay) { }
        public System.TimeSpan Delay { get; }
    }
    public abstract class DelayedDeliveryConstraint : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        protected DelayedDeliveryConstraint() { }
    }
    public class DoNotDeliverBefore : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DoNotDeliverBefore(System.DateTime at) { }
        public System.DateTime At { get; }
    }
}
namespace NServiceBus.DeliveryConstraints
{
    public abstract class DeliveryConstraint
    {
        protected DeliveryConstraint() { }
    }
    public class static DeliveryConstraintContextExtensions
    {
        public static void AddDeliveryConstraint(this NServiceBus.TransportDispatch.RoutingContext context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static void AddDeliveryConstraint(this NServiceBus.Pipeline.Contexts.OutgoingLogicalMessageContext context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> GetDeliveryConstraints(this NServiceBus.TransportDispatch.RoutingContext context) { }
        public static void RemoveDeliveryConstaint(this NServiceBus.TransportDispatch.RoutingContext context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static bool TryGetDeliveryConstraint<T>(this NServiceBus.TransportDispatch.RoutingContext context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
        public static bool TryGetDeliveryConstraint<T>(this NServiceBus.Pipeline.Contexts.OutgoingLogicalMessageContext context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
    }
}
namespace NServiceBus.Encryption
{
    public interface IEncryptionService
    {
        string Decrypt(NServiceBus.EncryptedValue encryptedValue);
        NServiceBus.EncryptedValue Encrypt(string value);
    }
}
namespace NServiceBus.Extensibility
{
    public class ContextBag : NServiceBus.Extensibility.ReadOnlyContextBag
    {
        public ContextBag(NServiceBus.Extensibility.ContextBag parentBag = null) { }
        public T Get<T>() { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public void Merge(NServiceBus.Extensibility.ContextBag context) { }
        public void Remove<T>() { }
        public void Set<T>(T t) { }
        public void Set<T>(string key, T t) { }
        public bool TryGet<T>(out T result) { }
        public bool TryGet<T>(string key, out T result) { }
        public bool TryGetRootContext<T>(out T result)
            where T : NServiceBus.Extensibility.ContextBag { }
    }
    public abstract class ExtendableOptions
    {
        protected ExtendableOptions() { }
    }
    public class static ExtendableOptionsExtensions
    {
        public static NServiceBus.Extensibility.ContextBag GetExtensions(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public interface ReadOnlyContextBag
    {
        T Get<T>();
        bool TryGet<T>(out T result);
        bool TryGet<T>(string key, out T result);
    }
}
namespace NServiceBus.Faults
{
    public class ErrorsNotifications : System.IDisposable
    {
        public ErrorsNotifications() { }
        public System.IObservable<NServiceBus.Faults.SecondLevelRetry> MessageHasBeenSentToSecondLevelRetries { get; }
        public System.IObservable<NServiceBus.Faults.FirstLevelRetry> MessageHasFailedAFirstLevelRetryAttempt { get; }
        public System.IObservable<NServiceBus.Faults.FailedMessage> MessageSentToErrorQueue { get; }
    }
    public struct FailedMessage
    {
        public FailedMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static FaultsHeaderKeys
    {
        public const string FailedQ = "NServiceBus.FailedQ";
    }
    public struct FirstLevelRetry
    {
        public FirstLevelRetry(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public int RetryAttempt { get; }
    }
    [System.ObsoleteAttribute(@"IManageMessageFailures is no longer an extension point. If you want full control over what happens when a message fails (including retries) please override the MoveFaultsToErrorQueue behavior. If you just want to get notified when messages are being moved please use BusNotifications.Errors.MessageSentToErrorQueue.Subscribe(e=>{}). Will be removed in version 7.0.0.", true)]
    public interface IManageMessageFailures { }
    public struct SecondLevelRetry
    {
        public SecondLevelRetry(System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public int RetryAttempt { get; }
    }
}
namespace NServiceBus.Features
{
    public class Audit : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class AutoSubscribe : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class BestPracticeEnforcement : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class CriticalTimeMonitoring : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class DataBus : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Encryptor : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public abstract class Feature
    {
        protected Feature() { }
        public bool IsActive { get; }
        public bool IsEnabledByDefault { get; }
        public string Name { get; }
        public string Version { get; }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> settings) { }
        protected void DependsOn<T>()
            where T : NServiceBus.Features.Feature { }
        protected void DependsOn(string featureName) { }
        protected void DependsOnAtLeastOne(params System.Type[] features) { }
        protected void DependsOnAtLeastOne(params string[] featureNames) { }
        protected void DependsOnOptionally(string featureName) { }
        protected void DependsOnOptionally(System.Type featureType) { }
        protected void DependsOnOptionally<T>()
            where T : NServiceBus.Features.Feature { }
        protected void EnableByDefault() { }
        protected void Prerequisite(System.Func<NServiceBus.Features.FeatureConfigurationContext, bool> condition, string description) { }
        protected void RegisterStartupTask<T>()
            where T : NServiceBus.Features.FeatureStartupTask { }
        protected internal abstract void Setup(NServiceBus.Features.FeatureConfigurationContext context);
        public override string ToString() { }
    }
    public class FeatureConfigurationContext
    {
        public NServiceBus.ObjectBuilder.IConfigureComponents Container { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        public NServiceBus.Settings.ReadOnlySettings Settings { get; }
        public NServiceBus.Pipeline.PipelineSettings AddSatellitePipeline(string name, string qualifier, NServiceBus.Transports.TransactionSupport requiredTransactionSupport, NServiceBus.Transports.PushRuntimeSettings runtimeSettings, out string transportAddress) { }
    }
    public class FeatureDiagnosticData
    {
        public FeatureDiagnosticData() { }
        public bool Active { get; }
        public System.Collections.Generic.IList<System.Collections.Generic.List<string>> Dependencies { get; }
        public bool DependenciesAreMeet { get; set; }
        public bool EnabledByDefault { get; }
        public string Name { get; }
        public NServiceBus.Features.PrerequisiteStatus PrerequisiteStatus { get; }
        public System.Collections.Generic.IList<System.Type> StartupTasks { get; }
        public string Version { get; }
    }
    public class FeaturesReport
    {
        public System.Collections.Generic.IList<NServiceBus.Features.FeatureDiagnosticData> Features { get; }
    }
    public abstract class FeatureStartupTask
    {
        protected FeatureStartupTask() { }
        protected abstract void OnStart();
        protected virtual void OnStop() { }
    }
    public enum FeatureState
    {
        Disabled = 0,
        Enabled = 1,
        Active = 2,
        Deactivated = 3,
    }
    public class FirstLevelRetries : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class ForwardReceivedMessages : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryGatewayPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryOutboxPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySagaPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryTimeoutPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InstallationSupport : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class JsonSerialization : NServiceBus.Serialization.ConfigureSerialization
    {
        protected override System.Type GetSerializerType(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MessageDrivenSubscriptions : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MsmqSubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MsmqTransportConfigurator : NServiceBus.Transports.ConfigureTransport
    {
        protected override string ExampleConnectionStringForErrorMessage { get; }
        protected override bool RequiresConnectionString { get; }
        protected override void Configure(NServiceBus.Features.FeatureConfigurationContext context, string connectionString) { }
    }
    public class Outbox : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class PrerequisiteStatus
    {
        public bool IsSatisfied { get; }
        public System.Collections.Generic.List<string> Reasons { get; }
    }
    public class Sagas : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Scheduler : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class SecondLevelRetries : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class static SerializationFeatureHelper { }
    public class static SettingsExtentions
    {
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault<T>(this NServiceBus.Settings.SettingsHolder settings)
            where T : NServiceBus.Features.Feature { }
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault(this NServiceBus.Settings.SettingsHolder settings, System.Type featureType) { }
        public static bool IsFeatureActive(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
        public static bool IsFeatureEnabled(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
    }
    public class SLAMonitoring : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class StorageDrivenPublishing : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class TimeoutManager : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class TimeoutManagerBasedDeferral : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class XmlSerialization : NServiceBus.Serialization.ConfigureSerialization
    {
        protected override System.Type GetSerializerType(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
}
namespace NServiceBus.Gateway.Deduplication
{
    public interface IDeduplicateMessages
    {
        System.Threading.Tasks.Task<bool> DeduplicateMessage(string clientId, System.DateTime timeReceived, NServiceBus.Extensibility.ContextBag context);
    }
}
namespace NServiceBus.Hosting.Helpers
{
    public class AssemblyScanner
    {
        public AssemblyScanner() { }
        public AssemblyScanner(string baseDirectoryToScan) { }
        [System.ObsoleteAttribute("This method is no longer required since deep scanning of assemblies is done to de" +
            "tect an NServiceBus reference. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.List<System.Reflection.Assembly> MustReferenceAtLeastOneAssembly { get; }
        public bool ThrowExceptions { get; set; }
        public NServiceBus.Hosting.Helpers.AssemblyScannerResults GetScannableAssemblies() { }
    }
    public class AssemblyScannerResults
    {
        public AssemblyScannerResults() { }
        public System.Collections.Generic.List<System.Reflection.Assembly> Assemblies { get; }
        public bool ErrorsThrownDuringScanning { get; }
        public System.Collections.Generic.List<NServiceBus.Hosting.Helpers.SkippedFile> SkippedFiles { get; }
        public System.Collections.Generic.List<System.Type> Types { get; }
    }
    public class SkippedFile
    {
        public string FilePath { get; }
        public string SkipReason { get; }
    }
}
namespace NServiceBus.Hosting
{
    public class HostInformation
    {
        public HostInformation(System.Guid hostId, string displayName) { }
        public HostInformation(System.Guid hostId, string displayName, System.Collections.Generic.Dictionary<string, string> properties) { }
        public string DisplayName { get; }
        public System.Guid HostId { get; }
        public System.Collections.Generic.Dictionary<string, string> Properties { get; }
    }
}
namespace NServiceBus.InMemory.Outbox
{
    public class static InMemoryOutboxSettingsExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings TimeToKeepDeduplicationData(this NServiceBus.Outbox.OutboxSettings settings, System.TimeSpan time) { }
    }
}
namespace NServiceBus.Installation
{
    public interface INeedToInstallSomething
    {
        System.Threading.Tasks.Task InstallAsync(string identity, NServiceBus.Configure config);
    }
}
namespace NServiceBus.Logging
{
    public class DefaultFactory : NServiceBus.Logging.LoggingFactoryDefinition
    {
        public DefaultFactory() { }
        public void Directory(string directory) { }
        protected internal override NServiceBus.Logging.ILoggerFactory GetLoggingFactory() { }
        public void Level(NServiceBus.Logging.LogLevel level) { }
    }
    public interface ILog
    {
        bool IsDebugEnabled { get; }
        bool IsErrorEnabled { get; }
        bool IsFatalEnabled { get; }
        bool IsInfoEnabled { get; }
        bool IsWarnEnabled { get; }
        void Debug(string message);
        void Debug(string message, System.Exception exception);
        void DebugFormat(string format, params object[] args);
        void Error(string message);
        void Error(string message, System.Exception exception);
        void ErrorFormat(string format, params object[] args);
        void Fatal(string message);
        void Fatal(string message, System.Exception exception);
        void FatalFormat(string format, params object[] args);
        void Info(string message);
        void Info(string message, System.Exception exception);
        void InfoFormat(string format, params object[] args);
        void Warn(string message);
        void Warn(string message, System.Exception exception);
        void WarnFormat(string format, params object[] args);
    }
    public interface ILoggerFactory
    {
        NServiceBus.Logging.ILog GetLogger(System.Type type);
        NServiceBus.Logging.ILog GetLogger(string name);
    }
    public abstract class LoggingFactoryDefinition
    {
        protected LoggingFactoryDefinition() { }
        protected internal abstract NServiceBus.Logging.ILoggerFactory GetLoggingFactory();
    }
    public enum LogLevel
    {
        Debug = 0,
        Info = 1,
        Warn = 2,
        Error = 3,
        Fatal = 4,
    }
    public class static LogManager
    {
        public static NServiceBus.Logging.ILog GetLogger<T>() { }
        public static NServiceBus.Logging.ILog GetLogger(System.Type type) { }
        public static NServiceBus.Logging.ILog GetLogger(string name) { }
        public static T Use<T>()
            where T : NServiceBus.Logging.LoggingFactoryDefinition, new () { }
        public static void UseFactory(NServiceBus.Logging.ILoggerFactory loggerFactory) { }
    }
}
namespace NServiceBus.MessageInterfaces
{
    public interface IMessageMapper : NServiceBus.IMessageCreator
    {
        System.Type GetMappedTypeFor(System.Type t);
        System.Type GetMappedTypeFor(string typeName);
        void Initialize(System.Collections.Generic.IEnumerable<System.Type> types);
    }
}
namespace NServiceBus.MessageInterfaces.MessageMapper.Reflection
{
    public class MessageMapper : NServiceBus.IMessageCreator, NServiceBus.MessageInterfaces.IMessageMapper
    {
        public MessageMapper() { }
        public T CreateInstance<T>(System.Action<T> action) { }
        public T CreateInstance<T>() { }
        public object CreateInstance(System.Type t) { }
        public System.Type GetMappedTypeFor(System.Type t) { }
        public System.Type GetMappedTypeFor(string typeName) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> types) { }
    }
}
namespace NServiceBus.MessageMutator
{
    [System.ObsoleteAttribute("Just have your mutator implement both IMutateOutgoingMessages and IMutateIncoming" +
        "Messages. Will be removed in version 7.0.0.", true)]
    public interface IMessageMutator : NServiceBus.MessageMutator.IMutateIncomingMessages, NServiceBus.MessageMutator.IMutateOutgoingMessages { }
    public interface IMutateIncomingMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingMessageContext context);
    }
    public interface IMutateIncomingTransportMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingTransportMessageContext context);
    }
    public interface IMutateOutgoingMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingMessageContext context);
    }
    public interface IMutateOutgoingTransportMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingTransportMessageContext context);
    }
    [System.ObsoleteAttribute("Just have your mutator implement both IMutateIncomingTransportMessages and IMutat" +
        "eOutgoingTransportMessages. Will be removed in version 7.0.0.", true)]
    public interface IMutateTransportMessages : NServiceBus.MessageMutator.IMutateIncomingTransportMessages, NServiceBus.MessageMutator.IMutateOutgoingTransportMessages { }
    public class MutateIncomingMessageContext
    {
        public MutateIncomingMessageContext(object message, System.Collections.Generic.IDictionary<string, string> headers) { }
        public System.Collections.Generic.IDictionary<string, string> Headers { get; }
        public object Message { get; set; }
    }
    public class MutateIncomingTransportMessageContext
    {
        public MutateIncomingTransportMessageContext(byte[] body, System.Collections.Generic.IDictionary<string, string> headers) { }
        public byte[] Body { get; set; }
        public System.Collections.Generic.IDictionary<string, string> Headers { get; }
    }
    public class MutateOutgoingMessageContext
    {
        public MutateOutgoingMessageContext(object outgoingMessage, System.Collections.Generic.IDictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; set; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<, > incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
    public class MutateOutgoingTransportMessageContext
    {
        public MutateOutgoingTransportMessageContext(byte[] outgoingBody, object outgoingMessage, System.Collections.Generic.IDictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public byte[] OutgoingBody { get; set; }
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<, > incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
}
namespace NServiceBus.ObjectBuilder.Common
{
    public interface IContainer : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        NServiceBus.ObjectBuilder.Common.IContainer BuildChildContainer();
        void Configure(System.Type component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void Configure<T>(System.Func<T> component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureProperty(System.Type component, string property, object value);
        bool HasComponent(System.Type componentType);
        void RegisterSingleton(System.Type lookupType, object instance);
        void Release(object instance);
    }
}
namespace NServiceBus.ObjectBuilder
{
    public interface IBuilder : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        T Build<T>();
        System.Collections.Generic.IEnumerable<T> BuildAll<T>();
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        void BuildAndDispatch(System.Type typeToBuild, System.Action<object> action);
        NServiceBus.ObjectBuilder.IBuilder CreateChildBuilder();
        void Release(object instance);
    }
    public interface IComponentConfig
    {
        NServiceBus.ObjectBuilder.IComponentConfig ConfigureProperty(string name, object value);
    }
    public interface IComponentConfig<T>
    {
        NServiceBus.ObjectBuilder.IComponentConfig<T> ConfigureProperty(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value);
    }
    public interface IConfigureComponents
    {
        NServiceBus.ObjectBuilder.IComponentConfig ConfigureComponent(System.Type concreteComponent, NServiceBus.DependencyLifecycle dependencyLifecycle);
        NServiceBus.ObjectBuilder.IComponentConfig<T> ConfigureComponent<T>(NServiceBus.DependencyLifecycle dependencyLifecycle);
        NServiceBus.ObjectBuilder.IComponentConfig<T> ConfigureComponent<T>(System.Func<T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        NServiceBus.ObjectBuilder.IComponentConfig<T> ConfigureComponent<T>(System.Func<NServiceBus.ObjectBuilder.IBuilder, T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        NServiceBus.ObjectBuilder.IConfigureComponents ConfigureProperty<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value);
        NServiceBus.ObjectBuilder.IConfigureComponents ConfigureProperty<T>(string propertyName, object value);
        bool HasComponent<T>();
        bool HasComponent(System.Type componentType);
        NServiceBus.ObjectBuilder.IConfigureComponents RegisterSingleton(System.Type lookupType, object instance);
        NServiceBus.ObjectBuilder.IConfigureComponents RegisterSingleton<T>(T instance);
    }
}
namespace NServiceBus.Outbox
{
    public interface IOutboxStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxTransaction> BeginTransaction(NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxMessage> Get(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task SetAsDispatched(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Store(NServiceBus.Outbox.OutboxMessage message, NServiceBus.Outbox.OutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context);
    }
    public class OutboxMessage
    {
        public OutboxMessage(string messageId, System.Collections.Generic.IList<NServiceBus.Outbox.TransportOperation> operations) { }
        public string MessageId { get; }
        public System.Collections.Generic.IList<NServiceBus.Outbox.TransportOperation> TransportOperations { get; }
    }
    public class OutboxSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        [System.ObsoleteAttribute("Please use `InMemoryOutboxSettingsExtensions.TimeToKeepDeduplicationData(TimeSpan" +
            " time)` instead. Will be removed in version 7.0.0.", true)]
        public void TimeToKeepDeduplicationData(System.TimeSpan time) { }
    }
    public interface OutboxTransaction : System.IDisposable
    {
        System.Threading.Tasks.Task Commit();
    }
    public class TransportOperation
    {
        public TransportOperation(string messageId, System.Collections.Generic.Dictionary<string, string> options, byte[] body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public System.Collections.Generic.Dictionary<string, string> Options { get; }
    }
}
namespace NServiceBus.OutgoingPipeline
{
    public class OutgoingLogicalMessage
    {
        public OutgoingLogicalMessage(object message) { }
        public OutgoingLogicalMessage(System.Type messageType, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
    }
    public class OutgoingPhysicalMessageContext : NServiceBus.Pipeline.BehaviorContext
    {
        public OutgoingPhysicalMessageContext(byte[] body, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.Contexts.OutgoingLogicalMessageContext parentContext) { }
        public byte[] Body { get; set; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
    }
    public class OutgoingPublishContext : NServiceBus.Pipeline.BehaviorContext
    {
        public OutgoingPublishContext(NServiceBus.OutgoingPipeline.OutgoingLogicalMessage message, NServiceBus.PublishOptions options, NServiceBus.Pipeline.BehaviorContext parentContext) { }
        public NServiceBus.OutgoingPipeline.OutgoingLogicalMessage Message { get; }
    }
    public class OutgoingReplyContext : NServiceBus.Pipeline.BehaviorContext
    {
        public OutgoingReplyContext(NServiceBus.OutgoingPipeline.OutgoingLogicalMessage message, NServiceBus.ReplyOptions options, NServiceBus.Pipeline.BehaviorContext parentContext) { }
        public NServiceBus.OutgoingPipeline.OutgoingLogicalMessage Message { get; }
    }
    public class OutgoingSendContext : NServiceBus.Pipeline.BehaviorContext
    {
        public OutgoingSendContext(NServiceBus.OutgoingPipeline.OutgoingLogicalMessage message, NServiceBus.SendOptions options, NServiceBus.Pipeline.BehaviorContext parentContext) { }
        public NServiceBus.OutgoingPipeline.OutgoingLogicalMessage Message { get; set; }
    }
}
namespace NServiceBus.Performance.TimeToBeReceived
{
    public class DiscardIfNotReceivedBefore : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public DiscardIfNotReceivedBefore(System.TimeSpan maxTime) { }
        public System.TimeSpan MaxTime { get; }
    }
}
namespace NServiceBus.Persistence.Legacy
{
    public class MsmqPersistence : NServiceBus.Persistence.PersistenceDefinition { }
}
namespace NServiceBus.Persistence
{
    public abstract class PersistenceDefinition
    {
        protected PersistenceDefinition() { }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> action) { }
        [System.ObsoleteAttribute("Please use `HasSupportFor<T>()` instead. Will be removed in version 7.0.0.", true)]
        public bool HasSupportFor(NServiceBus.Persistence.Storage storage) { }
        public bool HasSupportFor<T>()
            where T : NServiceBus.Persistence.StorageType { }
        public bool HasSupportFor(System.Type storageType) { }
        protected void Supports<T>(System.Action<NServiceBus.Settings.SettingsHolder> action)
            where T : NServiceBus.Persistence.StorageType { }
        [System.ObsoleteAttribute("Please use `Supports<T>()` instead. Will be removed in version 7.0.0.", true)]
        protected void Supports(NServiceBus.Persistence.Storage storage, System.Action<NServiceBus.Settings.SettingsHolder> action) { }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.Persistence.StorageType` instead. Will be removed in vers" +
        "ion 7.0.0.", true)]
    public enum Storage
    {
        Timeouts = 1,
        Subscriptions = 2,
        Sagas = 3,
        GatewayDeduplication = 4,
        Outbox = 5,
    }
    public abstract class StorageType
    {
        public override string ToString() { }
        public sealed class GatewayDeduplication : NServiceBus.Persistence.StorageType { }
        public sealed class Outbox : NServiceBus.Persistence.StorageType { }
        public sealed class Sagas : NServiceBus.Persistence.StorageType { }
        public sealed class Subscriptions : NServiceBus.Persistence.StorageType { }
        public sealed class Timeouts : NServiceBus.Persistence.StorageType { }
    }
}
namespace NServiceBus.Pipeline
{
    public abstract class Behavior<TContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TContext, TContext>
        where TContext : NServiceBus.Pipeline.BehaviorContext
    {
        protected Behavior() { }
        protected NServiceBus.Unicast.Transport.PipelineInfo PipelineInfo { get; }
        public virtual System.Threading.Tasks.Task Cooldown() { }
        public void Initialize(NServiceBus.Unicast.Transport.PipelineInfo pipelineInfo) { }
        public abstract System.Threading.Tasks.Task Invoke(TContext context, System.Func<System.Threading.Tasks.Task> next);
        public System.Threading.Tasks.Task Invoke(TContext context, System.Func<TContext, System.Threading.Tasks.Task> next) { }
        public virtual System.Threading.Tasks.Task Warmup() { }
    }
    public abstract class BehaviorContext : NServiceBus.Extensibility.ContextBag
    {
        protected BehaviorContext(NServiceBus.Extensibility.ContextBag parentContext) { }
        public NServiceBus.ObjectBuilder.IBuilder Builder { get; }
    }
    public interface IBehavior
    {
        System.Threading.Tasks.Task Cooldown();
        void Initialize(NServiceBus.Unicast.Transport.PipelineInfo pipelineInfo);
        System.Threading.Tasks.Task Warmup();
    }
    [System.ObsoleteAttribute("Please use `Behavior<T>` instead. Will be removed in version 7.0.0.", true)]
    public interface IBehavior<in TContext>
        where in TContext : NServiceBus.Pipeline.BehaviorContext
    {
        void Invoke(TContext context, System.Action next);
    }
    public interface IBehavior<in TIn, out TOut> : NServiceBus.Pipeline.IBehavior
        where in TIn : NServiceBus.Pipeline.BehaviorContext
        where out TOut : NServiceBus.Pipeline.BehaviorContext
    {
        System.Threading.Tasks.Task Invoke(TIn context, System.Func<TOut, System.Threading.Tasks.Task> next);
    }
    public interface IPipelineTerminator { }
    [System.ObsoleteAttribute("You can no longer get access to the pipeline context via DI. Please use a behavio" +
        "r to get access instead. Will be removed in version 7.0.0.", true)]
    public class PipelineExecutor : System.IDisposable
    {
        public PipelineExecutor(NServiceBus.Settings.ReadOnlySettings settings, NServiceBus.ObjectBuilder.IBuilder builder, NServiceBus.BusNotifications busNotifications) { }
        public NServiceBus.Pipeline.BehaviorContext CurrentContext { get; }
        public System.Collections.Generic.IList<NServiceBus.Pipeline.RegisterStep> Incoming { get; }
        public System.Collections.Generic.IList<NServiceBus.Pipeline.RegisterStep> Outgoing { get; }
        public void Dispose() { }
        public void InvokePipeline<TContext>(System.Collections.Generic.IEnumerable<System.Type> behaviors, TContext context)
            where TContext : NServiceBus.Pipeline.BehaviorContext { }
    }
    public class PipelineNotifications : System.IDisposable
    {
        public PipelineNotifications() { }
        public System.IObservable<System.IObservable<NServiceBus.Pipeline.StepStarted>> ReceiveStarted { get; }
    }
    public class PipelineSettings
    {
        public NServiceBus.Pipeline.StepRegistrationSequence Register(string stepId, System.Type behavior, string description) { }
        public NServiceBus.Pipeline.StepRegistrationSequence Register(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type behavior, string description) { }
        public void Register<TRegisterStep>()
            where TRegisterStep : NServiceBus.Pipeline.RegisterStep, new () { }
        public void Register(NServiceBus.Pipeline.RegisterStep registration) { }
        public void Remove(string stepId) { }
        public void Remove(NServiceBus.Pipeline.WellKnownStep wellKnownStep) { }
        public void Replace(string stepId, System.Type newBehavior, string description = null) { }
        public void Replace(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type newBehavior, string description = null) { }
    }
    public abstract class PipelineTerminator<T> : NServiceBus.Pipeline.StageConnector<T, NServiceBus.Pipeline.PipelineTerminator<T>.TerminatingContext>, NServiceBus.Pipeline.IPipelineTerminator
        where T : NServiceBus.Pipeline.BehaviorContext
    {
        protected PipelineTerminator() { }
        public virtual System.Threading.Tasks.Task Invoke(T context, System.Func<NServiceBus.Pipeline.PipelineTerminator<T>.TerminatingContext, System.Threading.Tasks.Task> next) { }
        protected abstract System.Threading.Tasks.Task Terminate(T context);
        public class TerminatingContext<T> : NServiceBus.Pipeline.BehaviorContext
            where T : NServiceBus.Pipeline.BehaviorContext
        {
            public TerminatingContext(NServiceBus.Pipeline.BehaviorContext parentContext) { }
        }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{StepId}({BehaviorType.FullName}) - {Description}")]
    public abstract class RegisterStep
    {
        protected RegisterStep(string stepId, System.Type behavior, string description) { }
        public System.Type BehaviorType { get; }
        public string Description { get; }
        public string StepId { get; }
        public void InsertAfter(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertAfter(string id) { }
        public void InsertAfterIfExists(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertAfterIfExists(string id) { }
        public void InsertBefore(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertBefore(string id) { }
        public void InsertBeforeIfExists(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertBeforeIfExists(string id) { }
        public virtual bool IsEnabled(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public abstract class StageConnector<TFrom, TTo> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFrom, TTo>, NServiceBus.Pipeline.IStageConnector
        where TFrom : NServiceBus.Pipeline.BehaviorContext
        where TTo : NServiceBus.Pipeline.BehaviorContext
    {
        protected StageConnector() { }
        protected NServiceBus.Unicast.Transport.PipelineInfo PipelineInfo { get; }
        public virtual System.Threading.Tasks.Task Cooldown() { }
        public void Initialize(NServiceBus.Unicast.Transport.PipelineInfo pipelineInfo) { }
        public abstract System.Threading.Tasks.Task Invoke(TFrom context, System.Func<TTo, System.Threading.Tasks.Task> next);
        public virtual System.Threading.Tasks.Task Warmup() { }
    }
    public struct StepEnded
    {
        public StepEnded(System.TimeSpan duration) { }
        public System.TimeSpan Duration { get; }
    }
    public class StepRegistrationSequence
    {
        public NServiceBus.Pipeline.StepRegistrationSequence Register(string stepId, System.Type behavior, string description) { }
        public NServiceBus.Pipeline.StepRegistrationSequence Register(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type behavior, string description) { }
    }
    public struct StepStarted
    {
        public StepStarted(string stepId, System.Type behavior, System.IObservable<NServiceBus.Pipeline.StepEnded> stepEnded) { }
        public System.Type Behavior { get; }
        public System.IObservable<NServiceBus.Pipeline.StepEnded> Ended { get; }
        public string StepId { get; }
    }
    public class static TransportMessageContextExtensions
    {
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.OutgoingPipeline.OutgoingReplyContext context, out NServiceBus.Transports.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.Contexts.OutgoingLogicalMessageContext context, out NServiceBus.Transports.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.OutgoingPipeline.OutgoingPhysicalMessageContext context, out NServiceBus.Transports.IncomingMessage message) { }
    }
    public class WellKnownStep
    {
        public static readonly NServiceBus.Pipeline.WellKnownStep AuditProcessedMessage;
        [System.ObsoleteAttribute("The child container creation is now an integral part of the pipeline invocation a" +
            "nd no longer a separate behavior. Will be removed in version 7.0.0.", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep CreateChildContainer;
        [System.ObsoleteAttribute("The dispatch step is the terminating step in v6 so any dependency on it can safel" +
            "y be removed. Will be removed in version 7.0.0.", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep DispatchMessageToTransport;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforcePublishBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceReplyBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceSendBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceSubscribeBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceUnsubscribeBestPractices;
        public static readonly NServiceBus.Pipeline.WellKnownStep ExecuteUnitOfWork;
        public static NServiceBus.Pipeline.WellKnownStep HostInformation;
        public static readonly NServiceBus.Pipeline.WellKnownStep InvokeHandlers;
        public static readonly NServiceBus.Pipeline.WellKnownStep InvokeSaga;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateIncomingMessages;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateIncomingTransportMessage;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateOutgoingMessages;
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateOutgoingTransportMessage;
        public static NServiceBus.Pipeline.WellKnownStep ProcessingStatistics;
    }
}
namespace NServiceBus.Pipeline.Contexts
{
    public abstract class IncomingContext : NServiceBus.Pipeline.BehaviorContext
    {
        protected IncomingContext(NServiceBus.Pipeline.BehaviorContext parentContext) { }
    }
    public class InvokeHandlerContext : NServiceBus.Pipeline.Contexts.IncomingContext
    {
        public InvokeHandlerContext(NServiceBus.Unicast.Behaviors.MessageHandler handler, NServiceBus.Pipeline.Contexts.LogicalMessageProcessingContext parentContext) { }
        public bool HandlerInvocationAborted { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public object MessageBeingHandled { get; }
        public NServiceBus.Unicast.Behaviors.MessageHandler MessageHandler { get; }
        public string MessageId { get; }
        public NServiceBus.Unicast.Messages.MessageMetadata MessageMetadata { get; }
        public void DoNotInvokeAnyMoreHandlers() { }
    }
    public class LogicalMessageProcessingContext : NServiceBus.Pipeline.Contexts.IncomingContext
    {
        public LogicalMessageProcessingContext(NServiceBus.Unicast.Messages.LogicalMessage logicalMessage, System.Collections.Generic.Dictionary<string, string> headers, NServiceBus.Pipeline.Contexts.IncomingContext parentContext) { }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public NServiceBus.Unicast.Messages.LogicalMessage Message { get; }
        public bool MessageHandled { get; set; }
    }
    [System.ObsoleteAttribute("Please use `OutgoingLogicalMessage` instead. Will be removed in version 7.0.0.", true)]
    public class OutgoingContext : NServiceBus.Pipeline.BehaviorContext
    {
        public OutgoingContext(NServiceBus.Pipeline.BehaviorContext parentContext, NServiceBus.Unicast.DeliveryOptions deliveryOptions, NServiceBus.Unicast.Messages.LogicalMessage message) { }
        public NServiceBus.Unicast.DeliveryOptions DeliveryOptions { get; }
        public NServiceBus.TransportMessage IncomingMessage { get; }
        public NServiceBus.Unicast.Messages.LogicalMessage OutgoingLogicalMessage { get; }
        public NServiceBus.TransportMessage OutgoingMessage { get; }
    }
    public class OutgoingLogicalMessageContext : NServiceBus.Pipeline.BehaviorContext
    {
        public OutgoingLogicalMessageContext(NServiceBus.OutgoingPipeline.OutgoingLogicalMessage message, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Extensibility.ContextBag parentContext) { }
        public NServiceBus.OutgoingPipeline.OutgoingLogicalMessage Message { get; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; set; }
        public void UpdateMessageInstance(object newInstance) { }
    }
    public class TransportReceiveContext : NServiceBus.Pipeline.Contexts.IncomingContext
    {
        public NServiceBus.Transports.IncomingMessage Message { get; }
    }
}
namespace NServiceBus.Routing
{
    public abstract class AddressTag
    {
        protected AddressTag() { }
    }
    public class AllInstancesDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public AllInstancesDistributionStrategy() { }
        public override System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstanceName> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstanceName> allInstances) { }
    }
    public sealed class DirectRoutingImmediateDestination
    {
        public DirectRoutingImmediateDestination(NServiceBus.EndpointInstanceName instanceName) { }
        public DirectRoutingImmediateDestination(string physicalAddress) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
    }
    public class DistributionPolicy
    {
        public DistributionPolicy() { }
        public void SetDistributionStrategy(NServiceBus.Routing.DistributionStrategy distributionStrategy, System.Func<System.Type, bool> typeMatchingRule) { }
    }
    public abstract class DistributionStrategy
    {
        protected DistributionStrategy() { }
        public abstract System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstanceName> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstanceName> allInstances);
    }
    public class EndpointInstanceData
    {
        public EndpointInstanceData(NServiceBus.EndpointInstanceName name) { }
        public System.Collections.Generic.Dictionary<string, object> ExtensionData { get; }
        public NServiceBus.EndpointInstanceName Name { get; }
    }
    public class EndpointInstances
    {
        public EndpointInstances() { }
        public void AddDynamic(System.Func<NServiceBus.EndpointName, System.Collections.Generic.IEnumerable<NServiceBus.Routing.EndpointInstanceData>> dynamicRule) { }
        public void AddDynamic(System.Func<NServiceBus.EndpointName, System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstanceName>> dynamicRule) { }
        public void AddStatic(NServiceBus.EndpointName endpoint, params NServiceBus.Routing.EndpointInstanceData[] instances) { }
        public void AddStatic(NServiceBus.EndpointName endpoint, params NServiceBus.EndpointInstanceName[] instances) { }
        public void AddStaticUsingTransportDiscriminators(NServiceBus.EndpointName endpoint, params string[] transportDiscriminators) { }
    }
    public class Itinerary
    {
        public Itinerary(string ultimateDestination, params string[] sendVia) { }
        public bool IsEmpty { get; }
        public NServiceBus.Routing.Itinerary Advance(out string immediateDestination) { }
        public static NServiceBus.Routing.Itinerary Empty() { }
        public static NServiceBus.Routing.Itinerary ExtractFrom(System.Collections.Generic.IDictionary<string, string> headers) { }
        public void Store(System.Collections.Generic.IDictionary<string, string> headers) { }
    }
    public class MulticastAddressTag : NServiceBus.Routing.AddressTag
    {
        public MulticastAddressTag(System.Type messageType) { }
        public System.Type MessageType { get; }
    }
    public class MulticastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public MulticastRoutingStrategy(System.Type messageType) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public abstract class RoutingStrategy
    {
        protected RoutingStrategy() { }
        public abstract NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers);
    }
    public class SingleInstanceRoundRobinDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public SingleInstanceRoundRobinDistributionStrategy() { }
        [System.Runtime.CompilerServices.IteratorStateMachineAttribute(typeof(NServiceBus.Routing.SingleInstanceRoundRobinDistributionStrategy.<SelectDestination>d__3))]
        public override System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstanceName> SelectDestination(System.Collections.Generic.IEnumerable<NServiceBus.EndpointInstanceName> currentAllInstances) { }
    }
    public class SubscribeContext : NServiceBus.Pipeline.BehaviorContext
    {
        public SubscribeContext(NServiceBus.Pipeline.BehaviorContext parentContext, System.Type eventType, NServiceBus.SubscribeOptions options) { }
        public System.Type EventType { get; }
    }
    public class UnicastAddressTag : NServiceBus.Routing.AddressTag
    {
        public UnicastAddressTag(string destination) { }
        public string Destination { get; }
    }
    public sealed class UnicastRoutingDestination
    {
        public UnicastRoutingDestination(NServiceBus.EndpointName endpointName) { }
        public UnicastRoutingDestination(NServiceBus.EndpointInstanceName instanceName) { }
        public UnicastRoutingDestination(string physicalAddress) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
    }
    public sealed class UnicastRoutingRoute
    {
        public UnicastRoutingRoute(NServiceBus.Routing.UnicastRoutingDestination ultimateDestination, NServiceBus.Routing.DirectRoutingImmediateDestination immediateDestination = null) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
    }
    public class UnicastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public UnicastRoutingStrategy(string ultimateDestination, params string[] route) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
        public NServiceBus.Routing.UnicastRoutingStrategy SendVia(string next) { }
    }
    public class UnicastRoutingTable
    {
        public UnicastRoutingTable() { }
        public void AddDynamic(System.Func<System.Type, NServiceBus.Extensibility.ContextBag, System.Collections.Generic.IEnumerable<NServiceBus.Routing.UnicastRoutingRoute>> dynamicRule) { }
        public void AddDynamic(System.Func<System.Type, NServiceBus.Extensibility.ContextBag, System.Collections.Generic.IEnumerable<NServiceBus.Routing.UnicastRoutingDestination>> dynamicRule) { }
        public void AddStatic(System.Type messageType, NServiceBus.Routing.UnicastRoutingRoute route) { }
        public void AddStatic(System.Type messageType, NServiceBus.EndpointName destination) { }
        public void AddStatic(System.Type messageType, NServiceBus.EndpointName destination, NServiceBus.EndpointInstanceName sendVia) { }
        public void AddStatic(System.Type messageType, NServiceBus.EndpointName destination, string sendVia) { }
        public void AddStatic(System.Type messageType, NServiceBus.EndpointInstanceName destination) { }
        public void AddStatic(System.Type messageType, string destinationAddress) { }
        public void AddStatic(System.Type messageType, string destinationAddress, string sendVia) { }
    }
    public class UnsubscribeContext : NServiceBus.Pipeline.BehaviorContext
    {
        public UnsubscribeContext(NServiceBus.Pipeline.BehaviorContext parentContext, System.Type eventType, NServiceBus.UnsubscribeOptions options) { }
        public System.Type EventType { get; }
    }
}
namespace NServiceBus.Routing.MessageDrivenSubscriptions
{
    public class PublisherAddress
    {
        public PublisherAddress(NServiceBus.EndpointName endpoint) { }
        public PublisherAddress(params NServiceBus.EndpointInstanceName[] instances) { }
        public PublisherAddress(params string[] addresses) { }
    }
    public class Publishers
    {
        public Publishers() { }
        public void AddDynamic(System.Func<System.Type, NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress> dynamicRule, string description = null) { }
        public void AddStatic(NServiceBus.EndpointName publisher, System.Type eventType) { }
        public void AddStatic(string publisherAddress, System.Type eventType) { }
        public void AddStatic(NServiceBus.EndpointName publisher, System.Reflection.Assembly eventAssembly, string eventNamespace = null) { }
    }
}
namespace NServiceBus.Routing.StorageDrivenPublishing
{
    [System.ObsoleteAttribute("No longer an extension point, if you want to list events without subscribers you " +
        "can take a dependency on ISubscriptionStorage and query it for the event types y" +
        "ou want to check. Will be removed in version 7.0.0.", true)]
    public class SubscribersForEvent
    {
        public SubscribersForEvent(System.Collections.Generic.List<string> subscribers, System.Type eventType) { }
        public System.Type EventType { get; }
        public System.Collections.Generic.IEnumerable<string> Subscribers { get; }
    }
}
namespace NServiceBus.Sagas
{
    public class ActiveSagaInstance
    {
        [System.ObsoleteAttribute("Please use `context.MessageHandler.Instance` instead. Will be removed in version " +
            "7.0.0.", true)]
        public NServiceBus.Saga Instance { get; }
        public bool IsNew { get; }
        public bool NotFound { get; }
        public string SagaId { get; }
        [System.ObsoleteAttribute("Please use `.Metadata.SagaType` instead. Will be removed in version 7.0.0.", true)]
        public System.Type SagaType { get; }
        public void AttachNewEntity(NServiceBus.IContainSagaData sagaEntity) { }
    }
    public class CorrelationProperty
    {
        public CorrelationProperty(string name) { }
        public string Name { get; }
    }
    public interface IFinder { }
    public abstract class IFindSagas<T>
        where T : NServiceBus.IContainSagaData
    {
        protected IFindSagas() { }
        public interface Using<T, M> : NServiceBus.Sagas.IFinder
            where T : NServiceBus.IContainSagaData
        {
            System.Threading.Tasks.Task<T> FindBy(M message, NServiceBus.Extensibility.ReadOnlyContextBag context);
        }
    }
    public interface IHandleSagaNotFound
    {
        System.Threading.Tasks.Task Handle(object message);
    }
    public interface ISagaPersister
    {
        System.Threading.Tasks.Task Complete(NServiceBus.IContainSagaData saga, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(System.Guid sagaId, NServiceBus.Extensibility.ContextBag context)
            where TSagaData : NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(string propertyName, object propertyValue, NServiceBus.Extensibility.ContextBag context)
            where TSagaData : NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task Save(NServiceBus.IContainSagaData sagaInstance, System.Collections.Generic.IDictionary<string, object> correlationProperties, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Update(NServiceBus.IContainSagaData saga, NServiceBus.Extensibility.ContextBag context);
    }
    public class SagaFinderDefinition
    {
        public SagaFinderDefinition(System.Type type, string messageType, System.Collections.Generic.Dictionary<string, object> properties) { }
        public string MessageType { get; }
        public System.Collections.Generic.Dictionary<string, object> Properties { get; }
        public System.Type Type { get; }
    }
    public class SagaMessage
    {
        public SagaMessage(string messageType, bool isAllowedToStart) { }
        public bool IsAllowedToStartSaga { get; }
        public string MessageType { get; }
    }
    public class SagaMetadata
    {
        public SagaMetadata(string name, System.Type sagaType, string entityName, System.Type sagaEntityType, System.Collections.Generic.List<NServiceBus.Sagas.CorrelationProperty> correlationProperties, System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMessage> messages, System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaFinderDefinition> finders) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMessage> AssociatedMessages { get; }
        public System.Collections.Generic.List<NServiceBus.Sagas.CorrelationProperty> CorrelationProperties { get; }
        public string EntityName { get; }
        public System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaFinderDefinition> Finders { get; }
        public string Name { get; }
        public System.Type SagaEntityType { get; }
        public System.Type SagaType { get; }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType) { }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType, System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
        public bool IsMessageAllowedToStartTheSaga(string messageType) { }
        public bool TryGetFinder(string messageType, out NServiceBus.Sagas.SagaFinderDefinition finderDefinition) { }
    }
    public class SagaMetadataCollection : System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMetadata>, System.Collections.IEnumerable
    {
        public SagaMetadataCollection() { }
        public NServiceBus.Sagas.SagaMetadata Find(System.Type sagaType) { }
        public NServiceBus.Sagas.SagaMetadata FindByEntity(System.Type entityType) { }
        public System.Collections.Generic.IEnumerator<NServiceBus.Sagas.SagaMetadata> GetEnumerator() { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
    }
    [System.ObsoleteAttribute("There is no need for this attribute anymore, all mapped properties are automatica" +
        "lly correlated. Will be removed in version 7.0.0.", true)]
    public sealed class UniqueAttribute : System.Attribute
    {
        public UniqueAttribute() { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Collections.Generic.IDictionary<string, object> GetUniqueProperties(NServiceBus.IContainSagaData entity) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> GetUniqueProperties(System.Type type) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Reflection.PropertyInfo GetUniqueProperty(System.Type type) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. Will be removed in version 7.0.0.", true)]
        public static System.Nullable<System.Collections.Generic.KeyValuePair<string, object>> GetUniqueProperty(NServiceBus.IContainSagaData entity) { }
    }
}
namespace NServiceBus.Satellites
{
    [System.ObsoleteAttribute(@"ISatellite is no longer an extension point. In order to create a satellite one must create a feature that uses AddSatellitePipeline() method and a class that inherits from SatelliteBehavior that is used for processing the messages. Will be removed in version 7.0.0.", true)]
    public interface IAdvancedSatellite { }
    [System.ObsoleteAttribute(@"ISatellite is no longer an extension point. In order to create a satellite one must create a feature that uses AddSatellitePipeline() method and a class that inherits from SatelliteBehavior that is used for processing the messages. Will be removed in version 7.0.0.", true)]
    public interface ISatellite { }
}
namespace NServiceBus.SecondLevelRetries.Config
{
    public class SecondLevelRetriesSettings
    {
        [System.ObsoleteAttribute("Please use `CustomRetryPolicy(Func<IncomingMessage, TimeSpan> customPolicy)` inst" +
            "ead. Will be removed in version 7.0.0.", true)]
        public void CustomRetryPolicy(System.Func<NServiceBus.TransportMessage, System.TimeSpan> customPolicy) { }
        public void CustomRetryPolicy(System.Func<NServiceBus.Transports.IncomingMessage, System.TimeSpan> customPolicy) { }
    }
}
namespace NServiceBus.Serialization
{
    public abstract class ConfigureSerialization : NServiceBus.Features.Feature
    {
        protected ConfigureSerialization() { }
        protected abstract System.Type GetSerializerType(NServiceBus.Features.FeatureConfigurationContext context);
        protected virtual void RegisterSerializer(NServiceBus.Features.FeatureConfigurationContext context, System.Type serializerType) { }
        protected internal void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public interface IMessageSerializer
    {
        string ContentType { get; }
        object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypes = null);
        void Serialize(object message, System.IO.Stream stream);
    }
    public abstract class SerializationDefinition
    {
        protected SerializationDefinition() { }
        protected internal abstract System.Type ProvidedByFeature();
    }
    public class SerializationExtentions<T> : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
        where T : NServiceBus.Serialization.SerializationDefinition
    {
        public SerializationExtentions(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.Serializers.Json
{
    public class JsonMessageSerializer : NServiceBus.Serialization.IMessageSerializer
    {
        public JsonMessageSerializer(NServiceBus.MessageInterfaces.IMessageMapper messageMapper) { }
        public string ContentType { get; }
        public System.Text.Encoding Encoding { get; set; }
        public object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypes) { }
        public object DeserializeObject(string value, System.Type type) { }
        public void Serialize(object message, System.IO.Stream stream) { }
        public string SerializeObject(object value) { }
    }
}
namespace NServiceBus.Serializers.XML
{
    public class XmlMessageSerializer : NServiceBus.Serialization.IMessageSerializer
    {
        public XmlMessageSerializer(NServiceBus.MessageInterfaces.IMessageMapper mapper, NServiceBus.Conventions conventions) { }
        public string ContentType { get; }
        public string Namespace { get; set; }
        public bool SanitizeInput { get; set; }
        public bool SkipWrappingRawXml { get; set; }
        public object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypesToDeserialize = null) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public void InitType(System.Type t) { }
        public void Serialize(object message, System.IO.Stream stream) { }
    }
}
namespace NServiceBus.Settings
{
    public interface ReadOnlySettings
    {
        void ApplyTo<T>(NServiceBus.ObjectBuilder.IComponentConfig config);
        void ApplyTo(System.Type componentType, NServiceBus.ObjectBuilder.IComponentConfig config);
        T Get<T>();
        T Get<T>(string key);
        object Get(string key);
        T GetOrDefault<T>(string key);
        bool HasExplicitValue(string key);
        bool HasExplicitValue<T>();
        bool HasSetting(string key);
        bool HasSetting<T>();
        bool TryGet<T>(out T val);
        bool TryGet<T>(string key, out T val);
    }
    public class ScaleOutSettings
    {
        public void UniqueQueuePerEndpointInstance() { }
        public void UniqueQueuePerEndpointInstance(string discriminator) { }
        [System.ObsoleteAttribute("This is the default starting with V6. Will be removed in version 7.0.0.", true)]
        public void UseSingleBrokerQueue() { }
        [System.ObsoleteAttribute("Please use `UniqueQueuePerEndpointInstance` instead. Will be removed in version 7" +
            ".0.0.", true)]
        public void UseUniqueBrokerQueuePerMachine() { }
    }
    public class SettingsHolder : NServiceBus.Settings.ReadOnlySettings
    {
        public SettingsHolder() { }
        public void ApplyTo<T>(NServiceBus.ObjectBuilder.IComponentConfig config) { }
        public void ApplyTo(System.Type componentType, NServiceBus.ObjectBuilder.IComponentConfig config) { }
        public T Get<T>(string key) { }
        public T Get<T>() { }
        public object Get(string key) { }
        public T GetOrDefault<T>() { }
        public T GetOrDefault<T>(string key) { }
        public bool HasExplicitValue(string key) { }
        public bool HasExplicitValue<T>() { }
        public bool HasSetting(string key) { }
        public bool HasSetting<T>() { }
        public void Set(string key, object value) { }
        public void Set<T>(object value) { }
        public void Set<T>(System.Action value) { }
        public void SetDefault<T>(object value) { }
        public void SetDefault<T>(System.Action value) { }
        public void SetDefault(string key, object value) { }
        public void SetProperty<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        public void SetPropertyDefault<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        public bool TryGet<T>(out T val) { }
        public bool TryGet<T>(string key, out T val) { }
    }
    public class TransactionSettings
    {
        public NServiceBus.Settings.TransactionSettings DefaultTimeout(System.TimeSpan defaultTimeout) { }
        public NServiceBus.Settings.TransactionSettings Disable() { }
        public NServiceBus.Settings.TransactionSettings DisableDistributedTransactions() { }
        public NServiceBus.Settings.TransactionSettings DoNotWrapHandlersExecutionInATransactionScope() { }
        public NServiceBus.Settings.TransactionSettings Enable() { }
        public NServiceBus.Settings.TransactionSettings EnableDistributedTransactions() { }
        public NServiceBus.Settings.TransactionSettings IsolationLevel(System.Transactions.IsolationLevel isolationLevel) { }
        public NServiceBus.Settings.TransactionSettings WrapHandlersExecutionInATransactionScope() { }
    }
}
namespace NServiceBus.Support
{
    public class static RuntimeEnvironment
    {
        public static string MachineName { get; }
        public static System.Func<string> MachineNameAction { get; set; }
    }
}
namespace NServiceBus.Timeout.Core
{
    public interface IPersistTimeouts
    {
        System.Threading.Tasks.Task Add(NServiceBus.Timeout.Core.TimeoutData timeout, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutData> Peek(string timeoutId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task RemoveTimeoutBy(System.Guid sagaId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<bool> TryRemove(string timeoutId, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IQueryTimeouts
    {
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutsChunk> GetNextChunk(System.DateTime startSlice);
    }
    public class TimeoutData
    {
        [System.ObsoleteAttribute("Not used anymore. Will be removed in version 7.0.0.", true)]
        public const string OriginalReplyToAddress = "NServiceBus.Timeout.ReplyToAddress";
        public TimeoutData() { }
        public string Destination { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
        public string Id { get; set; }
        public string OwningTimeoutManager { get; set; }
        public System.Guid SagaId { get; set; }
        public byte[] State { get; set; }
        public System.DateTime Time { get; set; }
        [System.ObsoleteAttribute("Use new SendOptions() instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Unicast.SendOptions ToSendOptions(NServiceBus.Address replyToAddress) { }
        [System.ObsoleteAttribute("Use new SendOptions() instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Unicast.SendOptions ToSendOptions(string replyToAddress) { }
        public override string ToString() { }
        [System.ObsoleteAttribute("Use new OutgoingMessage(timeoutData.State) instead. Will be removed in version 7." +
            "0.0.", true)]
        public NServiceBus.TransportMessage ToTransportMessage() { }
    }
    public class TimeoutsChunk
    {
        public TimeoutsChunk(System.Collections.Generic.IEnumerable<NServiceBus.Timeout.Core.TimeoutsChunk.Timeout> dueTimeouts, System.DateTime nextTimeToQuery) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Timeout.Core.TimeoutsChunk.Timeout> DueTimeouts { get; }
        public System.DateTime NextTimeToQuery { get; }
        public class Timeout
        {
            public Timeout(string id, System.DateTime dueTime) { }
            public System.DateTime DueTime { get; }
            public string Id { get; }
        }
    }
}
namespace NServiceBus.TransportDispatch
{
    public class static HeaderContextExtensions
    {
        public static void SetHeader(this NServiceBus.Pipeline.Contexts.OutgoingLogicalMessageContext context, string key, string value) { }
        public static void SetHeader(this NServiceBus.OutgoingPipeline.OutgoingPublishContext context, string key, string value) { }
        public static void SetHeader(this NServiceBus.OutgoingPipeline.OutgoingSendContext context, string key, string value) { }
        public static void SetHeader(this NServiceBus.OutgoingPipeline.OutgoingReplyContext context, string key, string value) { }
        public static void SetHeader(this NServiceBus.OutgoingPipeline.OutgoingPhysicalMessageContext context, string key, string value) { }
    }
    public class RoutingContext : NServiceBus.Pipeline.BehaviorContext
    {
        public RoutingContext(NServiceBus.Transports.OutgoingMessage messageToDispatch, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.BehaviorContext context) { }
        public RoutingContext(NServiceBus.Transports.OutgoingMessage messageToDispatch, NServiceBus.Routing.RoutingStrategy addressLabel, NServiceBus.Pipeline.BehaviorContext context) { }
        public NServiceBus.Transports.OutgoingMessage Message { get; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; set; }
    }
}
namespace NServiceBus.Transports
{
    public abstract class ConfigureTransport : NServiceBus.Features.Feature
    {
        protected ConfigureTransport() { }
        protected abstract string ExampleConnectionStringForErrorMessage { get; }
        protected virtual bool RequiresConnectionString { get; }
        protected abstract void Configure(NServiceBus.Features.FeatureConfigurationContext context, string connectionString);
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public enum DispatchConsistency
    {
        Default = 1,
        Isolated = 2,
    }
    public class DispatchOptions
    {
        public DispatchOptions(NServiceBus.Routing.AddressTag addressTag, NServiceBus.Transports.DispatchConsistency requiredDispatchConsistency, System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public NServiceBus.Routing.AddressTag AddressTag { get; }
        public System.Collections.Generic.IEnumerable<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public NServiceBus.Transports.DispatchConsistency RequiredDispatchConsistency { get; set; }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public interface IAuditMessages { }
    public interface ICancelDeferredMessages
    {
        System.Threading.Tasks.Task CancelDeferredMessages(string messageKey, NServiceBus.Pipeline.BehaviorContext context);
    }
    public interface ICreateQueues
    {
        void CreateQueueIfNecessary(string address, string account);
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface IDeferMessages
    {
        [System.ObsoleteAttribute("Please use `ICancelDeferredMessages` instead. Will be removed in version 7.0.0.", true)]
        void ClearDeferredMessages(string headerKey, string headerValue);
        void Defer(NServiceBus.TransportMessage message, NServiceBus.Unicast.SendOptions sendOptions);
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.Transport.IPushMessages` instead. Will be removed in vers" +
        "ion 7.0.0.", true)]
    public interface IDequeueMessages
    {
        void Init(NServiceBus.Address address, NServiceBus.Unicast.Transport.TransactionSettings transactionSettings, System.Func<NServiceBus.TransportMessage, bool> tryProcessMessage, System.Action<NServiceBus.TransportMessage, System.Exception> endProcessMessage);
        void Start(int maximumConcurrencyLevel);
        void Stop();
    }
    public interface IDispatchMessages
    {
        System.Threading.Tasks.Task Dispatch(System.Collections.Generic.IEnumerable<NServiceBus.Transports.TransportOperation> outgoingMessages, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IManageSubscriptions
    {
        System.Threading.Tasks.Task SubscribeAsync(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task UnsubscribeAsync(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
    }
    public class static IManageSubscriptionsExtensions_obsolete
    {
        [System.ObsoleteAttribute("Please use `SubscribeAsync(Type eventType, ContextBag context)` instead. Will be " +
            "removed in version 7.0.0.", true)]
        public static void Subscribe(this NServiceBus.Transports.IManageSubscriptions manage, System.Type eventType, NServiceBus.Extensibility.ContextBag context) { }
        [System.ObsoleteAttribute("Please use `UnsubscribeAsync(Type eventType, ContextBag context)` instead. Will b" +
            "e removed in version 7.0.0.", true)]
        public static void Unsubscribe(NServiceBus.Transports.IManageSubscriptions manage, System.Type eventType, NServiceBus.Extensibility.ContextBag context) { }
    }
    public class IncomingMessage
    {
        public IncomingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.IO.Stream bodyStream) { }
        public byte[] Body { get; set; }
        public System.IO.Stream BodyStream { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static IncomingMessageExtensions
    {
        public static NServiceBus.MessageIntentEnum GetMesssageIntent(this NServiceBus.Transports.IncomingMessage message) { }
        public static string GetReplyToAddress(this NServiceBus.Transports.IncomingMessage message) { }
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface IPublishMessages
    {
        void Publish(NServiceBus.TransportMessage message, NServiceBus.Unicast.PublishOptions publishOptions);
    }
    public interface IPushMessages
    {
        void Init(System.Func<NServiceBus.Transports.PushContext, System.Threading.Tasks.Task> pipe, NServiceBus.Transports.PushSettings settings);
        void Start(NServiceBus.Transports.PushRuntimeSettings limitations);
        System.Threading.Tasks.Task Stop();
    }
    [System.ObsoleteAttribute("Please use `IDispatchMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface ISendMessages
    {
        void Send(NServiceBus.TransportMessage message, NServiceBus.Unicast.SendOptions sendOptions);
    }
    public class MessageAvailable
    {
        public MessageAvailable(System.Action<NServiceBus.Pipeline.Contexts.IncomingContext> contextAction) { }
    }
    public class OutboundRoutingPolicy
    {
        public OutboundRoutingPolicy(NServiceBus.Transports.OutboundRoutingType sends, NServiceBus.Transports.OutboundRoutingType publishes, NServiceBus.Transports.OutboundRoutingType replies) { }
        public NServiceBus.Transports.OutboundRoutingType Publishes { get; }
        public NServiceBus.Transports.OutboundRoutingType Replies { get; }
        public NServiceBus.Transports.OutboundRoutingType Sends { get; }
    }
    public enum OutboundRoutingType
    {
        DirectSend = 0,
        IndirectPublish = 1,
    }
    public class OutgoingMessage
    {
        public OutgoingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class PushContext
    {
        public PushContext(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.IO.Stream bodyStream, NServiceBus.Extensibility.ContextBag context) { }
        public System.IO.Stream BodyStream { get; }
        public NServiceBus.Extensibility.ContextBag Context { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class PushRuntimeSettings
    {
        public PushRuntimeSettings(int maxConcurrency = 100) { }
        public static NServiceBus.Transports.PushRuntimeSettings Default { get; }
        public int MaxConcurrency { get; }
    }
    public class PushSettings
    {
        public PushSettings(string inputQueue, string errorQueue, bool purgeOnStartup, NServiceBus.Transports.TransactionSupport requiredTransactionSupport) { }
        public string ErrorQueue { get; }
        public string InputQueue { get; }
        public bool PurgeOnStartup { get; }
        public NServiceBus.Transports.TransactionSupport RequiredTransactionSupport { get; }
    }
    public class QueueBindings
    {
        public QueueBindings() { }
        public System.Collections.Generic.IEnumerable<string> ReceivingAddresses { get; }
        public System.Collections.Generic.IEnumerable<string> SendingAddresses { get; }
        public void BindReceiving(string address) { }
        public void BindSending(string transportAddress) { }
    }
    public enum TransactionSupport
    {
        None = 0,
        SingleQueue = 1,
        MultiQueue = 2,
        Distributed = 3,
    }
    public class TransportAddresses
    {
        public TransportAddresses() { }
        public void AddException(NServiceBus.EndpointInstanceName endpointInstance, string physicalAddress) { }
        public void AddRule(System.Func<NServiceBus.EndpointInstanceName, string> dynamicRule) { }
    }
    public abstract class TransportDefinition
    {
        protected TransportDefinition() { }
        public bool HasNativePubSubSupport { get; set; }
        public bool HasSupportForCentralizedPubSub { get; set; }
        [System.ObsoleteAttribute("GetTransactionSupport. Will be removed in version 7.0.0.", true)]
        public System.Nullable<bool> HasSupportForDistributedTransactions { get; set; }
        [System.ObsoleteAttribute("Please use `GetTransactionSupport` instead. Will be removed in version 7.0.0.", true)]
        public bool HasSupportForMultiQueueNativeTransactions { get; set; }
        public bool RequireOutboxConsent { get; set; }
        protected internal void Configure(NServiceBus.BusConfiguration config) { }
        public abstract string GetDiscriminatorForThisEndpointInstance();
        public abstract NServiceBus.Transports.OutboundRoutingPolicy GetOutboundRoutingPolicy(NServiceBus.Settings.ReadOnlySettings settings);
        public abstract NServiceBus.Transports.IManageSubscriptions GetSubscriptionManager();
        public abstract System.Collections.Generic.IEnumerable<System.Type> GetSupportedDeliveryConstraints();
        public abstract NServiceBus.Transports.TransactionSupport GetTransactionSupport();
        public abstract string ToTransportAddress(NServiceBus.LogicalAddress logicalAddress);
    }
    public class TransportOperation
    {
        public TransportOperation(NServiceBus.Transports.OutgoingMessage message, NServiceBus.Transports.DispatchOptions dispatchOptions) { }
        public NServiceBus.Transports.DispatchOptions DispatchOptions { get; }
        public NServiceBus.Transports.OutgoingMessage Message { get; }
    }
}
namespace NServiceBus.Transports.Msmq.Config
{
    public class MsmqSettings
    {
        public MsmqSettings() { }
        public System.TimeSpan TimeToReachQueue { get; set; }
        public bool UseConnectionCache { get; set; }
        public bool UseDeadLetterQueue { get; set; }
        public bool UseJournalQueue { get; set; }
        public bool UseTransactionalQueues { get; set; }
    }
}
namespace NServiceBus.Transports.Msmq
{
    public class HeaderInfo
    {
        public HeaderInfo() { }
        public string Key { get; set; }
        public string Value { get; set; }
    }
    [System.ObsoleteAttribute("No longer available, resolve an instance of IPushMessages from the container inst" +
        "ead. Will be removed in version 7.0.0.", true)]
    public class MsmqDequeueStrategy : NServiceBus.Transports.IDequeueMessages, System.IDisposable
    {
        public MsmqDequeueStrategy(NServiceBus.Configure configure, NServiceBus.CriticalError criticalError, NServiceBus.Transports.Msmq.MsmqUnitOfWork unitOfWork) { }
        public NServiceBus.Address ErrorQueue { get; set; }
        public void Dispose() { }
        public void Init(NServiceBus.Address address, NServiceBus.Unicast.Transport.TransactionSettings settings, System.Func<NServiceBus.TransportMessage, bool> tryProcessMessage, System.Action<NServiceBus.TransportMessage, System.Exception> endProcessMessage) { }
        public void Start(int maximumConcurrencyLevel) { }
        public void Stop() { }
    }
    public class MsmqMessageSender : NServiceBus.Transports.IDispatchMessages
    {
        public MsmqMessageSender(NServiceBus.Transports.Msmq.Config.MsmqSettings settings, NServiceBus.MsmqLabelGenerator messageLabelGenerator) { }
        public System.Threading.Tasks.Task Dispatch(System.Collections.Generic.IEnumerable<NServiceBus.Transports.TransportOperation> transportOperations, NServiceBus.Extensibility.ContextBag context) { }
    }
    [System.ObsoleteAttribute("The msmq transaction is now available via the pipeline context. Will be removed i" +
        "n version 7.0.0.", true)]
    public class MsmqUnitOfWork : System.IDisposable
    {
        public MsmqUnitOfWork() { }
        public System.Messaging.MessageQueueTransaction Transaction { get; }
        public void Dispose() { }
        public bool HasActiveTransaction() { }
    }
}
namespace NServiceBus.Unicast.Behaviors
{
    public class MessageHandler
    {
        [System.ObsoleteAttribute("Please use `MessageHandler(Action<object, object, object> invocation, Type handle" +
            "rType)` instead. Will be removed in version 7.0.0.", true)]
        public MessageHandler() { }
        public System.Type HandlerType { get; }
        public object Instance { get; set; }
        [System.ObsoleteAttribute("Please use `MessageHandler.Invoke` instead. Will be removed in version 7.0.0.", true)]
        public System.Action<object, object> Invocation { get; set; }
        public System.Threading.Tasks.Task Invoke(object message) { }
    }
}
namespace NServiceBus.Unicast
{
    public class static BuilderExtensions
    {
        public static void ForEach<T>(this NServiceBus.ObjectBuilder.IBuilder builder, System.Action<T> action) { }
    }
    [System.ObsoleteAttribute("No longer used, please use the new callbacks api described in the v6 upgrade guid" +
        "e. Will be removed in version 7.0.0.", true)]
    public class BusAsyncResult : System.IAsyncResult
    {
        public BusAsyncResult(System.AsyncCallback callback, object state) { }
        public object AsyncState { get; }
        public System.Threading.WaitHandle AsyncWaitHandle { get; }
        public bool CompletedSynchronously { get; }
        public bool IsCompleted { get; }
        public void Complete(int errorCode, params object[] messages) { }
    }
    public class DeliveryMessageOptions
    {
        public DeliveryMessageOptions() { }
        [System.ObsoleteAttribute("Use the ConsistencyGuarantee class instead. Will be removed in version 7.0.0.", true)]
        public bool EnlistInReceiveTransaction { get; set; }
        [System.ObsoleteAttribute("Use context.TryGetDeliveryConstraint<NonDurableDelivery> instead. Will be removed" +
            " in version 7.0.0.", true)]
        public System.Nullable<bool> NonDurable { get; set; }
        [System.ObsoleteAttribute("Use context.TryGetDeliveryConstraint<DiscardIfNotReceivedBefore> instead. Will be" +
            " removed in version 7.0.0.", true)]
        public System.Nullable<System.TimeSpan> TimeToBeReceived { get; set; }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.UnicastBus.DeliveryMessageOptions` instead. Will be remov" +
        "ed in version 7.0.0.", true)]
    public abstract class DeliveryOptions
    {
        protected DeliveryOptions() { }
        [System.ObsoleteAttribute("Turn best practices check off using configuration.DisableFeature<BestPracticeEnfo" +
            "rcement>(). Will be removed in version 7.0.0.", true)]
        public bool EnforceMessagingBestPractices { get; set; }
        [System.ObsoleteAttribute("Reply to address can be get/set using the `NServiceBus.ReplyToAddress` header. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public string ReplyToAddress { get; set; }
    }
    [System.ObsoleteAttribute("Not a public API. Please use `MessageHandlerRegistry` instead. Will be removed in" +
        " version 7.0.0.", true)]
    public interface IMessageHandlerRegistry { }
    public class MessageContext : NServiceBus.IMessageContext
    {
        [System.ObsoleteAttribute("Please use `MessageContext(IncomingMessage incomingMessage)` instead. Will be rem" +
            "oved in version 7.0.0.", true)]
        public MessageContext(NServiceBus.TransportMessage incomingMessage) { }
        public MessageContext(NServiceBus.Transports.IncomingMessage incomingMessage) { }
        public System.DateTime TimeSent { get; }
    }
    public class MessageEventArgs : System.EventArgs
    {
        public MessageEventArgs(object msg) { }
        public object Message { get; }
    }
    public class MessageHandlerRegistry
    {
        [System.ObsoleteAttribute("Please use `MessageHandlerRegistry.RegisterHandler(Type handlerType)` instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public void CacheMethodForHandler(System.Type handler, System.Type messageType) { }
        public void Clear() { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Behaviors.MessageHandler> GetHandlersFor(System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `MessageHandlerRegistry.GetHandlersFor(Type messageType)` instead. Wil" +
            "l be removed in version 7.0.0.", true)]
        public System.Collections.Generic.IEnumerable<System.Type> GetHandlerTypes(System.Type messageType) { }
        public System.Collections.Generic.IEnumerable<System.Type> GetMessageTypes() { }
        [System.ObsoleteAttribute("Please use `MessageHandler.Invoke(object message, object context)` instead. Will " +
            "be removed in version 7.0.0.", true)]
        public void InvokeHandle(object handler, object message) { }
        [System.ObsoleteAttribute("Please use `MessageHandler.Invoke(object message, object context)` instead. Will " +
            "be removed in version 7.0.0.", true)]
        public void InvokeTimeout(object handler, object state) { }
        public void RegisterHandler(System.Type handlerType) { }
    }
    public class MessagesEventArgs : System.EventArgs
    {
        public MessagesEventArgs(object[] messages) { }
        public object[] Messages { get; }
    }
    [System.ObsoleteAttribute("Use context.Intent to detect of the message is a event being published and use co" +
        "ntext.MessageType to get the actual event type. Will be removed in version 7.0.0" +
        ".", true)]
    public class PublishOptions : NServiceBus.Unicast.DeliveryOptions
    {
        public PublishOptions() { }
    }
    [System.ObsoleteAttribute("Not used anymore, use the \'NServiceBus.MessageIntent\' header to detect if the mes" +
        "sage is a reply. Will be removed in version 7.0.0.", true)]
    public class ReplyOptions : NServiceBus.Unicast.DeliveryOptions
    {
        public ReplyOptions() { }
    }
    [System.ObsoleteAttribute("Please use `NServiceBus.UnicastBus.SendMessageOptions` instead. Will be removed i" +
        "n version 7.0.0.", true)]
    public class SendOptions : NServiceBus.Unicast.DeliveryOptions
    {
        [System.ObsoleteAttribute("Please use `SendMessageOptions(string)` instead. Will be removed in version 7.0.0" +
            ".", true)]
        public SendOptions(NServiceBus.Address destination) { }
        [System.ObsoleteAttribute("Reply to address can be get/set using the `NServiceBus.CorrelationId` header. Wil" +
            "l be removed in version 7.0.0.", true)]
        public string CorrelationId { get; set; }
        [System.ObsoleteAttribute("Please use `DelayDeliveryFor` instead. Will be removed in version 7.0.0.", true)]
        public System.Nullable<System.TimeSpan> DelayDeliveryWith { get; set; }
    }
    [System.ObsoleteAttribute("UnicastBus has been made internal. Use either IBus or ISendOnlyBus. Will be remov" +
        "ed in version 7.0.0.", true)]
    public class UnicastBus : NServiceBus.IBus, NServiceBus.ISendOnlyBus, NServiceBus.IStartableBus, System.IDisposable
    {
        [System.ObsoleteAttribute("Builder should be accessed inside feature, the pipeline and start/stop infrastruc" +
            "ture only. Will be removed in version 7.0.0.", true)]
        public NServiceBus.ObjectBuilder.IBuilder Builder { get; }
        [System.ObsoleteAttribute("Please use `IBus.CurrentMessageContext` instead. Will be removed in version 7.0.0" +
            ".", true)]
        public NServiceBus.IMessageContext CurrentMessageContext { get; }
        [System.ObsoleteAttribute("We have introduced a more explicit API to set the host identifier, see busConfigu" +
            "ration.UniquelyIdentifyRunningInstance(). Will be removed in version 7.0.0.", true)]
        public NServiceBus.Hosting.HostInformation HostInformation { get; set; }
        [System.ObsoleteAttribute("ReadOnlySettings should be accessed inside feature, the pipeline and start/stop i" +
            "nfrastructure only. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.ReadOnlySettings Settings { get; }
        [System.ObsoleteAttribute("Please use `SendLocalAsync(object message, SendLocalOptions options)` instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public NServiceBus.ICallback Defer(System.TimeSpan delay, object message) { }
        [System.ObsoleteAttribute("Please use `SendLocalAsync(object message, SendLocalOptions options)` instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public NServiceBus.ICallback Defer(System.DateTime processAt, object message) { }
        [System.ObsoleteAttribute("Please use `IBus.Dispose()` instead. Will be removed in version 7.0.0.", true)]
        public void Dispose() { }
        [System.ObsoleteAttribute("Please use `IBus.DoNotContinueDispatchingCurrentMessageToHandlers()` instead. Wil" +
            "l be removed in version 7.0.0.", true)]
        public void DoNotContinueDispatchingCurrentMessageToHandlers() { }
        [System.ObsoleteAttribute("Please use `IBus.ForwardCurrentMessageToAsync(string destination)` instead. Will " +
            "be removed in version 7.0.0.", true)]
        public System.Threading.Tasks.Task ForwardCurrentMessageToAsync(string destination) { }
        [System.ObsoleteAttribute("Please use `IBus.HandleCurrentMessageLaterAsync()` instead. Will be removed in ve" +
            "rsion 7.0.0.", true)]
        public System.Threading.Tasks.Task HandleCurrentMessageLaterAsync() { }
        [System.ObsoleteAttribute("Please use `ISendOnlyBus.PublishAsync(object message, PublishOptions options)` in" +
            "stead. Will be removed in version 7.0.0.", true)]
        public System.Threading.Tasks.Task PublishAsync(object message, NServiceBus.PublishOptions options) { }
        [System.ObsoleteAttribute("Please use `ISendOnlyBus.PublishAsync<T>(Action<T> messageConstructor, PublishOpt" +
            "ions options)` instead. Will be removed in version 7.0.0.", true)]
        public System.Threading.Tasks.Task PublishAsync<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions) { }
        [System.ObsoleteAttribute("Please use `IBus.ReplyAsync<T>(object message, ReplyOptions options)` instead. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public System.Threading.Tasks.Task ReplyAsync(object message, NServiceBus.ReplyOptions options) { }
        [System.ObsoleteAttribute("Please use `IBus.ReplyAsync<T>(Action<T> messageConstructor, ReplyOptions options" +
            ")` instead. Will be removed in version 7.0.0.", true)]
        public System.Threading.Tasks.Task ReplyAsync<T>(System.Action<T> messageConstructor, NServiceBus.ReplyOptions options) { }
        [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
        public void Return<T>(T errorEnum) { }
        [System.ObsoleteAttribute("Please use `ISendOnlyBus.SendAsync(object message, SendOptions options)` instead." +
            " Will be removed in version 7.0.0.", true)]
        public System.Threading.Tasks.Task SendAsync(object message, NServiceBus.SendOptions options) { }
        [System.ObsoleteAttribute("Please use `ISendOnlyBus.SendAsync<T>(Action<T> messageConstructor, SendOptions o" +
            "ptions)` instead. Will be removed in version 7.0.0.", true)]
        public System.Threading.Tasks.Task SendAsync<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options) { }
        [System.ObsoleteAttribute("Please use `IStartableBus.StartAsync()` instead. Will be removed in version 7.0.0" +
            ".", true)]
        public System.Threading.Tasks.Task<NServiceBus.IBus> StartAsync() { }
        [System.ObsoleteAttribute("Please use `IBus.Subscribe(Type messageType)` instead. Will be removed in version" +
            " 7.0.0.", true)]
        public void Subscribe(System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `IBus.Subscribe<T>()` instead. Will be removed in version 7.0.0.", true)]
        public void Subscribe<T>() { }
        public System.Threading.Tasks.Task SubscribeAsync(System.Type eventType, NServiceBus.SubscribeOptions options) { }
        [System.ObsoleteAttribute("Please use `IBus.Unsubscribe(Type messageType)` instead. Will be removed in versi" +
            "on 7.0.0.", true)]
        public void Unsubscribe(System.Type messageType) { }
        [System.ObsoleteAttribute("Please use `IBus.Unsubscribe<T>()` instead. Will be removed in version 7.0.0.", true)]
        public void Unsubscribe<T>() { }
        public System.Threading.Tasks.Task UnsubscribeAsync(System.Type eventType, NServiceBus.UnsubscribeOptions options) { }
    }
}
namespace NServiceBus.Unicast.Messages
{
    public class LogicalMessage
    {
        public object Instance { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Unicast.Messages.MessageMetadata Metadata { get; }
        public void UpdateMessageInstance(object newInstance) { }
    }
    public class LogicalMessageFactory
    {
        public LogicalMessageFactory(NServiceBus.Unicast.Messages.MessageMetadataRegistry messageMetadataRegistry, NServiceBus.MessageInterfaces.IMessageMapper messageMapper) { }
        public NServiceBus.Unicast.Messages.LogicalMessage Create(object message) { }
        public NServiceBus.Unicast.Messages.LogicalMessage Create(System.Type messageType, object message) { }
    }
    public class MessageMetadata
    {
        public System.Collections.Generic.IEnumerable<System.Type> MessageHierarchy { get; }
        public System.Type MessageType { get; }
        [System.ObsoleteAttribute("You can access Recoverable via the DeliveryConstraints collection on the outgoing" +
            " context, the new constraint is called NonDurableDelivery. Will be removed in ve" +
            "rsion 7.0.0.", true)]
        public bool Recoverable { get; }
        [System.ObsoleteAttribute("You can access TTBR via the DeliveryConstraints collection on the outgoing contex" +
            "t. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class MessageMetadataRegistry
    {
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(System.Type messageType) { }
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(string messageTypeIdentifier) { }
    }
}
namespace NServiceBus.Unicast.Queuing
{
    [System.ObsoleteAttribute("Please use `QueueBindings` instead. Will be removed in version 7.0.0.", true)]
    public interface IWantQueueCreated { }
    public class QueueNotFoundException : System.Exception
    {
        public QueueNotFoundException() { }
        [System.ObsoleteAttribute("Please use `QueueNotFoundException(string queue, string message, Exception inner)" +
            "` instead. Will be removed in version 7.0.0.", true)]
        public QueueNotFoundException(NServiceBus.Address queue, string message, System.Exception inner) { }
        public QueueNotFoundException(string queue, string message, System.Exception inner) { }
        protected QueueNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public string Queue { get; set; }
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
}
namespace NServiceBus.Unicast.Routing
{
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class StaticMessageRouter
    {
        public StaticMessageRouter(System.Collections.Generic.IEnumerable<System.Type> knownMessages) { }
        [System.ObsoleteAttribute("Please use `config.AutoSubscribe().AutoSubscribePlainMessages()` instead. Will be" +
            " removed in version 7.0.0.", true)]
        public bool SubscribeToPlainMessages { get; set; }
        public System.Collections.Generic.List<string> GetDestinationFor(System.Type messageType) { }
        public void RegisterEventRoute(System.Type eventType, string endpointAddress) { }
        public void RegisterMessageRoute(System.Type messageType, string endpointAddress) { }
    }
}
namespace NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions
{
    public interface IInitializableSubscriptionStorage : NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.ISubscriptionStorage
    {
        void Init();
    }
    public interface ISubscriptionStorage
    {
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<string>> GetSubscriberAddressesForMessage(System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Subscribe(string client, System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(string client, System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
    }
}
namespace NServiceBus.Unicast.Subscriptions
{
    public class MessageType
    {
        public MessageType(System.Type type) { }
        public MessageType(string messageTypeString) { }
        public MessageType(string typeName, string versionString) { }
        public MessageType(string typeName, System.Version version) { }
        public string TypeName { get; }
        public System.Version Version { get; }
        public bool Equals(NServiceBus.Unicast.Subscriptions.MessageType other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class SubscriptionEventArgs : System.EventArgs
    {
        public SubscriptionEventArgs() { }
        public string MessageType { get; set; }
        public string SubscriberReturnAddress { get; set; }
    }
}
namespace NServiceBus.Unicast.Transport
{
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class static ControlMessage
    {
        public static NServiceBus.TransportMessage Create() { }
    }
    public class static ControlMessageFactory
    {
        public static NServiceBus.Transports.OutgoingMessage Create(NServiceBus.MessageIntentEnum intent) { }
    }
    [System.ObsoleteAttribute("Use the pipeline to catch failures. Will be removed in version 7.0.0.", true)]
    public class FailedMessageProcessingEventArgs : System.EventArgs
    {
        public FailedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class FinishedMessageProcessingEventArgs : System.EventArgs
    {
        public FinishedMessageProcessingEventArgs(NServiceBus.TransportMessage m) { }
        public NServiceBus.TransportMessage Message { get; }
    }
    [System.ObsoleteAttribute("Please use `IPushMessages` instead. Will be removed in version 7.0.0.", true)]
    public interface ITransport
    {
        int MaximumConcurrencyLevel { get; }
        int MaximumMessageThroughputPerSecond { get; }
        public event System.EventHandler<NServiceBus.Unicast.Transport.FailedMessageProcessingEventArgs> FailedMessageProcessing;
        public event System.EventHandler<NServiceBus.Unicast.Transport.FinishedMessageProcessingEventArgs> FinishedMessageProcessing;
        public event System.EventHandler<NServiceBus.Unicast.Transport.StartedMessageProcessingEventArgs> StartedMessageProcessing;
        public event System.EventHandler<NServiceBus.Unicast.Transport.TransportMessageReceivedEventArgs> TransportMessageReceived;
        void AbortHandlingCurrentMessage();
        void ChangeMaximumConcurrencyLevel(int maximumConcurrencyLevel);
        void ChangeMaximumMessageThroughputPerSecond(int maximumMessageThroughputPerSecond);
        void Start(NServiceBus.Address localAddress);
        void Stop();
    }
    public class PipelineInfo
    {
        public PipelineInfo(string name, string transportAddress) { }
        public string Name { get; }
        public string TransportAddress { get; }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class StartedMessageProcessingEventArgs : System.EventArgs
    {
        public StartedMessageProcessingEventArgs(NServiceBus.TransportMessage m) { }
        public NServiceBus.TransportMessage Message { get; }
    }
    public class TransactionSettings
    {
        [System.ObsoleteAttribute("No longer used. Will be removed in version 7.0.0.", true)]
        public TransactionSettings(bool isTransactional, System.TimeSpan transactionTimeout, System.Transactions.IsolationLevel isolationLevel, bool suppressDistributedTransactions, bool doNotWrapHandlersExecutionInATransactionScope) { }
        [System.ObsoleteAttribute("DoNotWrapHandlersExecutionInATransactionScope is no longer used here. Please use " +
            "settings.GetOrDefault<bool>(\'Transactions.DoNotWrapHandlersExecutionInATransacti" +
            "onScope\') instead. Will be removed in version 7.0.0.", true)]
        public bool DoNotWrapHandlersExecutionInATransactionScope { get; set; }
        public System.Transactions.IsolationLevel IsolationLevel { get; set; }
        public bool IsTransactional { get; set; }
        public bool SuppressDistributedTransactions { get; set; }
        public System.TimeSpan TransactionTimeout { get; set; }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportMessageAvailableEventArgs : System.EventArgs
    {
        public TransportMessageAvailableEventArgs(NServiceBus.TransportMessage m) { }
        public NServiceBus.TransportMessage Message { get; }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportMessageReceivedEventArgs : System.EventArgs
    {
        public TransportMessageReceivedEventArgs(NServiceBus.TransportMessage m) { }
        public NServiceBus.TransportMessage Message { get; }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportReceiver : NServiceBus.Unicast.Transport.ITransport, System.IDisposable
    {
        public TransportReceiver(NServiceBus.Unicast.Transport.TransactionSettings transactionSettings, int maximumConcurrencyLevel, int maximumThroughput, NServiceBus.Transports.IDequeueMessages receiver, NServiceBus.Faults.IManageMessageFailures manageMessageFailures, NServiceBus.Settings.ReadOnlySettings settings, NServiceBus.Configure config, NServiceBus.Unicast.Transport.TransactionSettings transactionSettings1) { }
        public NServiceBus.Faults.IManageMessageFailures FailureManager { get; set; }
        public int MaximumConcurrencyLevel { get; }
        public int MaximumMessageThroughputPerSecond { get; }
        public NServiceBus.Transports.IDequeueMessages Receiver { get; set; }
        public NServiceBus.Unicast.Transport.TransactionSettings TransactionSettings { get; }
        public event System.EventHandler<NServiceBus.Unicast.Transport.FailedMessageProcessingEventArgs> FailedMessageProcessing;
        public event System.EventHandler<NServiceBus.Unicast.Transport.FinishedMessageProcessingEventArgs> FinishedMessageProcessing;
        public event System.EventHandler<NServiceBus.Unicast.Transport.StartedMessageProcessingEventArgs> StartedMessageProcessing;
        public event System.EventHandler<NServiceBus.Unicast.Transport.TransportMessageReceivedEventArgs> TransportMessageReceived;
        public void AbortHandlingCurrentMessage() { }
        public void ChangeMaximumConcurrencyLevel(int maximumConcurrencyLevel) { }
        public void ChangeMaximumMessageThroughputPerSecond(int maximumMessageThroughputPerSecond) { }
        public void Dispose() { }
        public void Start(NServiceBus.Address address) { }
        public void Stop() { }
    }
}
namespace NServiceBus.UnitOfWork
{
    public interface IManageUnitsOfWork
    {
        void Begin();
        void End(System.Exception ex = null);
    }
}