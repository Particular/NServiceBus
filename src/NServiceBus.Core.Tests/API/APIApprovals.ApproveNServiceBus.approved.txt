[assembly: System.CLSCompliantAttribute(true)]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.AcceptanceTesting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Core.Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Hosting.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.PerformanceTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.5.2", FrameworkDisplayName=".NET Framework 4.5.2")]
public class static ConfigureHandlerSettings
{
    [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
        "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
        "l over handler creation. Will be removed in version 7.0.0.", true)]
    public static void InitializeHandlerProperty<THandler>(this NServiceBus.EndpointConfiguration config, string property, object value) { }
}
namespace NServiceBus
{
    [System.ObsoleteAttribute("Use the string based overloads. Will be removed in version 7.0.0.", true)]
    public class Address
    {
        public Address() { }
    }
    public enum AddressMode
    {
        Local = 0,
        Remote = 1,
    }
    [System.ObsoleteAttribute("Use `EndpointConfiguration.ExcludeAssemblies` instead. Will be removed in version" +
        " 7.0.0.", true)]
    public class AllAssemblies
    {
        public AllAssemblies() { }
    }
    public class AssemblyScannerConfiguration
    {
        public AssemblyScannerConfiguration() { }
        public bool ScanAppDomainAssemblies { get; set; }
        public bool ScanAssembliesInNestedDirectories { get; set; }
        public bool ThrowExceptions { get; set; }
        public void ExcludeAssemblies(params string[] assemblies) { }
        public void ExcludeTypes(params System.Type[] types) { }
    }
    public class static AssemblyScannerConfigurationExtensions
    {
        public static NServiceBus.AssemblyScannerConfiguration AssemblyScanner(this NServiceBus.EndpointConfiguration configuration) { }
    }
    public class static AuditConfigReader
    {
        public static bool TryGetAuditQueueAddress(this NServiceBus.Settings.ReadOnlySettings settings, out string address) { }
    }
    public class static AutoSubscribeSettingsExtensions
    {
        public static NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings AutoSubscribe(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static BestPracticesOptionExtensions
    {
        public static void DoNotEnforceBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingReplyContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingSendContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.ISubscribeContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingPublishContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IUnsubscribeContext context) { }
        public static bool IgnoredBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public class static Bus
    {
        [System.ObsoleteAttribute("Use `Endpoint.Create` instead. The member currently throws a NotImplementedExcept" +
            "ion. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.IStartableBus Create(NServiceBus.EndpointConfiguration configuration) { }
        [System.ObsoleteAttribute("Use `EndpointConfiguration.SendOnly` instead. The member currently throws a NotIm" +
            "plementedException. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.IBus CreateSendOnly(NServiceBus.EndpointConfiguration configuration) { }
    }
    [System.ObsoleteAttribute("No longer used, use the new callbacks api described in the version 6 upgrade guid" +
        "e. Will be removed in version 7.0.0.", true)]
    public class BusAsyncResultEventArgs
    {
        public BusAsyncResultEventArgs() { }
    }
    [System.ObsoleteAttribute("Use `EndpointConfiguration` instead. Will be removed in version 7.0.0.", true)]
    public class BusConfiguration
    {
        public BusConfiguration() { }
    }
    [System.ObsoleteAttribute("Use `Notifications` instead. Will be removed in version 7.0.0.", true)]
    public class BusNotifications
    {
        public BusNotifications() { }
    }
    [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
    public class CompletionResult
    {
        public CompletionResult() { }
    }
    public class static ConfigurationTimeoutExtensions
    {
        public static void TimeToWaitBeforeTriggeringCriticalErrorOnTimeoutOutages(this NServiceBus.EndpointConfiguration config, System.TimeSpan timeToWait) { }
    }
    [System.ObsoleteAttribute("This is no longer a public API. Will be removed in version 7.0.0.", true)]
    public class Configure
    {
        public Configure() { }
    }
    public class static ConfigureAudit
    {
        public static void AuditProcessedMessagesTo(this NServiceBus.EndpointConfiguration config, string auditQueue, System.Nullable<System.TimeSpan> timeToBeReceived = null) { }
    }
    public class static ConfigureCriticalErrorAction
    {
        public static void DefineCriticalErrorAction(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Func<NServiceBus.ICriticalErrorContext, System.Threading.Tasks.Task> onCriticalError) { }
        [System.ObsoleteAttribute("Use `ConfigureCriticalErrorAction.DefineCriticalErrorAction(EndpointConfiguration" +
            ", Func<ICriticalErrorContext, Task>)` instead. Will be removed in version 7.0.0." +
            "", true)]
        public static void DefineCriticalErrorAction(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Action<string, System.Exception> onCriticalError) { }
    }
    public class static ConfigureError
    {
        public static void SendFailedMessagesTo(this NServiceBus.EndpointConfiguration config, string errorQueue) { }
    }
    public class static ConfigureFileShareDataBus
    {
        public static NServiceBus.DataBus.DataBusExtensions<NServiceBus.FileShareDataBus> BasePath(this NServiceBus.DataBus.DataBusExtensions<NServiceBus.FileShareDataBus> config, string basePath) { }
        [System.ObsoleteAttribute("Use `BasePath(this DataBusExtensions<FileShareDataBus> config, string basePath)` " +
            "instead. The member currently throws a NotImplementedException. Will be removed " +
            "in version 7.0.0.", true)]
        public static NServiceBus.DataBus.DataBusExtentions<NServiceBus.FileShareDataBus> BasePath(this NServiceBus.DataBus.DataBusExtentions<NServiceBus.FileShareDataBus> config, string basePath) { }
    }
    public class static ConfigureForwarding
    {
        public static void ForwardReceivedMessagesTo(this NServiceBus.EndpointConfiguration config, string address) { }
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class static ConfigureInMemoryFaultManagement
    {
        [System.ObsoleteAttribute("This is no longer supported. If you want full control over what happens when a me" +
            "ssage fails (including retries) override the MoveFaultsToErrorQueue behavior. Th" +
            "e member currently throws a NotImplementedException. Will be removed in version " +
            "7.0.0.", true)]
        public static void DiscardFailedMessagesInsteadOfSendingToErrorQueue(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static ConfigureLicenseExtensions
    {
        public static void License(this NServiceBus.EndpointConfiguration config, string licenseText) { }
        public static void LicensePath(this NServiceBus.EndpointConfiguration config, string licenseFile) { }
    }
    public class static ConfigurePurging
    {
        public static void PurgeOnStartup(this NServiceBus.EndpointConfiguration config, bool value) { }
        [System.ObsoleteAttribute("The member currently throws a NotImplementedException. Will be removed in version" +
            " 7.0.0.", true)]
        public static bool PurgeOnStartup(this NServiceBus.Configure config) { }
    }
    public class static ConfigureQueueCreation
    {
        [System.ObsoleteAttribute("Use `CreateQueues` instead. The member currently throws a NotImplementedException" +
            ". Will be removed in version 7.0.0.", true)]
        public static bool CreateQueues(this NServiceBus.Configure config) { }
        public static bool CreateQueues(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static void DoNotCreateQueues(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static ConfigureRijndaelEncryptionService
    {
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. Will be treated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public static void RegisterEncryptionService(this NServiceBus.EndpointConfiguration config, System.Func<NServiceBus.IEncryptionService> func) { }
        [System.ObsoleteAttribute(@"It is no longer possible to access the builder to create an encryption service. If container access is required use the container directly in the factory. Use `RegisterEncryptionService(this EndpointConfiguration config, Func<IEncryptionService> func)` instead. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public static void RegisterEncryptionService(this NServiceBus.EndpointConfiguration config, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.IEncryptionService> func) { }
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. Will be treated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config) { }
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. Will be treated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config, string encryptionKeyIdentifier, byte[] encryptionKey, System.Collections.Generic.IList<byte[]> decryptionKeys = null) { }
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. Will be treated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config, string encryptionKeyIdentifier, System.Collections.Generic.IDictionary<string, byte[]> keys, System.Collections.Generic.IList<byte[]> decryptionKeys = null) { }
    }
    public class static ConfigureTransportConnectionString
    {
        [System.ObsoleteAttribute("Not available any more. The member currently throws a NotImplementedException. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public static string TransportConnectionString(this NServiceBus.Configure config) { }
    }
    public class static ConnectorContextExtensions
    {
        public static NServiceBus.Pipeline.IAuditContext CreateAuditContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IAuditContext> forkConnector, NServiceBus.Transport.OutgoingMessage message, string auditAddress, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IBatchDispatchContext CreateBatchDispatchContext(this NServiceBus.Pipeline.StageForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IBatchDispatchContext> stageForkConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IDispatchContext CreateDispatchContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IBatchDispatchContext, NServiceBus.Pipeline.IDispatchContext> stageConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IBatchDispatchContext sourceContext) { }
        public static NServiceBus.Pipeline.IDispatchContext CreateDispatchContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IRoutingContext, NServiceBus.Pipeline.IDispatchContext> stageConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IRoutingContext sourceContext) { }
        public static NServiceBus.Pipeline.IForwardingContext CreateForwardingContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IForwardingContext> forwardingContext, NServiceBus.Transport.OutgoingMessage message, string forwardingAddress, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingLogicalMessageContext CreateIncomingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IIncomingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.LogicalMessage logicalMessage, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(this NServiceBus.Pipeline.StageForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IBatchDispatchContext> stageForkConnector, NServiceBus.Transport.IncomingMessage incomingMessage, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext> stageConnector, NServiceBus.Transport.IncomingMessage incomingMessage, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IInvokeHandlerContext CreateInvokeHandlerContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IIncomingLogicalMessageContext, NServiceBus.Pipeline.IInvokeHandlerContext> stageConnector, NServiceBus.Pipeline.MessageHandler messageHandler, NServiceBus.Persistence.CompletableSynchronizedStorageSession storageSession, NServiceBus.Pipeline.IIncomingLogicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingPublishContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingPublishContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingReplyContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingReplyContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingSendContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingSendContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingPhysicalMessageContext CreateOutgoingPhysicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingLogicalMessageContext, NServiceBus.Pipeline.IOutgoingPhysicalMessageContext> stageConnector, byte[] messageBody, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingLogicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IRoutingContext> forkConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, string localAddress, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IForwardingContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy, NServiceBus.Pipeline.IForwardingContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IAuditContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy, NServiceBus.Pipeline.IAuditContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingPhysicalMessageContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingPhysicalMessageContext sourceContext) { }
    }
    public abstract class ContainSagaData : NServiceBus.IContainSagaData
    {
        protected ContainSagaData() { }
        public virtual System.Guid Id { get; set; }
        public virtual string OriginalMessageId { get; set; }
        public virtual string Originator { get; set; }
    }
    public class static ContentTypes
    {
        public const string Json = "application/json";
        public const string Xml = "text/xml";
    }
    public class Conventions
    {
        public Conventions() { }
        public void AddSystemMessagesConventions(System.Func<System.Type, bool> definesMessageType) { }
        [System.ObsoleteAttribute("No longer an extension point. The member currently throws a NotImplementedExcepti" +
            "on. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan GetTimeToBeReceived(System.Type messageType) { }
        public bool IsCommandType(System.Type t) { }
        public bool IsDataBusProperty(System.Reflection.PropertyInfo property) { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        public bool IsEncryptedProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEventType(System.Type t) { }
        [System.ObsoleteAttribute("No longer an extension point. The member currently throws a NotImplementedExcepti" +
            "on. Will be removed in version 7.0.0.", true)]
        public static bool IsExpressMessageType(System.Type t) { }
        public bool IsInSystemConventionList(System.Type t) { }
        public bool IsMessageType(System.Type t) { }
    }
    public class ConventionsBuilder : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public ConventionsBuilder(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.Conventions Conventions { get; }
        public NServiceBus.ConventionsBuilder DefiningCommandsAs(System.Func<System.Type, bool> definesCommandType) { }
        public NServiceBus.ConventionsBuilder DefiningDataBusPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesDataBusProperty) { }
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. This convention configuration does not work in combination with the NServiceBus.Encryption.MessageProperty package. Will be treated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public NServiceBus.ConventionsBuilder DefiningEncryptedPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesEncryptedProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEventsAs(System.Func<System.Type, bool> definesEventType) { }
        public NServiceBus.ConventionsBuilder DefiningMessagesAs(System.Func<System.Type, bool> definesMessageType) { }
    }
    public class static CorrelationContextExtensions
    {
        [System.ObsoleteAttribute("Using custom correlation IDs is discouraged and will be removed in the next major" +
            " version. Will be treated as an error from version 7.0.0. Will be removed in ver" +
            "sion 8.0.0.", false)]
        public static string GetCorrelationId(this NServiceBus.SendOptions options) { }
        [System.ObsoleteAttribute("Using custom correlation IDs is discouraged and will be removed in the next major" +
            " version. Will be treated as an error from version 7.0.0. Will be removed in ver" +
            "sion 8.0.0.", false)]
        public static string GetCorrelationId(this NServiceBus.ReplyOptions options) { }
        [System.ObsoleteAttribute("Setting a custom correlation ID is discouraged and will be removed in the next ma" +
            "jor version. Will be treated as an error from version 7.0.0. Will be removed in " +
            "version 8.0.0.", false)]
        public static void SetCorrelationId(this NServiceBus.SendOptions options, string correlationId) { }
        [System.ObsoleteAttribute("Setting a custom correlation ID is discouraged and will be removed in the next ma" +
            "jor version. Will be treated as an error from version 7.0.0. Will be removed in " +
            "version 8.0.0.", false)]
        public static void SetCorrelationId(this NServiceBus.ReplyOptions options, string correlationId) { }
    }
    public class CriticalError
    {
        public CriticalError(System.Func<NServiceBus.ICriticalErrorContext, System.Threading.Tasks.Task> onCriticalErrorAction) { }
        public virtual void Raise(string errorMessage, System.Exception exception) { }
    }
    public class CriticalErrorContext : NServiceBus.ICriticalErrorContext
    {
        public CriticalErrorContext(System.Func<System.Threading.Tasks.Task> stop, string error, System.Exception exception) { }
        public string Error { get; }
        public System.Exception Exception { get; }
        public System.Func<System.Threading.Tasks.Task> Stop { get; }
    }
    public class static CriticalTimeMonitoringConfig
    {
        [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
            "s.PerformanceCounters. Will be treated as an error from version 7.0.0. Will be r" +
            "emoved in version 8.0.0.", false)]
        public static void EnableCriticalTimePerformanceCounter(this NServiceBus.EndpointConfiguration config) { }
    }
    public class DataBusProperty<T> : NServiceBus.IDataBusProperty, System.Runtime.Serialization.ISerializable
        where T :  class
    {
        public DataBusProperty(T value) { }
        protected DataBusProperty(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public bool HasValue { get; set; }
        public string Key { get; set; }
        public T Value { get; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public object GetValue() { }
        public void SetValue(object valueToSet) { }
    }
    public class static DateTimeExtensions
    {
        public static System.DateTime ToUtcDateTime(string wireFormattedString) { }
        public static string ToWireFormattedString(System.DateTime dateTime) { }
    }
    public class static DefaultRecoverabilityPolicy
    {
        public static NServiceBus.RecoverabilityAction Invoke(NServiceBus.RecoverabilityConfig config, NServiceBus.Transport.ErrorContext errorContext) { }
    }
    public class DelayedConfig
    {
        public DelayedConfig(int maxNumberOfRetries, System.TimeSpan timeIncrease) { }
        public int MaxNumberOfRetries { get; }
        public System.TimeSpan TimeIncrease { get; }
    }
    public class static DelayedDeliveryOptionExtensions
    {
        public static void DelayDeliveryWith(this NServiceBus.SendOptions options, System.TimeSpan delay) { }
        public static void DoNotDeliverBefore(this NServiceBus.SendOptions options, System.DateTimeOffset at) { }
        public static System.Nullable<System.DateTimeOffset> GetDeliveryDate(this NServiceBus.SendOptions options) { }
        public static System.Nullable<System.TimeSpan> GetDeliveryDelay(this NServiceBus.SendOptions options) { }
    }
    public class DelayedRetriesSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.DelayedRetriesSettings NumberOfRetries(int numberOfRetries) { }
        public NServiceBus.DelayedRetriesSettings TimeIncrease(System.TimeSpan timeIncrease) { }
    }
    public sealed class DelayedRetry : NServiceBus.RecoverabilityAction
    {
        public System.TimeSpan Delay { get; }
    }
    public enum DependencyLifecycle
    {
        SingleInstance = 0,
        InstancePerUnitOfWork = 1,
        InstancePerCall = 2,
    }
    public class DevelopmentTransport : NServiceBus.Transport.TransportDefinition
    {
        public DevelopmentTransport() { }
        public override string ExampleConnectionStringForErrorMessage { get; }
        public override bool RequiresConnectionString { get; }
        public override NServiceBus.Transport.TransportInfrastructure Initialize(NServiceBus.Settings.SettingsHolder settings, string connectionString) { }
    }
    public class static DevelopmentTransportConfigExtensions
    {
        public static void StorageDirectory(this NServiceBus.TransportExtensions<NServiceBus.DevelopmentTransport> config, string path) { }
    }
    public class DevelopmentTransportHeader
    {
        public DevelopmentTransportHeader() { }
        public string Key { get; set; }
        public string Value { get; set; }
    }
    public class DistributionPolicy : NServiceBus.IDistributionPolicy
    {
        public DistributionPolicy() { }
        public void SetDistributionStrategy(NServiceBus.Routing.DistributionStrategy distributionStrategy) { }
    }
    public enum DistributionStrategyScope
    {
        Send = 0,
        Publish = 1,
    }
    public class static DurableMessagesConfig
    {
        public static void DisableDurableMessages(this NServiceBus.EndpointConfiguration config) { }
        public static bool DurableMessagesEnabled(this NServiceBus.Settings.ReadOnlySettings settings) { }
        [System.ObsoleteAttribute("Use `DurableMessagesEnabled` instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 7.0.0.", true)]
        public static bool DurableMessagesEnabled(this NServiceBus.Configure config) { }
        public static void EnableDurableMessages(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static DurableMessagesConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningExpressMessagesAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, bool> definesExpressMessageType) { }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
        "removed in version 8.0.0.", false)]
    public class EncryptedValue
    {
        public EncryptedValue() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        public string Base64Iv { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        public string EncryptedBase64Value { get; set; }
    }
    public class static Endpoint
    {
        public static System.Threading.Tasks.Task<NServiceBus.IStartableEndpoint> Create(NServiceBus.EndpointConfiguration configuration) { }
        public static System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start(NServiceBus.EndpointConfiguration configuration) { }
    }
    public class EndpointConfiguration : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public EndpointConfiguration(string endpointName) { }
        public NServiceBus.Notifications Notifications { get; }
        [System.ObsoleteAttribute("Use `EndpointConfiguration.AddHeaderToAllOutgoingMessages(string key,string value" +
            ")` instead. The member currently throws a NotImplementedException. Will be remov" +
            "ed in version 7.0.0.", true)]
        public System.Collections.Generic.IDictionary<string, string> OutgoingHeaders { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        [System.ObsoleteAttribute("Use `EndpointConfiguration.ExcludeAssemblies` instead. The member currently throw" +
            "s a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void AssembliesToScan(System.Collections.Generic.IEnumerable<System.Reflection.Assembly> assemblies) { }
        [System.ObsoleteAttribute("Use `EndpointConfiguration.ExcludeAssemblies` instead. The member currently throw" +
            "s a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void AssembliesToScan(params System.Reflection.Assembly[] assemblies) { }
        public NServiceBus.ConventionsBuilder Conventions() { }
        public void CustomConfigurationSource(NServiceBus.Config.ConfigurationSource.IConfigurationSource configurationSource) { }
        [System.ObsoleteAttribute("Endpoint name is now a mandatory constructor argument on EndpointConfiguration. T" +
            "he member currently throws a NotImplementedException. Will be removed in version" +
            " 7.0.0.", true)]
        public void EndpointName(string name) { }
        [System.ObsoleteAttribute("Use the AssemblyScanner configuration API. Use `AssemblyScannerConfigurationExten" +
            "sions.AssemblyScanner` instead. Will be treated as an error from version 7.0.0. " +
            "Will be removed in version 8.0.0.", false)]
        public void ExcludeAssemblies(params string[] assemblies) { }
        [System.ObsoleteAttribute("Use the AssemblyScanner configuration API. Use `AssemblyScannerConfigurationExten" +
            "sions.AssemblyScanner` instead. Will be treated as an error from version 7.0.0. " +
            "Will be removed in version 8.0.0.", false)]
        public void ExcludeTypes(params System.Type[] types) { }
        [System.ObsoleteAttribute("Use `EndpointConfiguration.OverridePublicReturnAddress(string address)` instead. " +
            "The member currently throws a NotImplementedException. Will be removed in versio" +
            "n 7.0.0.", true)]
        public void OverridePublicReturnAddress(NServiceBus.Address address) { }
        public void RegisterComponents(System.Action<NServiceBus.ObjectBuilder.IConfigureComponents> registration) { }
        [System.ObsoleteAttribute("Use `EndpointConfiguration.ExcludeAssemblies` instead. The member currently throw" +
            "s a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void ScanAssembliesInDirectory(string probeDirectory) { }
        [System.ObsoleteAttribute("Use the AssemblyScanner configuration API. Use `AssemblyScannerConfigurationExten" +
            "sions.AssemblyScanner` instead. Will be treated as an error from version 7.0.0. " +
            "Will be removed in version 8.0.0.", false)]
        public void ScanAssembliesInNestedDirectories() { }
        public void SendOnly() { }
        [System.ObsoleteAttribute("Use `EndpointConfiguration.ExcludeTypes` instead. The member currently throws a N" +
            "otImplementedException. Will be removed in version 7.0.0.", true)]
        public void TypesToScan(System.Collections.Generic.IEnumerable<System.Type> typesToScan) { }
        public void UseContainer<T>(System.Action<NServiceBus.Container.ContainerCustomizations> customizations = null)
            where T : NServiceBus.Container.ContainerDefinition, new () { }
        public void UseContainer(System.Type definitionType) { }
        public void UseContainer(NServiceBus.ObjectBuilder.Common.IContainer builder) { }
    }
    public class static EndpointConfigurationExtensions
    {
        public static void DisableFeature<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void DisableFeature(this NServiceBus.EndpointConfiguration config, System.Type featureType) { }
        public static void EnableFeature<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void EnableFeature(this NServiceBus.EndpointConfiguration config, System.Type featureType) { }
    }
    public class static EndpointInstanceExtensions
    {
        public static NServiceBus.Routing.EndpointInstance AtMachine(this NServiceBus.Routing.EndpointInstance instance, string machineName) { }
    }
    public class static ErrorQueueSettings
    {
        public static string ErrorQueueAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class ExpressAttribute : System.Attribute
    {
        public ExpressAttribute() { }
    }
    [System.ObsoleteAttribute("Headers are not managed via the send, reply and publishoptions. Will be removed i" +
        "n version 7.0.0.", true)]
    public class static ExtensionMethods
    {
        [System.ObsoleteAttribute("Use a incoming behavior to get access to the current message. The member currentl" +
            "y throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public static object CurrentMessageBeingHandled { get; set; }
        [System.ObsoleteAttribute("Headers are not \'set\' only on the outgoing pipeline. The member currently throws " +
            "a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public static string GetMessageHeader(this NServiceBus.IBus bus, object msg, string key) { }
        [System.ObsoleteAttribute("Use the overload of the Send, Publish or Reply method that accepts an options par" +
            "ameter. Call options.SetHeader(\"MyHeader\",\"MyValue\") instead. The member current" +
            "ly throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public static void SetMessageHeader(this NServiceBus.IBus bus, object msg, string key, string value) { }
    }
    public class FailedConfig
    {
        [System.ObsoleteAttribute("Use `FailedConfig(string errorQueue, HashSet<Type> unrecoverableExceptionTypes)` " +
            "instead. Will be treated as an error from version 7.0.0. Will be removed in vers" +
            "ion 8.0.0.", false)]
        public FailedConfig(string errorQueue) { }
        public FailedConfig(string errorQueue, System.Collections.Generic.HashSet<System.Type> unrecoverableExceptionTypes) { }
        public string ErrorQueue { get; }
        public System.Collections.Generic.HashSet<System.Type> UnrecoverableExceptionTypes { get; }
    }
    public class FileShareDataBus : NServiceBus.DataBus.DataBusDefinition
    {
        public FileShareDataBus() { }
        protected internal override System.Type ProvidedByFeature() { }
    }
    [System.ObsoleteAttribute("Use `EndpointConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed in" +
        " version 7.0.0.", true)]
    public class First<T>
    {
        public First() { }
    }
    public class static HeaderOptionExtensions
    {
        public static System.Collections.Generic.IReadOnlyDictionary<string, string> GetHeaders(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void SetHeader(this NServiceBus.Extensibility.ExtendableOptions options, string key, string value) { }
    }
    public class static Headers
    {
        public const string ContentType = "NServiceBus.ContentType";
        public const string ControlMessageHeader = "NServiceBus.ControlMessage";
        public const string ConversationId = "NServiceBus.ConversationId";
        public const string CorrelationId = "NServiceBus.CorrelationId";
        public const string DelayedRetries = "NServiceBus.Retries";
        public const string DelayedRetriesTimestamp = "NServiceBus.Retries.Timestamp";
        public const string DestinationSites = "NServiceBus.DestinationSites";
        public const string EnclosedMessageTypes = "NServiceBus.EnclosedMessageTypes";
        [System.ObsoleteAttribute("Use `ImmediateRetries` instead. Will be removed in version 7.0.0.", true)]
        public const string FLRetries = "NServiceBus.FLRetries";
        public const string HasLicenseExpired = "$.diagnostics.license.expired";
        public const string HeaderName = "Header";
        public const string HostDisplayName = "$.diagnostics.hostdisplayname";
        public const string HostId = "$.diagnostics.hostid";
        public const string HttpFrom = "NServiceBus.From";
        public const string HttpTo = "NServiceBus.To";
        public const string ImmediateRetries = "NServiceBus.FLRetries";
        public const string IsDeferredMessage = "NServiceBus.IsDeferredMessage";
        public const string IsSagaTimeoutMessage = "NServiceBus.IsSagaTimeoutMessage";
        public const string MessageId = "NServiceBus.MessageId";
        public const string MessageIntent = "NServiceBus.MessageIntent";
        public const string NonDurableMessage = "NServiceBus.NonDurableMessage";
        public const string NServiceBusVersion = "NServiceBus.Version";
        public const string OriginatingAddress = "NServiceBus.OriginatingAddress";
        public const string OriginatingEndpoint = "NServiceBus.OriginatingEndpoint";
        public const string OriginatingHostId = "$.diagnostics.originating.hostid";
        public const string OriginatingMachine = "NServiceBus.OriginatingMachine";
        public const string OriginatingSagaId = "NServiceBus.OriginatingSagaId";
        public const string OriginatingSagaType = "NServiceBus.OriginatingSagaType";
        public const string OriginatingSite = "NServiceBus.OriginatingSite";
        public const string ProcessingEnded = "NServiceBus.ProcessingEnded";
        public const string ProcessingEndpoint = "NServiceBus.ProcessingEndpoint";
        public const string ProcessingMachine = "NServiceBus.ProcessingMachine";
        public const string ProcessingStarted = "NServiceBus.ProcessingStarted";
        public const string RelatedTo = "NServiceBus.RelatedTo";
        public const string ReplyToAddress = "NServiceBus.ReplyToAddress";
        [System.ObsoleteAttribute("Use `DelayedRetries` instead. Will be removed in version 7.0.0.", true)]
        public const string Retries = "NServiceBus.Retries";
        [System.ObsoleteAttribute("Use `DelayedRetriesTimestamp` instead. Will be removed in version 7.0.0.", true)]
        public const string RetriesTimestamp = "NServiceBus.Retries.Timestamp";
        public const string ReturnMessageErrorCodeHeader = "NServiceBus.ReturnMessage.ErrorCode";
        public const string RijndaelKeyIdentifier = "NServiceBus.RijndaelKeyIdentifier";
        public const string RouteTo = "NServiceBus.Header.RouteTo";
        public const string SagaId = "NServiceBus.SagaId";
        public const string SagaType = "NServiceBus.SagaType";
        public const string SubscriberEndpoint = "NServiceBus.SubscriberEndpoint";
        public const string SubscriberTransportAddress = "NServiceBus.SubscriberAddress";
        public const string SubscriptionMessageType = "SubscriptionMessageType";
        public const string TimeSent = "NServiceBus.TimeSent";
        public const string TimeToBeReceived = "NServiceBus.TimeToBeReceived";
        [System.ObsoleteAttribute("The WinIdName header is no longer attached to outgoing message to avoid passing s" +
            "ecurity related information on the wire. Should you rely on the header being pre" +
            "sent you can add a message mutator that sets it. Will be removed in version 7.0." +
            "0.", true)]
        public const string WindowsIdentityName = "WinIdName";
    }
    public class static HostInfoConfigurationExtensions
    {
        public static NServiceBus.HostInfoSettings UniquelyIdentifyRunningInstance(this NServiceBus.EndpointConfiguration config) { }
    }
    public class HostInfoSettings
    {
        public NServiceBus.HostInfoSettings UsingCustomDisplayName(string displayName) { }
        public NServiceBus.HostInfoSettings UsingCustomIdentifier(System.Guid id) { }
        public NServiceBus.HostInfoSettings UsingInstalledFilePath() { }
        public NServiceBus.HostInfoSettings UsingNames(string instanceName, string hostName) { }
    }
    public interface IAmStartedByMessages<T> : NServiceBus.IHandleMessages<T> { }
    [System.ObsoleteAttribute("Use `config.UseTransport<MsmqTransport>().SubscriptionAuthorizer(Authorizer);` in" +
        "stead. Will be removed in version 7.0.0.", true)]
    public interface IAuthorizeSubscriptions { }
    [System.ObsoleteAttribute(@"IHandleMessages<T> now exposes the IMessageHandlerContext parameter. Use this to access what used to be available in the IBus interface. Use the provided context in extension points like message handlers or IEndpointInstance when outside the message processing pipeline. Will be removed in version 7.0.0.", true)]
    public interface IBus { }
    public class static IBusExtensions
    {
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.DoNotContinueDispatchingCurrentMessageToHandlers()` p" +
            "rovided to message handlers instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 7.0.0.", true)]
        public static void DoNotContinueDispatchingCurrentMessageToHandlers(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.ForwardCurrentMessageTo(string destination)` provided" +
            " to message handlers instead. The member currently throws a NotImplementedExcept" +
            "ion. Will be removed in version 7.0.0.", true)]
        public static void ForwardCurrentMessageTo(this NServiceBus.IBus bus, string destination) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.HandleCurrentMessageLater()` provided to message hand" +
            "lers instead. The member currently throws a NotImplementedException. Will be rem" +
            "oved in version 7.0.0.", true)]
        public static void HandleCurrentMessageLater(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.Reply(object message)` provided to message handlers i" +
            "nstead. The member currently throws a NotImplementedException. Will be removed i" +
            "n version 7.0.0.", true)]
        public static void Reply(this NServiceBus.IBus bus, object message) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.Reply<T>(Action<T> messageConstructor)` provided to m" +
            "essage handlers instead. The member currently throws a NotImplementedException. " +
            "Will be removed in version 7.0.0.", true)]
        public static void Reply<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.SendLocal(object message)` provided to message handle" +
            "rs instead. The member currently throws a NotImplementedException. Will be remov" +
            "ed in version 7.0.0.", true)]
        public static void SendLocal(this NServiceBus.IBus bus, object message) { }
        [System.ObsoleteAttribute("Use `IMessageHandlerContext.SendLocal<T>(Action<T> messageConstructor)` provided " +
            "to message handlers instead. The member currently throws a NotImplementedExcepti" +
            "on. Will be removed in version 7.0.0.", true)]
        public static void SendLocal<T>(this NServiceBus.IBus bus, System.Action<T> messageConstructor) { }
        [System.ObsoleteAttribute("Use `Subscribe(Type messageType)` instead. The member currently throws a NotImple" +
            "mentedException. Will be removed in version 7.0.0.", true)]
        public static void Subscribe(this NServiceBus.IBus bus, System.Type messageType) { }
        [System.ObsoleteAttribute("Use `Subscribe<T>()` instead. The member currently throws a NotImplementedExcepti" +
            "on. Will be removed in version 7.0.0.", true)]
        public static void Subscribe<T>(this NServiceBus.IBus bus) { }
        [System.ObsoleteAttribute("Use `Unsubscribe(Type messageType)` instead. The member currently throws a NotImp" +
            "lementedException. Will be removed in version 7.0.0.", true)]
        public static void Unsubscribe(this NServiceBus.IBus bus, System.Type messageType) { }
        [System.ObsoleteAttribute("Use `Unsubscribe<T>()` instead. The member currently throws a NotImplementedExcep" +
            "tion. Will be removed in version 7.0.0.", true)]
        public static void Unsubscribe<T>(this NServiceBus.IBus bus) { }
    }
    [System.ObsoleteAttribute("Replaced by NServiceBus.Callbacks package. Will be removed in version 7.0.0.", true)]
    public interface ICallback { }
    public interface ICommand : NServiceBus.IMessage { }
    public interface IConfigureHowToFindSagaWithMessage
    {
        void ConfigureMapping<TSagaEntity, TMessage>(System.Linq.Expressions.Expression<System.Func<TSagaEntity, object>> sagaEntityProperty, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty)
            where TSagaEntity : NServiceBus.IContainSagaData
        ;
    }
    public interface IContainSagaData
    {
        System.Guid Id { get; set; }
        string OriginalMessageId { get; set; }
        string Originator { get; set; }
    }
    public interface ICriticalErrorContext
    {
        string Error { get; }
        System.Exception Exception { get; }
        System.Func<System.Threading.Tasks.Task> Stop { get; }
    }
    public interface IDataBusProperty
    {
        bool HasValue { get; set; }
        string Key { get; set; }
        object GetValue();
        void SetValue(object value);
    }
    public interface IDistributionPolicy
    {
        NServiceBus.Routing.DistributionStrategy GetDistributionStrategy(string endpointName, NServiceBus.DistributionStrategyScope scope);
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
        "removed in version 8.0.0.", false)]
    public interface IEncryptionService
    {
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        string Decrypt(NServiceBus.EncryptedValue encryptedValue, NServiceBus.Pipeline.IIncomingLogicalMessageContext context);
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        NServiceBus.EncryptedValue Encrypt(string value, NServiceBus.Pipeline.IOutgoingLogicalMessageContext context);
    }
    public interface IEndpointInstance : NServiceBus.IMessageSession
    {
        System.Threading.Tasks.Task Stop();
    }
    public interface IEvent : NServiceBus.IMessage { }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public interface IExcludesBuilder { }
    public interface IHandleMessages<T>
    {
        System.Threading.Tasks.Task Handle(T message, NServiceBus.IMessageHandlerContext context);
    }
    public interface IHandleTimeouts<T>
    {
        System.Threading.Tasks.Task Timeout(T state, NServiceBus.IMessageHandlerContext context);
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public interface IIncludesBuilder { }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public interface IManageMessageHeaders { }
    public interface IMessage { }
    [System.ObsoleteAttribute("Use `IMessageHandlerContext` provided to message handlers instead. Will be remove" +
        "d in version 7.0.0.", true)]
    public interface IMessageContext { }
    public interface IMessageCreator
    {
        T CreateInstance<T>();
        T CreateInstance<T>(System.Action<T> action);
        object CreateInstance(System.Type messageType);
    }
    public interface IMessageHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext
    {
        NServiceBus.Persistence.SynchronizedStorageSession SynchronizedStorageSession { get; }
        void DoNotContinueDispatchingCurrentMessageToHandlers();
        System.Threading.Tasks.Task HandleCurrentMessageLater();
    }
    public interface IMessageProcessingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext
    {
        System.Collections.Generic.IReadOnlyDictionary<string, string> MessageHeaders { get; }
        string MessageId { get; }
        string ReplyToAddress { get; }
        System.Threading.Tasks.Task ForwardCurrentMessageTo(string destination);
        System.Threading.Tasks.Task Reply(object message, NServiceBus.ReplyOptions options);
        System.Threading.Tasks.Task Reply<T>(System.Action<T> messageConstructor, NServiceBus.ReplyOptions options);
    }
    public class static IMessageProcessingContextExtensions
    {
        public static System.Threading.Tasks.Task Reply(this NServiceBus.IMessageProcessingContext context, object message) { }
        public static System.Threading.Tasks.Task Reply<T>(this NServiceBus.IMessageProcessingContext context, System.Action<T> messageConstructor) { }
    }
    public interface IMessageSession
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.SubscribeOptions options);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.UnsubscribeOptions options);
    }
    public class static IMessageSessionExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IMessageSession session) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IMessageSession session, string destination, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IMessageSession session, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Subscribe(this NServiceBus.IMessageSession session, System.Type messageType) { }
        public static System.Threading.Tasks.Task Subscribe<T>(this NServiceBus.IMessageSession session) { }
        public static System.Threading.Tasks.Task Unsubscribe(this NServiceBus.IMessageSession session, System.Type messageType) { }
        public static System.Threading.Tasks.Task Unsubscribe<T>(this NServiceBus.IMessageSession session) { }
    }
    public class ImmediateConfig
    {
        public ImmediateConfig(int maxNumberOfRetries) { }
        public int MaxNumberOfRetries { get; }
    }
    public class static ImmediateDispatchOptionExtensions
    {
        public static bool RequiredImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void RequireImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public class ImmediateRetriesSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public void NumberOfRetries(int numberOfRetries) { }
    }
    public sealed class ImmediateRetry : NServiceBus.RecoverabilityAction { }
    public interface INeedInitialization
    {
        void Customize(NServiceBus.EndpointConfiguration configuration);
    }
    public class InMemoryPersistence : NServiceBus.Persistence.PersistenceDefinition { }
    public class static InstallConfigExtensions
    {
        public static void EnableInstallers(this NServiceBus.EndpointConfiguration config, string username = null) { }
    }
    public class InstanceMappingFileSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public InstanceMappingFileSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.InstanceMappingFileSettings FilePath(string filePath) { }
        public NServiceBus.InstanceMappingFileSettings RefreshInterval(System.TimeSpan refreshInterval) { }
    }
    public interface IPipelineContext : NServiceBus.Extensibility.IExtendable
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
    }
    public class static IPipelineContextExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IPipelineContext context) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IPipelineContext context, string destination, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IPipelineContext context, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
    }
    [System.ObsoleteAttribute("Use IEndpointInstance to create sending session. Will be removed in version 7.0.0" +
        ".", true)]
    public interface ISendOnlyBus : System.IDisposable { }
    [System.ObsoleteAttribute("Use `EndpointConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed in" +
        " version 7.0.0.", true)]
    public interface ISpecifyMessageHandlerOrdering { }
    [System.ObsoleteAttribute("Use `IStartableEndpoint` instead. Will be removed in version 7.0.0.", true)]
    public interface IStartableBus : NServiceBus.IBus
    {
        [System.ObsoleteAttribute("Use `IStartableEndpoint` instead. Will be removed in version 7.0.0.", true)]
        NServiceBus.IBus Start();
    }
    public interface IStartableEndpoint
    {
        System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start();
    }
    public interface IWantToRunBeforeConfigurationIsFinalized
    {
        void Run(NServiceBus.Settings.SettingsHolder settings);
    }
    [System.ObsoleteAttribute(@"`IWantToRunWhenBusStartsAndStops` has been moved to the host implementations and renamed. If you're self-hosting, instead of using this interface, you can call any startup code right before `Endpoint.Create` or any cleanup code right after `Endpoint.Stop`. When using either NServiceBus.Host or NServiceBus.Host.AzureCloudService, use the host's interface `IWantToRunWhenEndpointStartsAndStops` instead. Will be removed in version 7.0.0.", true)]
    public interface IWantToRunWhenBusStartsAndStops { }
    public class JsonSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public JsonSerializer() { }
        public override System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public class static JsonSerializerConfigurationExtensions
    {
        public static void Encoding(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.JsonSerializer> config, System.Text.Encoding encoding) { }
        [System.ObsoleteAttribute("Use `Encoding(this SerializationExtensions<JsonSerializer> config, Encoding encod" +
            "ing)` instead. The member currently throws a NotImplementedException. Will be re" +
            "moved in version 7.0.0.", true)]
        public static void Encoding(this NServiceBus.SerializationExtentions<NServiceBus.JsonSerializer> config, System.Text.Encoding encoding) { }
    }
    public class static LoadMessageHandlersExtensions
    {
        public static void ExecuteTheseHandlersFirst(this NServiceBus.EndpointConfiguration config, System.Collections.Generic.IEnumerable<System.Type> handlerTypes) { }
        public static void ExecuteTheseHandlersFirst(this NServiceBus.EndpointConfiguration config, params System.Type[] handlerTypes) { }
        [System.ObsoleteAttribute("Use `ExecuteTheseHandlersFirst` instead. The member currently throws a NotImpleme" +
            "ntedException. Will be removed in version 7.0.0.", true)]
        public static void LoadMessageHandlers<TFirst>(this NServiceBus.EndpointConfiguration config) { }
        [System.ObsoleteAttribute("Use `ExecuteTheseHandlersFirst` instead. The member currently throws a NotImpleme" +
            "ntedException. Will be removed in version 7.0.0.", true)]
        public static void LoadMessageHandlers<T>(this NServiceBus.EndpointConfiguration config, NServiceBus.First<T> order) { }
    }
    [System.ObsoleteAttribute("Use `LoadMessageHandlersExtensions` instead. Will be removed in version 7.0.0.", true)]
    public class static LoadMessageHandlersExtentions { }
    public struct LogicalAddress
    {
        public NServiceBus.Routing.EndpointInstance EndpointInstance { get; }
        public string Qualifier { get; }
        public NServiceBus.LogicalAddress CreateIndividualizedAddress(string discriminator) { }
        public static NServiceBus.LogicalAddress CreateLocalAddress(string queueName, System.Collections.Generic.IReadOnlyDictionary<string, string> properties) { }
        public NServiceBus.LogicalAddress CreateQualifiedAddress(string qualifier) { }
        public static NServiceBus.LogicalAddress CreateRemoteAddress(NServiceBus.Routing.EndpointInstance endpointInstance) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class MessageDeserializationException : System.Runtime.Serialization.SerializationException
    {
        public MessageDeserializationException(string message) { }
        public MessageDeserializationException(string transportMessageId, System.Exception innerException) { }
        protected MessageDeserializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static MessageDrivenSubscriptionsConfigExtensions
    {
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Type eventType, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Reflection.Assembly assembly, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Reflection.Assembly assembly, string @namespace, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void SubscriptionAuthorizer<T>(this NServiceBus.TransportExtensions<T> transportExtensions, System.Func<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, bool> authorizer)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
    }
    public class static MessageIdExtensions
    {
        public static string GetMessageId(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void SetMessageId(this NServiceBus.Extensibility.ExtendableOptions options, string messageId) { }
    }
    public enum MessageIntentEnum
    {
        Send = 1,
        Publish = 2,
        Subscribe = 3,
        Unsubscribe = 4,
        Reply = 5,
    }
    public class static MessageProcessingOptimizationExtensions
    {
        public static void LimitMessageProcessingConcurrencyTo(this NServiceBus.EndpointConfiguration config, int maxConcurrency) { }
    }
    public sealed class MoveToError : NServiceBus.RecoverabilityAction
    {
        public string ErrorQueue { get; }
    }
    public class static MsmqConfigurationExtensions
    {
        public static NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> ApplyLabelToMessages(this NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> transportExtensions, System.Func<System.Collections.Generic.IReadOnlyDictionary<string, string>, string> labelGenerator) { }
        public static NServiceBus.InstanceMappingFileSettings InstanceMappingFile(this NServiceBus.RoutingSettings<NServiceBus.MsmqTransport> config) { }
        public static void SetMessageDistributionStrategy(this NServiceBus.RoutingSettings<NServiceBus.MsmqTransport> config, NServiceBus.Routing.DistributionStrategy distributionStrategy) { }
        public static NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> TransactionScopeOptions(this NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> transportExtensions, System.Nullable<System.TimeSpan> timeout = null, System.Nullable<System.Transactions.IsolationLevel> isolationLevel = null) { }
        public static void UseDeadLetterQueueForMessagesWithTimeToBeReceived(this NServiceBus.TransportExtensions<NServiceBus.MsmqTransport> config) { }
    }
    public class MsmqTransport : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport
    {
        public MsmqTransport() { }
        public override string ExampleConnectionStringForErrorMessage { get; }
        public override bool RequiresConnectionString { get; }
        public override NServiceBus.Transport.TransportInfrastructure Initialize(NServiceBus.Settings.SettingsHolder settings, string connectionString) { }
    }
    public class NonDurableDelivery : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public NonDurableDelivery() { }
    }
    public class Notifications
    {
        public Notifications() { }
        public NServiceBus.Faults.ErrorsNotifications Errors { get; }
        [System.ObsoleteAttribute("For performance reasons it is no longer possible to instrument the pipeline execu" +
            "tion. The member currently throws a NotImplementedException. Will be removed in " +
            "version 7.0.0.", true)]
        public NServiceBus.PipelineNotifications Pipeline { get; }
    }
    [System.ObsoleteAttribute("Use `EndpointConfiguration.ExecuteTheseHandlersFirst` instead. Will be removed in" +
        " version 7.0.0.", true)]
    public class Order
    {
        public Order() { }
    }
    public class static OutboxConfigExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings EnableOutbox(this NServiceBus.EndpointConfiguration config) { }
    }
    public class PendingTransportOperations
    {
        public PendingTransportOperations() { }
        public bool HasOperations { get; }
        public NServiceBus.Transport.TransportOperation[] Operations { get; }
        public void Add(NServiceBus.Transport.TransportOperation transportOperation) { }
        public void AddRange(NServiceBus.Transport.TransportOperation[] transportOperations) { }
    }
    public class static PersistenceConfig
    {
        public static NServiceBus.PersistenceExtensions<T> UsePersistence<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition { }
        public static NServiceBus.PersistenceExtensions<T, S> UsePersistence<T, S>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition
            where S : NServiceBus.Persistence.StorageType { }
        public static NServiceBus.PersistenceExtensions UsePersistence(this NServiceBus.EndpointConfiguration config, System.Type definitionType) { }
    }
    public class PersistenceExtensions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public PersistenceExtensions(System.Type definitionType, NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
        [System.ObsoleteAttribute(@"Example: config.UsePersistence<InMemoryPersistence>().For(TimeoutStorage) should be changed to config.UsePersistence<InMemoryPersistence, Timeouts>(). Use `UsePersistence<T, S>() where T : PersistenceExtension where S : StorageType` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PersistenceExtensions For(params NServiceBus.Persistence.Storage[] specificStorages) { }
    }
    public class PersistenceExtensions<T> : NServiceBus.PersistenceExtensions
        where T : NServiceBus.Persistence.PersistenceDefinition
    {
        public PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        protected PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
        [System.ObsoleteAttribute("Example: config.UsePersistence<InMemoryPersistence>().For(TimeoutStorage) should " +
            "be changed to config.UsePersistence<InMemoryPersistence, Timeouts>(). Use `UsePe" +
            "rsistence<T, S>()` instead. Will be removed in version 7.0.0.", true)]
        public NServiceBus.PersistenceExtensions<T> For(params NServiceBus.Persistence.Storage[] specificStorages) { }
    }
    public class PersistenceExtensions<T, S> : NServiceBus.PersistenceExtensions<T>
        where T : NServiceBus.Persistence.PersistenceDefinition
        where S : NServiceBus.Persistence.StorageType
    {
        public PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    [System.ObsoleteAttribute("Use `PersistenceExtensions` instead. Will be removed in version 7.0.0.", true)]
    public class PersistenceExtentions
    {
        public PersistenceExtentions() { }
    }
    [System.ObsoleteAttribute("Use `PersistenceExtensions<T>` instead. Will be removed in version 7.0.0.", true)]
    public class PersistenceExtentions<T>
    {
        public PersistenceExtentions() { }
    }
    [System.ObsoleteAttribute("Use `PersistenceExtensions<T, S>` instead. Will be removed in version 7.0.0.", true)]
    public class PersistenceExtentions<T, S>
    {
        public PersistenceExtentions() { }
    }
    [System.ObsoleteAttribute("For performance reasons it is no longer possible to instrument the pipeline execu" +
        "tion. Will be removed in version 7.0.0.", true)]
    public class PipelineNotifications
    {
        public PipelineNotifications() { }
    }
    public class PublishOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public PublishOptions() { }
    }
    public class ReceivePipelineCompleted
    {
        public ReceivePipelineCompleted(NServiceBus.Transport.IncomingMessage processedMessage, System.DateTime startedAt, System.DateTime completedAt) { }
        public System.DateTime CompletedAt { get; }
        public NServiceBus.Transport.IncomingMessage ProcessedMessage { get; }
        public System.DateTime StartedAt { get; }
    }
    public class static ReceivePipelineConfigExtensions
    {
        public static void OnReceivePipelineCompleted(this NServiceBus.Pipeline.PipelineSettings pipelineSettings, System.Func<NServiceBus.ReceivePipelineCompleted, System.Threading.Tasks.Task> subscription) { }
    }
    public class static ReceiveSettingsExtensions
    {
        public static void MakeInstanceUniquelyAddressable(this NServiceBus.EndpointConfiguration config, string discriminator) { }
        public static void OverrideLocalAddress(this NServiceBus.EndpointConfiguration config, string baseInputQueueName) { }
    }
    public abstract class RecoverabilityAction
    {
        protected internal RecoverabilityAction() { }
        public static NServiceBus.DelayedRetry DelayedRetry(System.TimeSpan timeSpan) { }
        public static NServiceBus.ImmediateRetry ImmediateRetry() { }
        public static NServiceBus.MoveToError MoveToError(string errorQueue) { }
    }
    public class RecoverabilityConfig
    {
        public RecoverabilityConfig(NServiceBus.ImmediateConfig immediateConfig, NServiceBus.DelayedConfig delayedConfig, NServiceBus.FailedConfig failedConfig) { }
        public NServiceBus.DelayedConfig Delayed { get; }
        public NServiceBus.FailedConfig Failed { get; }
        public NServiceBus.ImmediateConfig Immediate { get; }
    }
    public class static RecoverabilityEndpointConfigurationExtensions
    {
        public static NServiceBus.RecoverabilitySettings Recoverability(this NServiceBus.EndpointConfiguration configuration) { }
    }
    public class RecoverabilitySettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.RecoverabilitySettings AddUnrecoverableException<T>()
            where T : System.Exception { }
        public NServiceBus.RecoverabilitySettings AddUnrecoverableException(System.Type exceptionType) { }
        public NServiceBus.RecoverabilitySettings CustomPolicy(System.Func<NServiceBus.RecoverabilityConfig, NServiceBus.Transport.ErrorContext, NServiceBus.RecoverabilityAction> custom) { }
        public NServiceBus.RecoverabilitySettings Delayed(System.Action<NServiceBus.DelayedRetriesSettings> customizations) { }
        public NServiceBus.RecoverabilitySettings DisableLegacyRetriesSatellite() { }
        public NServiceBus.RecoverabilitySettings Failed(System.Action<NServiceBus.RetryFailedSettings> customizations) { }
        public NServiceBus.RecoverabilitySettings Immediate(System.Action<NServiceBus.ImmediateRetriesSettings> customizations) { }
    }
    public class static RecoverabilitySettingsExtensions
    {
        public static void AddUnrecoverableException(this NServiceBus.Settings.SettingsHolder settings, System.Type exceptionType) { }
    }
    public class ReplyOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public ReplyOptions() { }
    }
    public class RetryFailedSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public NServiceBus.RetryFailedSettings HeaderCustomization(System.Action<System.Collections.Generic.Dictionary<string, string>> customization) { }
    }
    public class static RoutingFeatureSettingsExtensions
    {
        public static void OverridePublicReturnAddress(this NServiceBus.EndpointConfiguration configuration, string address) { }
    }
    public class static RoutingOptionExtensions
    {
        public static string GetDestination(this NServiceBus.ReplyOptions options) { }
        public static string GetDestination(this NServiceBus.SendOptions options) { }
        public static string GetReplyToRoute(this NServiceBus.ReplyOptions options) { }
        public static string GetReplyToRoute(this NServiceBus.SendOptions options) { }
        public static string GetRouteToSpecificInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToAnyInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToAnyInstance(this NServiceBus.ReplyOptions options) { }
        public static bool IsRoutingReplyToThisInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToThisInstance(this NServiceBus.ReplyOptions options) { }
        public static bool IsRoutingToThisEndpoint(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingToThisInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyTo(this NServiceBus.ReplyOptions options, string address) { }
        public static void RouteReplyTo(this NServiceBus.SendOptions options, string address) { }
        public static void RouteReplyToAnyInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyToAnyInstance(this NServiceBus.ReplyOptions options) { }
        public static void RouteReplyToThisInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyToThisInstance(this NServiceBus.ReplyOptions options) { }
        public static void RouteToSpecificInstance(this NServiceBus.SendOptions options, string instanceId) { }
        public static void RouteToThisEndpoint(this NServiceBus.SendOptions options) { }
        public static void RouteToThisInstance(this NServiceBus.SendOptions options) { }
        public static void SetDestination(this NServiceBus.SendOptions options, string destination) { }
        public static void SetDestination(this NServiceBus.ReplyOptions options, string destination) { }
    }
    public class RoutingSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public RoutingSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public void DoNotEnforceBestPractices() { }
        public void RouteToEndpoint(System.Type messageType, string destination) { }
        public void RouteToEndpoint(System.Reflection.Assembly assembly, string destination) { }
        public void RouteToEndpoint(System.Reflection.Assembly assembly, string @namespace, string destination) { }
    }
    public class RoutingSettings<T> : NServiceBus.RoutingSettings
        where T : NServiceBus.Transport.TransportDefinition
    {
        public RoutingSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class static RoutingSettingsExtensions
    {
        public static NServiceBus.RoutingSettings Routing(this NServiceBus.TransportExtensions config) { }
        public static NServiceBus.RoutingSettings<T> Routing<T>(this NServiceBus.TransportExtensions<T> config)
            where T : NServiceBus.Transport.TransportDefinition { }
    }
    public abstract class Saga
    {
        protected Saga() { }
        [System.ObsoleteAttribute("Sagas no longer provide access to bus operations via the .Bus property. Use the c" +
            "ontext parameter on the Handle method. The member currently throws a NotImplemen" +
            "tedException. Will be removed in version 7.0.0.", true)]
        public NServiceBus.IBus Bus { get; set; }
        public bool Completed { get; }
        public NServiceBus.IContainSagaData Entity { get; set; }
        protected internal abstract void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
        protected void MarkAsComplete() { }
        protected System.Threading.Tasks.Task ReplyToOriginator(NServiceBus.IMessageHandlerContext context, object message) { }
        [System.ObsoleteAttribute("Use `ReplyToOriginator(IMessageHandlerContext, object)` instead. The member curre" +
            "ntly throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        protected void ReplyToOriginator(object message) { }
        [System.ObsoleteAttribute("Construct the message and pass it to the non Action overload. Use `ReplyToOrigina" +
            "tor(IMessageHandlerContext, object)` instead. The member currently throws a NotI" +
            "mplementedException. Will be removed in version 7.0.0.", true)]
        protected virtual void ReplyToOriginator<TMessage>(System.Action<TMessage> messageConstructor) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTime at)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
        [System.ObsoleteAttribute("Use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, DateTime)` inste" +
            "ad. The member currently throws a NotImplementedException. Will be removed in ve" +
            "rsion 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at) { }
        [System.ObsoleteAttribute("Construct the message and pass it to the non Action overload. Use `RequestTimeout" +
            "<TTimeoutMessageType>(IMessageHandlerContext DateTime, TTimeoutMessageType)` ins" +
            "tead. The member currently throws a NotImplementedException. Will be removed in " +
            "version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at, System.Action<TTimeoutMessageType> action) { }
        [System.ObsoleteAttribute("Use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, DateTime, TTimeo" +
            "utMessageType)` instead. The member currently throws a NotImplementedException. " +
            "Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        [System.ObsoleteAttribute("Use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan)` inste" +
            "ad. The member currently throws a NotImplementedException. Will be removed in ve" +
            "rsion 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within) { }
        [System.ObsoleteAttribute(@"Construct the message and pass it to the non Action overload. Use `Saga.RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan, TTimeoutMessageType)` instead. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within, System.Action<TTimeoutMessageType> messageConstructor) { }
        [System.ObsoleteAttribute("Use `RequestTimeout<TTimeoutMessageType>(IMessageHandlerContext, TimeSpan, TTimeo" +
            "utMessageType)` instead. The member currently throws a NotImplementedException. " +
            "Will be removed in version 7.0.0.", true)]
        protected void RequestTimeout<TTimeoutMessageType>(System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
    }
    public abstract class Saga<TSagaData> : NServiceBus.Saga
        where TSagaData : NServiceBus.IContainSagaData, new ()
    {
        protected Saga() { }
        public TSagaData Data { get; set; }
        protected internal override void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration) { }
        protected abstract void ConfigureHowToFindSaga(NServiceBus.SagaPropertyMapper<TSagaData> mapper);
    }
    public class SagaPropertyMapper<TSagaData>
        where TSagaData : NServiceBus.IContainSagaData
    {
        public NServiceBus.ToSagaExpression<TSagaData, TMessage> ConfigureMapping<TMessage>(System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class static ScaleOutExtentions
    {
        [System.ObsoleteAttribute("The member currently throws a NotImplementedException. Will be removed in version" +
            " 7.0.0.", true)]
        public static NServiceBus.Settings.ScaleOutSettings ScaleOut(this NServiceBus.EndpointConfiguration config) { }
    }
    [System.ObsoleteAttribute("Use extension methods provided on ISendOnlyBus. Will be removed in version 7.0.0." +
        "", true)]
    public class Schedule
    {
        public Schedule() { }
    }
    public class ScheduledTask : NServiceBus.IMessage
    {
        public ScheduledTask() { }
        public System.TimeSpan Every { get; set; }
        public string Name { get; set; }
        public System.Guid TaskId { get; set; }
    }
    public class static ScheduleExtensions
    {
        [System.ObsoleteAttribute("Use `ScheduleEvery(this IMessageSession session, TimeSpan timeSpan, Func<IPipelin" +
            "eContext, Task> task)` instead. The member currently throws a NotImplementedExce" +
            "ption. Will be removed in version 7.0.0.", true)]
        public static void ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, System.Action task) { }
        [System.ObsoleteAttribute("Use `ScheduleEvery(this IMessageSession session, TimeSpan timeSpan, string name, " +
            "Func<IPipelineContext, Task> task)` instead. The member currently throws a NotIm" +
            "plementedException. Will be removed in version 7.0.0.", true)]
        public static void ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, string name, System.Action task) { }
        public static System.Threading.Tasks.Task ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, System.Func<NServiceBus.IPipelineContext, System.Threading.Tasks.Task> task) { }
        public static System.Threading.Tasks.Task ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, string name, System.Func<NServiceBus.IPipelineContext, System.Threading.Tasks.Task> task) { }
    }
    [System.ObsoleteAttribute("Use `endpointConfiguration.Recoverability().Delayed(delayed => )` instead. Will b" +
        "e removed in version 7.0.0.", true)]
    public class static SecondLevelRetriesConfigExtensions
    {
        [System.ObsoleteAttribute("Use `endpointConfiguration.Recoverability().Delayed(delayed => )` instead. The me" +
            "mber currently throws a NotImplementedException. Will be removed in version 7.0." +
            "0.", true)]
        public static NServiceBus.SecondLevelRetriesSettings SecondLevelRetries(this NServiceBus.EndpointConfiguration config) { }
    }
    [System.ObsoleteAttribute("Use `endpointConfiguration.Recoverability().CustomPolicy(Func<RecoverabilityConfi" +
        "g, ErrorContext, RecoverabilityAction> @custom)` instead. Will be removed in ver" +
        "sion 7.0.0.", true)]
    public class SecondLevelRetriesSettings
    {
        public SecondLevelRetriesSettings() { }
        [System.ObsoleteAttribute("Use `endpointConfiguration.Recoverability().CustomPolicy(Func<RecoverabilityConfi" +
            "g, ErrorContext, RecoverabilityAction> @custom)` instead. The member currently t" +
            "hrows a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void CustomRetryPolicy(System.Func<NServiceBus.TransportMessage, System.TimeSpan> customPolicy) { }
    }
    public class SendOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SendOptions() { }
    }
    public class static SerializationConfigExtensions
    {
        public static NServiceBus.Serialization.SerializationExtensions<T> AddDeserializer<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtensions<T> AddDeserializer<T>(this NServiceBus.EndpointConfiguration config, T serializationDefinition)
            where T : NServiceBus.Serialization.SerializationDefinition { }
        public static NServiceBus.Serialization.SerializationExtensions<T> UseSerialization<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtensions<T> UseSerialization<T>(this NServiceBus.EndpointConfiguration config, T serializationDefinition)
            where T : NServiceBus.Serialization.SerializationDefinition { }
        [System.ObsoleteAttribute("To use a custom serializer derive from SerializationDefinition and provide a fact" +
            "ory method for creating the serializer instance. The member currently throws a N" +
            "otImplementedException. Will be removed in version 7.0.0.", true)]
        public static void UseSerialization(this NServiceBus.EndpointConfiguration config, System.Type serializerType) { }
    }
    public class static SerializationContextExtensions
    {
        public static bool ShouldSkipSerialization(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context) { }
        public static void SkipSerialization(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context) { }
    }
    [System.ObsoleteAttribute("Use `SerializationExtensions<T>` instead. Will be removed in version 7.0.0.", true)]
    public class SerializationExtentions<T>
    {
        public SerializationExtentions() { }
    }
    public class static SettingsExtensions
    {
        public static string EndpointName(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static System.Collections.Generic.IList<System.Type> GetAvailableTypes(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static T GetConfigSection<T>(this NServiceBus.Settings.ReadOnlySettings settings)
            where T :  class, new () { }
        public static string InstanceSpecificQueue(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static string LocalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static NServiceBus.LogicalAddress LogicalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    [System.ObsoleteAttribute("Use `SettingsExtensions` instead. Will be removed in version 7.0.0.", true)]
    public class static SettingsExtentions { }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be treated as an error from version 7.0.0. Will be r" +
        "emoved in version 8.0.0.", false)]
    public class static SLAMonitoringConfig
    {
        [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
            "s.PerformanceCounters. Will be treated as an error from version 7.0.0. Will be r" +
            "emoved in version 8.0.0.", false)]
        public static void EnableSLAPerformanceCounter(this NServiceBus.EndpointConfiguration config, System.TimeSpan sla) { }
        [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
            "s.PerformanceCounters. Will be treated as an error from version 7.0.0. Will be r" +
            "emoved in version 8.0.0.", false)]
        public static void EnableSLAPerformanceCounter(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static StaticHeadersConfigExtensions
    {
        public static void AddHeaderToAllOutgoingMessages(this NServiceBus.EndpointConfiguration config, string key, string value) { }
    }
    public class SubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SubscribeOptions() { }
    }
    public class TimeoutManagerConfiguration
    {
        public TimeoutManagerConfiguration(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class static TimeoutManagerConfigurationExtensions
    {
        public static void LimitMessageProcessingConcurrencyTo(this NServiceBus.TimeoutManagerConfiguration timeoutManagerConfiguration, int maxConcurrency) { }
        public static NServiceBus.TimeoutManagerConfiguration TimeoutManager(this NServiceBus.EndpointConfiguration endpointConfiguration) { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class TimeToBeReceivedAttribute : System.Attribute
    {
        public TimeToBeReceivedAttribute(string timeSpan) { }
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class static TimeToBeReceivedConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningTimeToBeReceivedAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, System.TimeSpan> retrieveTimeToBeReceived) { }
    }
    public class ToSagaExpression<TSagaData, TMessage>
        where TSagaData : NServiceBus.IContainSagaData
    {
        public ToSagaExpression(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
        public void ToSaga(System.Linq.Expressions.Expression<System.Func<TSagaData, object>> sagaEntityProperty) { }
    }
    public class TransportExtensions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions ConnectionString(System.Func<string> connectionString) { }
        public NServiceBus.TransportExtensions ConnectionStringName(string name) { }
        public NServiceBus.TransportExtensions Transactions(NServiceBus.TransportTransactionMode transportTransactionMode) { }
    }
    public class TransportExtensions<T> : NServiceBus.TransportExtensions
        where T : NServiceBus.Transport.TransportDefinition
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(System.Func<string> connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionStringName(string name) { }
        public NServiceBus.TransportExtensions<T> Transactions(NServiceBus.TransportTransactionMode transportTransactionMode) { }
    }
    [System.ObsoleteAttribute("Not used anymore, use `OutgoingMessage` or `IncomingMessage` instead. Will be rem" +
        "oved in version 7.0.0.", true)]
    public class TransportMessage
    {
        public TransportMessage() { }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.Body\' or \'OutgoingMessage.Body\' instead. Th" +
            "e member currently throws a NotImplementedException. Will be removed in version " +
            "7.0.0.", true)]
        public byte[] Body { get; set; }
        [System.ObsoleteAttribute("Use the value of the \'NServiceBus.CorrelationId\' header instead. The member curre" +
            "ntly throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public string CorrelationId { get; set; }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.Headers\' or \'OutgoingMesssage.Headers\' inst" +
            "ead. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        [System.ObsoleteAttribute("Use the value of the \'IncomingMessage.MessageId\' or \'OutgoingMesssage.MessageId\' " +
            "instead. The member currently throws a NotImplementedException. Will be removed " +
            "in version 7.0.0.", true)]
        public string Id { get; }
        [System.ObsoleteAttribute("Use `GetMessageIntent(this IncomingMessage message)` instead. The member currentl" +
            "y throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public NServiceBus.MessageIntentEnum MessageIntent { get; }
        [System.ObsoleteAttribute(@"For sending purposes use `DeliveryConstraintContextExtensions.AddDeliveryConstraint(new NonDurableDelivery())` to set NonDurable delivery or `NonDurableDelivery constraint;DeliveryConstraintContextExtensions.TryGetDeliveryConstraint(out constraint)` to read wether NonDurable delivery is set. When receiving look at the new 'NServiceBus.NonDurableMessage' header. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public bool Recoverable { get; set; }
        [System.ObsoleteAttribute("Use `GetReplyToAddress(this IncomingMessage message)` instead. The member current" +
            "ly throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public string ReplyToAddress { get; }
        [System.ObsoleteAttribute(@"For sending purposes use `DeliveryConstraintContextExtensions.AddDeliveryConstraint(new DiscardIfNotReceivedBefore(timeToBeReceived))` to set the `TimeToBeReceived` or `DiscardIfNotReceivedBefore constraint;DeliveryConstraintContextExtensions.TryGetDeliveryConstraint(out constraint)` to read the `TimeToBeReceived`. When receiving look at the new 'NServiceBus.TimeToBeReceived' header. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan TimeToBeReceived { get; set; }
    }
    public enum TransportTransactionMode
    {
        None = 0,
        ReceiveOnly = 1,
        SendsAtomicWithReceive = 2,
        TransactionScope = 3,
    }
    public class UnitOfWorkSettings
    {
        public NServiceBus.UnitOfWorkSettings WrapHandlersInATransactionScope(System.Nullable<System.TimeSpan> timeout = null, System.Nullable<System.Transactions.IsolationLevel> isolationLevel = null) { }
    }
    public class static UnitOfWorkSettingsExtensions
    {
        public static NServiceBus.UnitOfWorkSettings UnitOfWork(this NServiceBus.EndpointConfiguration config) { }
    }
    public class UnsubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public UnsubscribeOptions() { }
    }
    public class static UseDataBusExtensions
    {
        public static NServiceBus.DataBus.DataBusExtensions<T> UseDataBus<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.DataBus.DataBusDefinition, new () { }
        public static NServiceBus.DataBus.DataBusExtensions UseDataBus(this NServiceBus.EndpointConfiguration config, System.Type dataBusType) { }
    }
    public class static UseTransportExtensions
    {
        public static NServiceBus.TransportExtensions<T> UseTransport<T>(this NServiceBus.EndpointConfiguration endpointConfiguration)
            where T : NServiceBus.Transport.TransportDefinition, new () { }
        public static NServiceBus.TransportExtensions UseTransport(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Type transportDefinitionType) { }
    }
    [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptedString` instead. Will be treated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
    public class WireEncryptedString : System.Runtime.Serialization.ISerializable
    {
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        public WireEncryptedString() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        public WireEncryptedString(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        [System.ObsoleteAttribute("No longer required. Will be removed in version 7.0.0.", true)]
        public string Base64Iv { get; set; }
        [System.ObsoleteAttribute("No longer required. Will be removed in version 7.0.0.", true)]
        public string EncryptedBase64Value { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        public NServiceBus.EncryptedValue EncryptedValue { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
            "removed in version 8.0.0.", false)]
        public string Value { get; set; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static XmlSerializationExtensions
    {
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> DontWrapRawXml(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config) { }
        [System.ObsoleteAttribute("Use `DontWrapRawXml(this SerializationExtensions<XmlSerializer> config)` instead." +
            " The member currently throws a NotImplementedException. Will be removed in versi" +
            "on 7.0.0.", true)]
        public static NServiceBus.SerializationExtentions<NServiceBus.XmlSerializer> DontWrapRawXml(this NServiceBus.SerializationExtentions<NServiceBus.XmlSerializer> config) { }
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> Namespace(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config, string namespaceToUse) { }
        [System.ObsoleteAttribute("Use `Namespace(this SerializationExtensions<XmlSerializer> config, string namespa" +
            "ceToUse)` instead. The member currently throws a NotImplementedException. Will b" +
            "e removed in version 7.0.0.", true)]
        public static NServiceBus.SerializationExtentions<NServiceBus.XmlSerializer> Namespace(this NServiceBus.SerializationExtentions<NServiceBus.XmlSerializer> config, string namespaceToUse) { }
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> SanitizeInput(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config) { }
        [System.ObsoleteAttribute("Use `SanitizeInput(this SerializationExtensions<XmlSerializer> config)` instead. " +
            "The member currently throws a NotImplementedException. Will be removed in versio" +
            "n 7.0.0.", true)]
        public static NServiceBus.SerializationExtentions<NServiceBus.XmlSerializer> SanitizeInput(this NServiceBus.SerializationExtentions<NServiceBus.XmlSerializer> config) { }
    }
    public class XmlSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public XmlSerializer() { }
        public override System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
}
namespace NServiceBus.AutomaticSubscriptions.Config
{
    public class AutoSubscribeSettings
    {
        [System.ObsoleteAttribute("Encourages bad practices. IMessageSession.Subscribe should be explicitly used. Th" +
            "e member currently throws a NotImplementedException. Will be removed in version " +
            "7.0.0.", true)]
        public void AutoSubscribePlainMessages() { }
        public void DoNotAutoSubscribeSagas() { }
        [System.ObsoleteAttribute("Transports with support for centralized pubsub will default this to true. Can saf" +
            "ely be removed. The member currently throws a NotImplementedException. Will be r" +
            "emoved in version 7.0.0.", true)]
        public void DoNotRequireExplicitRouting() { }
    }
}
namespace NServiceBus.Config
{
    [System.ObsoleteAttribute("Use of the application configuration file to configure auditing is discouraged. W" +
        "ill be treated as an error from version 7.0.0. Will be removed in version 8.0.0." +
        "", false)]
    public class AuditConfig : System.Configuration.ConfigurationSection
    {
        public AuditConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("OverrideTimeToBeReceived", IsRequired=false)]
        [System.ObsoleteAttribute("Use of the application configuration file to configure auditing is discouraged. U" +
            "se `EndpointConfiguration.AuditProcessedMessagesTo` instead. Will be treated as " +
            "an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public System.TimeSpan OverrideTimeToBeReceived { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("QueueName", IsRequired=false)]
        [System.ObsoleteAttribute("Use of the application configuration file to configure auditing is discouraged. U" +
            "se `EndpointConfiguration.AuditProcessedMessagesTo` instead. Will be treated as " +
            "an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public string QueueName { get; set; }
    }
    [System.ObsoleteAttribute("Use the feature concept instead via A class which inherits from `NServiceBus.Feat" +
        "ures.Feature` and use `configuration.EnableFeature<YourClass>()`. Will be remove" +
        "d in version 7.0.0.", true)]
    public interface IWantToRunWhenConfigurationIsComplete { }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
        "removed in version 8.0.0.", false)]
    public enum KeyFormat
    {
        Ascii = 0,
        Base64 = 1,
    }
    [System.ObsoleteAttribute("Logging configuration via configuration section is discouraged. Use `LogManager.U" +
        "se<DefaultFactory>()` instead. Will be treated as an error from version 7.0.0. W" +
        "ill be removed in version 8.0.0.", false)]
    public class Logging : System.Configuration.ConfigurationSection
    {
        public Logging() { }
        [System.Configuration.ConfigurationPropertyAttribute("Threshold", DefaultValue="Info", IsRequired=true)]
        [System.ObsoleteAttribute("Logging configuration via configuration section is discouraged. Use `LogManager.U" +
            "se<DefaultFactory>().Level(LogLevel)` instead. Will be treated as an error from " +
            "version 7.0.0. Will be removed in version 8.0.0.", false)]
        public string Threshold { get; set; }
    }
    [System.ObsoleteAttribute("Use `EndpointConfiguration.EnlistWithLegacyMSMQDistributor` instead. Will be remo" +
        "ved in version 7.0.0.", true)]
    public class MasterNodeConfig : System.Configuration.ConfigurationSection
    {
        public MasterNodeConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("Node", IsRequired=false)]
        [System.ObsoleteAttribute("Use `EndpointConfiguration.EnlistWithLegacyMSMQDistributor` instead. Will be remo" +
            "ved in version 7.0.0.", true)]
        public string Node { get; set; }
    }
    public class MessageEndpointMapping : System.Configuration.ConfigurationElement, System.IComparable<NServiceBus.Config.MessageEndpointMapping>
    {
        public MessageEndpointMapping() { }
        [System.Configuration.ConfigurationPropertyAttribute("Assembly", IsRequired=false)]
        public string AssemblyName { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Endpoint", IsRequired=true)]
        public string Endpoint { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Messages", IsRequired=false)]
        public string Messages { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Namespace", IsRequired=false)]
        public string Namespace { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Type", IsRequired=false)]
        public string TypeFullName { get; set; }
        public int CompareTo(NServiceBus.Config.MessageEndpointMapping other) { }
        public void Configure(System.Action<System.Type, string> mapTypeToEndpoint) { }
    }
    public class MessageEndpointMappingCollection : System.Configuration.ConfigurationElementCollection
    {
        public MessageEndpointMappingCollection() { }
        public new string AddElementName { get; set; }
        public new string ClearElementName { get; set; }
        public override System.Configuration.ConfigurationElementCollectionType CollectionType { get; }
        public new int Count { get; }
        public NServiceBus.Config.MessageEndpointMapping this[int index] { get; set; }
        public NServiceBus.Config.MessageEndpointMapping this[string Name] { get; }
        public new string RemoveElementName { get; }
        public void Add(NServiceBus.Config.MessageEndpointMapping mapping) { }
        protected override void BaseAdd(System.Configuration.ConfigurationElement element) { }
        public void Clear() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement(string elementName) { }
        protected override object GetElementKey(System.Configuration.ConfigurationElement element) { }
        public int IndexOf(NServiceBus.Config.MessageEndpointMapping mapping) { }
        public override bool IsReadOnly() { }
        public void Remove(NServiceBus.Config.MessageEndpointMapping mapping) { }
        public void Remove(string name) { }
        public void RemoveAt(int index) { }
    }
    [System.ObsoleteAttribute("Error queue configuration via configuration section is discouraged. Use `Endpoint" +
        "Configuration.SendFailedMessagesTo` instead. Will be treated as an error from ve" +
        "rsion 7.0.0. Will be removed in version 8.0.0.", false)]
    public class MessageForwardingInCaseOfFaultConfig : System.Configuration.ConfigurationSection
    {
        public MessageForwardingInCaseOfFaultConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("ErrorQueue", IsRequired=true)]
        [System.ObsoleteAttribute("Error queue configuration via configuration section is discouraged. Use `Endpoint" +
            "Configuration.SendFailedMessagesTo` instead. Will be treated as an error from ve" +
            "rsion 7.0.0. Will be removed in version 8.0.0.", false)]
        public string ErrorQueue { get; set; }
    }
    [System.ObsoleteAttribute("Configuring MSMQ subscription storage via configuration section is discouraged. U" +
        "se `EndpointConfiguration.UsePersistence<MsmqPersistence>()` instead. Will be tr" +
        "eated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
    public class MsmqSubscriptionStorageConfig : System.Configuration.ConfigurationSection
    {
        public MsmqSubscriptionStorageConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("Queue", IsRequired=true)]
        [System.ObsoleteAttribute("Configuring MSMQ subscription storage via configuration section is discouraged. U" +
            "se `EndpointConfiguration.UsePersistence<MsmqPersistence>().SubscriptionQueue` i" +
            "nstead. Will be treated as an error from version 7.0.0. Will be removed in versi" +
            "on 8.0.0.", false)]
        public string Queue { get; set; }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
        "removed in version 8.0.0.", false)]
    public class RijndaelEncryptionServiceConfig : System.Configuration.ConfigurationSection
    {
        public RijndaelEncryptionServiceConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("ExpiredKeys", IsRequired=false)]
        public NServiceBus.Config.RijndaelExpiredKeyCollection ExpiredKeys { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("Key", IsRequired=true)]
        public string Key { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("KeyFormat", IsRequired=false)]
        public NServiceBus.Config.KeyFormat KeyFormat { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("KeyIdentifier", IsRequired=false)]
        public string KeyIdentifier { get; set; }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
        "removed in version 8.0.0.", false)]
    public class RijndaelExpiredKey : System.Configuration.ConfigurationElement
    {
        public RijndaelExpiredKey() { }
        [System.Configuration.ConfigurationPropertyAttribute("Key", IsRequired=true)]
        public string Key { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("KeyFormat", IsRequired=false)]
        public NServiceBus.Config.KeyFormat KeyFormat { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("KeyIdentifier", IsRequired=false)]
        public string KeyIdentifier { get; set; }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be treated as an error from version 7.0.0. Will be " +
        "removed in version 8.0.0.", false)]
    public class RijndaelExpiredKeyCollection : System.Configuration.ConfigurationElementCollection
    {
        public RijndaelExpiredKeyCollection() { }
        public override System.Configuration.ConfigurationElementCollectionType CollectionType { get; }
        public NServiceBus.Config.RijndaelExpiredKey this[int index] { get; set; }
        public NServiceBus.Config.RijndaelExpiredKey this[string key] { get; }
        public void Add(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        protected override void BaseAdd(System.Configuration.ConfigurationElement element) { }
        public void Clear() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement() { }
        protected override System.Configuration.ConfigurationElement CreateNewElement(string elementName) { }
        protected override object GetElementKey(System.Configuration.ConfigurationElement element) { }
        public int IndexOf(NServiceBus.Config.RijndaelExpiredKey encryptionKey) { }
        public override bool IsReadOnly() { }
        public void Remove(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        public void Remove(string name) { }
        public void RemoveAt(int index) { }
    }
    [System.ObsoleteAttribute("Second Level Retries has been renamed to Delayed Retries. The app.config API has " +
        "been removed, use the code API via endpointConfiguration.Recoverability().Delaye" +
        "d(settings => ...);. Will be removed in version 7.0.0.", true)]
    public class SecondLevelRetriesConfig : System.Configuration.ConfigurationSection
    {
        public SecondLevelRetriesConfig() { }
        [System.ObsoleteAttribute(@"Second Level Retries has been renamed to Delayed Retries. The app.config API has been removed, use the code API via endpointConfiguration.Recoverability().Delayed(settings => ...);. To disable use endpointConfiguration.Recoverability().Delayed(settings => settings.NumberOfRetries(0));. Will be removed in version 7.0.0.", true)]
        public bool Enabled { get; set; }
        [System.ObsoleteAttribute(@"Second Level Retries has been renamed to Delayed Retries. The app.config API has been removed, use the code API via endpointConfiguration.Recoverability().Delayed(settings => ...);. To change the NumberOfRetries use endpointConfiguration.Recoverability().Delayed(settings => settings.NumberOfRetries(5);. Will be removed in version 7.0.0.", true)]
        public int NumberOfRetries { get; set; }
        [System.ObsoleteAttribute(@"Second Level Retries has been renamed to Delayed Retries. The app.config API has been removed, use the code API via endpointConfiguration.Recoverability().Delayed(settings => ...);. To change the TimeIncrease use endpointConfiguration.Recoverability().Delayed(settings => settings.TimeIncrease(TimeSpan.FromMinutes(5));. Will be removed in version 7.0.0.", true)]
        public System.TimeSpan TimeIncrease { get; set; }
    }
    [System.ObsoleteAttribute("The app.config API TransportConfig has been removed, use the code API. Will be re" +
        "moved in version 7.0.0.", true)]
    public class TransportConfig : System.Configuration.ConfigurationSection
    {
        public TransportConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("MaximumConcurrencyLevel", DefaultValue=0, IsRequired=false)]
        [System.ObsoleteAttribute("The app.config API TransportConfig has been removed, use the code API. To change " +
            "the concurrency level use endpointConfiguration.LimitMessageProcessingConcurrenc" +
            "yTo(1);. Will be removed in version 7.0.0.", true)]
        public int MaximumConcurrencyLevel { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MaximumMessageThroughputPerSecond", DefaultValue=-1, IsRequired=false)]
        [System.ObsoleteAttribute("Message throughput throttling has been removed. Consult the documentation for fur" +
            "ther information. Will be removed in version 7.0.0.", true)]
        public int MaximumMessageThroughputPerSecond { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MaxRetries", DefaultValue=5, IsRequired=false)]
        [System.ObsoleteAttribute("The app.config API TransportConfig has been removed, use the code API. To change " +
            "the NumberOfRetries use endpointConfiguration.Recoverability().Immediate(setting" +
            "s => settings.NumberOfRetries(5);. Will be removed in version 7.0.0.", true)]
        public int MaxRetries { get; set; }
    }
    [System.ObsoleteAttribute("Use of the application configuration file to configure the endpoint is discourage" +
        "d. Use the code first API instead. Will be treated as an error from version 7.0." +
        "0. Will be removed in version 8.0.0.", false)]
    public class UnicastBusConfig : System.Configuration.ConfigurationSection
    {
        public UnicastBusConfig() { }
        [System.Configuration.ConfigurationPropertyAttribute("DistributorControlAddress", IsRequired=false)]
        [System.ObsoleteAttribute("Switch to the code API by using \'EndpointConfiguration.EnlistWithLegacyMSMQDistri" +
            "butor\' instead. Will be removed in version 7.0.0.", true)]
        public string DistributorControlAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("DistributorDataAddress", IsRequired=false)]
        [System.ObsoleteAttribute("Switch to the code API by using \'EndpointConfiguration.EnlistWithLegacyMSMQDistri" +
            "butor\' instead. Will be removed in version 7.0.0.", true)]
        public string DistributorDataAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("ForwardReceivedMessagesTo", IsRequired=false)]
        [System.ObsoleteAttribute("Use \'EndpointConfiguration.ForwardReceivedMessagesTo\' to configure the forwarding" +
            " address. Will be removed in version 7.0.0.", true)]
        public string ForwardReceivedMessagesTo { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("MessageEndpointMappings", IsRequired=false)]
        [System.ObsoleteAttribute("Use of the application configuration file to configure routing is discouraged. Us" +
            "e `EndpointConfiguration.UseTransport<T>.Routing()` instead. Will be treated as " +
            "an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public NServiceBus.Config.MessageEndpointMappingCollection MessageEndpointMappings { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("TimeoutManagerAddress", IsRequired=false)]
        [System.ObsoleteAttribute("Use of the application configuration file to configure an external TimeoutManager" +
            " address is discouraged. Use `EndpointConfiguration.UseExternalTimeoutManager` i" +
            "nstead. Will be treated as an error from version 7.0.0. Will be removed in versi" +
            "on 8.0.0.", false)]
        public string TimeoutManagerAddress { get; set; }
        [System.Configuration.ConfigurationPropertyAttribute("TimeToBeReceivedOnForwardedMessages", IsRequired=false)]
        [System.ObsoleteAttribute("Use of the application configuration file to configure TimeToBeReceived in forwar" +
            "ded messages is discouraged. Will be treated as an error from version 7.0.0. Wil" +
            "l be removed in version 8.0.0.", false)]
        public System.TimeSpan TimeToBeReceivedOnForwardedMessages { get; set; }
    }
}
namespace NServiceBus.Config.ConfigurationSource
{
    public class DefaultConfigurationSource : NServiceBus.Config.ConfigurationSource.IConfigurationSource
    {
        public DefaultConfigurationSource() { }
    }
    [System.ObsoleteAttribute("The use of the IConfigurationSource is discouraged. Code configuration is prefere" +
        "d over configuration sources. Will be treated as an error from version 7.0.0. Wi" +
        "ll be removed in version 8.0.0.", false)]
    public interface IConfigurationSource
    {
        T GetConfiguration<T>()
            where T :  class, new ();
    }
    [System.ObsoleteAttribute("The use of the IConfigurationSource is discouraged. Code configuration is prefere" +
        "d over configuration sources. Will be treated as an error from version 7.0.0. Wi" +
        "ll be removed in version 8.0.0.", false)]
    public interface IProvideConfiguration<T>
    {
        T GetConfiguration();
    }
}
namespace NServiceBus.Configuration.AdvanceExtensibility
{
    public class static AdvanceExtensibilityExtensions
    {
        public static NServiceBus.Settings.SettingsHolder GetSettings(this NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings config) { }
    }
    public abstract class ExposeSettings
    {
        protected ExposeSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.ConsistencyGuarantees
{
    public class static TransactionModeSettingsExtensions
    {
        public static NServiceBus.TransportTransactionMode GetRequiredTransactionModeForReceives(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
}
namespace NServiceBus.Container
{
    public class ContainerCustomizations
    {
        public NServiceBus.Settings.SettingsHolder Settings { get; }
    }
    public abstract class ContainerDefinition
    {
        protected ContainerDefinition() { }
        public abstract NServiceBus.ObjectBuilder.Common.IContainer CreateContainer(NServiceBus.Settings.ReadOnlySettings settings);
    }
}
namespace NServiceBus.DataBus
{
    public abstract class DataBusDefinition
    {
        protected DataBusDefinition() { }
        protected internal abstract System.Type ProvidedByFeature();
    }
    public class DataBusExtensions : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public DataBusExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class DataBusExtensions<T> : NServiceBus.DataBus.DataBusExtensions
        where T : NServiceBus.DataBus.DataBusDefinition
    {
        public DataBusExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    [System.ObsoleteAttribute("Use `DataBusExtensions` instead. Will be removed in version 7.0.0.", true)]
    public class DataBusExtentions
    {
        public DataBusExtentions() { }
    }
    [System.ObsoleteAttribute("Use `DataBusExtensions<T>` instead. Will be removed in version 7.0.0.", true)]
    public class DataBusExtentions<T>
    {
        public DataBusExtentions() { }
    }
    public interface IDataBus
    {
        System.Threading.Tasks.Task<System.IO.Stream> Get(string key);
        System.Threading.Tasks.Task<string> Put(System.IO.Stream stream, System.TimeSpan timeToBeReceived);
        System.Threading.Tasks.Task Start();
    }
    public interface IDataBusSerializer
    {
        object Deserialize(System.IO.Stream stream);
        void Serialize(object databusProperty, System.IO.Stream stream);
    }
}
namespace NServiceBus.DelayedDelivery
{
    public class DelayDeliveryWith : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DelayDeliveryWith(System.TimeSpan delay) { }
        public System.TimeSpan Delay { get; }
    }
    public abstract class DelayedDeliveryConstraint : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        protected DelayedDeliveryConstraint() { }
    }
    public class DoNotDeliverBefore : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DoNotDeliverBefore(System.DateTime at) { }
        public System.DateTime At { get; }
    }
    public class static ExternalTimeoutManagerConfigurationExtensions
    {
        public static void UseExternalTimeoutManager(this NServiceBus.EndpointConfiguration endpointConfiguration, string externalTimeoutManagerAddress) { }
    }
}
namespace NServiceBus.DeliveryConstraints
{
    public abstract class DeliveryConstraint
    {
        protected DeliveryConstraint() { }
    }
    public class static DeliveryConstraintContextExtensions
    {
        public static void AddDeliveryConstraint(this NServiceBus.Extensibility.ContextBag context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> GetDeliveryConstraints(this NServiceBus.Extensibility.ContextBag context) { }
        public static void RemoveDeliveryConstaint(this NServiceBus.Extensibility.ContextBag context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static bool TryGetDeliveryConstraint<T>(this NServiceBus.Extensibility.ContextBag context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
        public static bool TryRemoveDeliveryConstraint<T>(this NServiceBus.Extensibility.ContextBag context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
    }
}
namespace NServiceBus.Extensibility
{
    public class ContextBag : NServiceBus.Extensibility.ReadOnlyContextBag
    {
        public ContextBag(NServiceBus.Extensibility.ContextBag parentBag = null) { }
        public T Get<T>() { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public void Remove<T>() { }
        public void Remove(string key) { }
        public void Set<T>(T t) { }
        public void Set<T>(string key, T t) { }
        public bool TryGet<T>(out T result) { }
        public bool TryGet<T>(string key, out T result) { }
    }
    public abstract class ExtendableOptions
    {
        protected ExtendableOptions() { }
    }
    public class static ExtendableOptionsExtensions
    {
        public static NServiceBus.Extensibility.ContextBag GetExtensions(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public interface IExtendable
    {
        NServiceBus.Extensibility.ContextBag Extensions { get; }
    }
    public interface ReadOnlyContextBag
    {
        T Get<T>();
        bool TryGet<T>(out T result);
        bool TryGet<T>(string key, out T result);
    }
}
namespace NServiceBus.Faults
{
    public class DelayedRetryMessage
    {
        public DelayedRetryMessage(System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public int RetryAttempt { get; }
    }
    public class ErrorsNotifications
    {
        [System.ObsoleteAttribute("Use `MessageHasBeenSentToDelayedRetries` instead. Will be removed in version 7.0." +
            "0.", true)]
        public System.EventHandler MessageHasBeenSentToSecondLevelRetries;
        [System.ObsoleteAttribute("Use `MessageHasFailedAnImmediateRetryAttempt` instead. Will be removed in version" +
            " 7.0.0.", true)]
        public System.EventHandler MessageHasFailedAFirstLevelRetryAttempt;
        public ErrorsNotifications() { }
        public event System.EventHandler<NServiceBus.Faults.DelayedRetryMessage> MessageHasBeenSentToDelayedRetries;
        public event System.EventHandler<NServiceBus.Faults.ImmediateRetryMessage> MessageHasFailedAnImmediateRetryAttempt;
        public event System.EventHandler<NServiceBus.Faults.FailedMessage> MessageSentToErrorQueue;
    }
    public class FailedMessage
    {
        [System.ObsoleteAttribute("Use `FailedMessage(string messageId, Dictionary<string, string> headers, byte[] b" +
            "ody, Exception exception, string errorQueue)` instead. The member currently thro" +
            "ws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public FailedMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception) { }
        public FailedMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, string errorQueue) { }
        public byte[] Body { get; }
        public string ErrorQueue { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static FaultsHeaderKeys
    {
        public const string FailedQ = "NServiceBus.FailedQ";
    }
    [System.ObsoleteAttribute("First Level Retries has been renamed to Immediate Retries. Use `NServiceBus.Fault" +
        "s.ImmediateRetryMessage` instead. Will be removed in version 7.0.0.", true)]
    public struct FirstLevelRetry { }
    [System.ObsoleteAttribute("IManageMessageFailures is no longer an extension point. To take control of the er" +
        "ror handling part of the message processing pipeline, review the Version 5 to 6 " +
        "upgrade guide for details. Will be removed in version 7.0.0.", true)]
    public interface IManageMessageFailures { }
    public class ImmediateRetryMessage
    {
        public ImmediateRetryMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public int RetryAttempt { get; }
    }
    [System.ObsoleteAttribute("Second Level Retries has been renamed to Delayed Retries. Use `NServiceBus.Faults" +
        ".DelayedRetryMessage` instead. Will be removed in version 7.0.0.", true)]
    public struct SecondLevelRetry { }
}
namespace NServiceBus.Features
{
    public class Audit : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class AutoSubscribe : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Use extensions provided by the TransportDefinition class instead. Will be removed" +
        " in version 7.0.0.", true)]
    public class ConfigureTransport
    {
        public ConfigureTransport() { }
    }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be treated as an error from version 7.0.0. Will be r" +
        "emoved in version 8.0.0.", false)]
    public class CriticalTimeMonitoring : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class DataBus : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Encryption is no longer enabled by default. Encryption gets enabled by calling co" +
        "nfiguration.RegisterEncryptionService or configuration.RijndaelEncryptionService" +
        ". Will be removed in version 7.0.0.", true)]
    public class Encryptor
    {
        public Encryptor() { }
    }
    public abstract class Feature
    {
        protected Feature() { }
        public bool IsActive { get; }
        public bool IsEnabledByDefault { get; }
        public string Name { get; }
        public string Version { get; }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> settings) { }
        protected void DependsOn<T>()
            where T : NServiceBus.Features.Feature { }
        protected void DependsOn(string featureTypeName) { }
        protected void DependsOnAtLeastOne(params System.Type[] features) { }
        protected void DependsOnAtLeastOne(params string[] featureNames) { }
        protected void DependsOnOptionally(string featureName) { }
        protected void DependsOnOptionally(System.Type featureType) { }
        protected void DependsOnOptionally<T>()
            where T : NServiceBus.Features.Feature { }
        protected void EnableByDefault() { }
        protected void Prerequisite(System.Func<NServiceBus.Features.FeatureConfigurationContext, bool> condition, string description) { }
        [System.ObsoleteAttribute("Use `FeatureConfigurationContext.RegisterStartupTask` instead. The member current" +
            "ly throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        protected void RegisterStartupTask<T>()
            where T : NServiceBus.Features.FeatureStartupTask { }
        protected internal abstract void Setup(NServiceBus.Features.FeatureConfigurationContext context);
        public override string ToString() { }
    }
    public class FeatureConfigurationContext
    {
        public NServiceBus.ObjectBuilder.IConfigureComponents Container { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        public NServiceBus.Settings.ReadOnlySettings Settings { get; }
        [System.ObsoleteAttribute(@"The satellite's transaction mode needs to match the endpoint's transaction mode. As such the 'requiredTransportTransactionMode' parameter is redundant and should be removed. Use `AddSatelliteReceiver(string name, string transportAddress, PushRuntimeSettings runtimeSettings, Func<RecoverabilityConfig, ErrorContext, RecoverabilityAction> recoverabilityPolicy, Func<IBuilder, MessageContext, Task> onMessage)` instead. Will be treated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public void AddSatelliteReceiver(string name, string transportAddress, NServiceBus.TransportTransactionMode requiredTransportTransactionMode, NServiceBus.Transport.PushRuntimeSettings runtimeSettings, System.Func<NServiceBus.RecoverabilityConfig, NServiceBus.Transport.ErrorContext, NServiceBus.RecoverabilityAction> recoverabilityPolicy, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Transport.MessageContext, System.Threading.Tasks.Task> onMessage) { }
        public void AddSatelliteReceiver(string name, string transportAddress, NServiceBus.Transport.PushRuntimeSettings runtimeSettings, System.Func<NServiceBus.RecoverabilityConfig, NServiceBus.Transport.ErrorContext, NServiceBus.RecoverabilityAction> recoverabilityPolicy, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Transport.MessageContext, System.Threading.Tasks.Task> onMessage) { }
        public void RegisterStartupTask<TTask>(TTask startupTask)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<NServiceBus.ObjectBuilder.IBuilder, TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
    }
    public abstract class FeatureStartupTask
    {
        protected FeatureStartupTask() { }
        protected abstract System.Threading.Tasks.Task OnStart(NServiceBus.IMessageSession session);
        protected abstract System.Threading.Tasks.Task OnStop(NServiceBus.IMessageSession session);
    }
    public enum FeatureState
    {
        Disabled = 0,
        Enabled = 1,
        Active = 2,
        Deactivated = 3,
    }
    [System.ObsoleteAttribute("FirstLevelRetries is no longer a separate feature. Please use endpointConfigurati" +
        "on.Recoverability().Immediate(cfg => cfg.NumberOfRetries(0)); to disable Immedia" +
        "te Retries. Will be removed in version 7.0.0.", true)]
    public class FirstLevelRetries : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class ForwardReceivedMessages : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryGatewayPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryOutboxPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySagaPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryTimeoutPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MessageDrivenSubscriptions : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class MsmqSubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Outbox : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be treated as an error from version 7.0.0. Will be r" +
        "emoved in version 8.0.0.", false)]
    public class ReceiveStatisticsPerformanceCounters : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Sagas : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Scheduler : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("SecondLevelRetries is no longer a separate feature. Please use endpointConfigurat" +
        "ion.Recoverability().Delayed(cfg => cfg.NumberOfRetries(0)) to disable Delayed R" +
        "etries. Will be removed in version 7.0.0.", true)]
    public class SecondLevelRetries : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Use the ConfigureSerialization Feature class instead. Use `ConfigureSerialization" +
        "` instead. Will be removed in version 7.0.0.", true)]
    public class static SerializationFeatureHelper { }
    public class static SettingsExtensions
    {
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault<T>(this NServiceBus.Settings.SettingsHolder settings)
            where T : NServiceBus.Features.Feature { }
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault(this NServiceBus.Settings.SettingsHolder settings, System.Type featureType) { }
        public static bool IsFeatureActive(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
        public static bool IsFeatureEnabled(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
    }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be treated as an error from version 7.0.0. Will be r" +
        "emoved in version 8.0.0.", false)]
    public class SLAMonitoring : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class StorageDrivenPublishing
    {
        public StorageDrivenPublishing() { }
    }
    public class TimeoutManager : NServiceBus.Features.Feature
    {
        protected internal override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class TimeoutManagerBasedDeferral
    {
        public TimeoutManagerBasedDeferral() { }
    }
}
namespace NServiceBus.Gateway.Deduplication
{
    public interface IDeduplicateMessages
    {
        System.Threading.Tasks.Task<bool> DeduplicateMessage(string clientId, System.DateTime timeReceived, NServiceBus.Extensibility.ContextBag context);
    }
}
namespace NServiceBus.Hosting.Helpers
{
    public class AssemblyScanner
    {
        public AssemblyScanner() { }
        public AssemblyScanner(string baseDirectoryToScan) { }
        [System.ObsoleteAttribute("This method is no longer required since deep scanning of assemblies is done to de" +
            "tect an NServiceBus reference. The member currently throws a NotImplementedExcep" +
            "tion. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.List<System.Reflection.Assembly> MustReferenceAtLeastOneAssembly { get; }
        public bool ScanAppDomainAssemblies { get; set; }
        public bool ThrowExceptions { get; set; }
        public NServiceBus.Hosting.Helpers.AssemblyScannerResults GetScannableAssemblies() { }
    }
    public class AssemblyScannerResults
    {
        public AssemblyScannerResults() { }
        public System.Collections.Generic.List<System.Reflection.Assembly> Assemblies { get; }
        public bool ErrorsThrownDuringScanning { get; }
        public System.Collections.Generic.List<NServiceBus.Hosting.Helpers.SkippedFile> SkippedFiles { get; }
        public System.Collections.Generic.List<System.Type> Types { get; }
    }
    public class SkippedFile
    {
        public string FilePath { get; }
        public string SkipReason { get; }
    }
}
namespace NServiceBus.Hosting
{
    public class HostInformation
    {
        public HostInformation(System.Guid hostId, string displayName) { }
        public HostInformation(System.Guid hostId, string displayName, System.Collections.Generic.Dictionary<string, string> properties) { }
        public string DisplayName { get; }
        public System.Guid HostId { get; }
        public System.Collections.Generic.Dictionary<string, string> Properties { get; }
    }
}
namespace NServiceBus.InMemory.Outbox
{
    public class static InMemoryOutboxSettingsExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings TimeToKeepDeduplicationData(this NServiceBus.Outbox.OutboxSettings settings, System.TimeSpan time) { }
    }
}
namespace NServiceBus.Installation
{
    public interface INeedToInstallSomething
    {
        System.Threading.Tasks.Task Install(string identity);
    }
}
namespace NServiceBus.Logging
{
    public class DefaultFactory : NServiceBus.Logging.LoggingFactoryDefinition
    {
        public DefaultFactory() { }
        public void Directory(string directory) { }
        protected internal override NServiceBus.Logging.ILoggerFactory GetLoggingFactory() { }
        public void Level(NServiceBus.Logging.LogLevel level) { }
    }
    public interface ILog
    {
        bool IsDebugEnabled { get; }
        bool IsErrorEnabled { get; }
        bool IsFatalEnabled { get; }
        bool IsInfoEnabled { get; }
        bool IsWarnEnabled { get; }
        void Debug(string message);
        void Debug(string message, System.Exception exception);
        void DebugFormat(string format, params object[] args);
        void Error(string message);
        void Error(string message, System.Exception exception);
        void ErrorFormat(string format, params object[] args);
        void Fatal(string message);
        void Fatal(string message, System.Exception exception);
        void FatalFormat(string format, params object[] args);
        void Info(string message);
        void Info(string message, System.Exception exception);
        void InfoFormat(string format, params object[] args);
        void Warn(string message);
        void Warn(string message, System.Exception exception);
        void WarnFormat(string format, params object[] args);
    }
    public interface ILoggerFactory
    {
        NServiceBus.Logging.ILog GetLogger(System.Type type);
        NServiceBus.Logging.ILog GetLogger(string name);
    }
    public abstract class LoggingFactoryDefinition
    {
        protected LoggingFactoryDefinition() { }
        protected internal abstract NServiceBus.Logging.ILoggerFactory GetLoggingFactory();
    }
    public enum LogLevel
    {
        Debug = 0,
        Info = 1,
        Warn = 2,
        Error = 3,
        Fatal = 4,
    }
    public class static LogManager
    {
        public static NServiceBus.Logging.ILog GetLogger<T>() { }
        public static NServiceBus.Logging.ILog GetLogger(System.Type type) { }
        public static NServiceBus.Logging.ILog GetLogger(string name) { }
        public static T Use<T>()
            where T : NServiceBus.Logging.LoggingFactoryDefinition, new () { }
        public static void UseFactory(NServiceBus.Logging.ILoggerFactory loggerFactory) { }
    }
}
namespace NServiceBus.MessageInterfaces
{
    public interface IMessageMapper : NServiceBus.IMessageCreator
    {
        System.Type GetMappedTypeFor(System.Type t);
        System.Type GetMappedTypeFor(string typeName);
        void Initialize(System.Collections.Generic.IEnumerable<System.Type> types);
    }
}
namespace NServiceBus.MessageInterfaces.MessageMapper.Reflection
{
    public class MessageMapper : NServiceBus.IMessageCreator, NServiceBus.MessageInterfaces.IMessageMapper
    {
        public MessageMapper() { }
        public T CreateInstance<T>(System.Action<T> action) { }
        public T CreateInstance<T>() { }
        public object CreateInstance(System.Type t) { }
        public System.Type GetMappedTypeFor(System.Type t) { }
        public System.Type GetMappedTypeFor(string typeName) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> types) { }
    }
}
namespace NServiceBus.MessageMutator
{
    [System.ObsoleteAttribute("Have the mutator implement both IMutateOutgoingMessages and IMutateIncomingMessag" +
        "es. Will be removed in version 7.0.0.", true)]
    public interface IMessageMutator { }
    public interface IMutateIncomingMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingMessageContext context);
    }
    public interface IMutateIncomingTransportMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingTransportMessageContext context);
    }
    public interface IMutateOutgoingMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingMessageContext context);
    }
    public interface IMutateOutgoingTransportMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingTransportMessageContext context);
    }
    [System.ObsoleteAttribute("Have the mutator implement both IMutateIncomingTransportMessages and IMutateOutgo" +
        "ingTransportMessages. Will be removed in version 7.0.0.", true)]
    public interface IMutateTransportMessages : NServiceBus.MessageMutator.IMutateIncomingTransportMessages, NServiceBus.MessageMutator.IMutateOutgoingTransportMessages { }
    public class MutateIncomingMessageContext
    {
        public MutateIncomingMessageContext(object message, System.Collections.Generic.Dictionary<string, string> headers) { }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public object Message { get; set; }
    }
    public class MutateIncomingTransportMessageContext
    {
        public MutateIncomingTransportMessageContext(byte[] body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public byte[] Body { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
    }
    public class MutateOutgoingMessageContext
    {
        public MutateOutgoingMessageContext(object outgoingMessage, System.Collections.Generic.Dictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public System.Collections.Generic.Dictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; set; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<, > incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
    public class MutateOutgoingTransportMessageContext
    {
        public MutateOutgoingTransportMessageContext(byte[] outgoingBody, object outgoingMessage, System.Collections.Generic.Dictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public byte[] OutgoingBody { get; set; }
        public System.Collections.Generic.Dictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<, > incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
    public class static MutatorRegistrationExtensions
    {
        public static void RegisterMessageMutator(this NServiceBus.EndpointConfiguration endpointConfiguration, object messageMutator) { }
    }
}
namespace NServiceBus.ObjectBuilder.Common
{
    public interface IContainer : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        NServiceBus.ObjectBuilder.Common.IContainer BuildChildContainer();
        void Configure(System.Type component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void Configure<T>(System.Func<T> component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        bool HasComponent(System.Type componentType);
        void RegisterSingleton(System.Type lookupType, object instance);
        void Release(object instance);
    }
}
namespace NServiceBus.ObjectBuilder
{
    public interface IBuilder : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        T Build<T>();
        System.Collections.Generic.IEnumerable<T> BuildAll<T>();
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        void BuildAndDispatch(System.Type typeToBuild, System.Action<object> action);
        NServiceBus.ObjectBuilder.IBuilder CreateChildBuilder();
        void Release(object instance);
    }
    [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
        "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
        "l over handler creation. Will be removed in version 7.0.0.", true)]
    public interface IComponentConfig { }
    [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
        "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
        "l over handler creation. Will be removed in version 7.0.0.", true)]
    public interface IComponentConfig<T> { }
    [System.ObsoleteAttribute("Setting property values explicitly is no longer supported via this API. Use `.Con" +
        "figureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full contro" +
        "l over handler creation. Will be removed in version 7.0.0.", true)]
    public class static IConfigureComponentObsoleteExtensions
    {
        [System.ObsoleteAttribute(@"Setting property values explicitly is no longer supported via this API. Use `.ConfigureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full control over handler creation. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.ObjectBuilder.IConfigureComponents ConfigureProperty<T>(this NServiceBus.ObjectBuilder.IConfigureComponents config, System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        [System.ObsoleteAttribute(@"Setting property values explicitly is no longer supported via this API. Use `.ConfigureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full control over handler creation. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.ObjectBuilder.IConfigureComponents ConfigureProperty<T>(this NServiceBus.ObjectBuilder.IConfigureComponents config, string propertyName, object value) { }
    }
    public interface IConfigureComponents
    {
        void ConfigureComponent(System.Type concreteComponent, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(System.Func<T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(System.Func<NServiceBus.ObjectBuilder.IBuilder, T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        bool HasComponent<T>();
        bool HasComponent(System.Type componentType);
        void RegisterSingleton(System.Type lookupType, object instance);
        void RegisterSingleton<T>(T instance);
    }
}
namespace NServiceBus.Outbox
{
    public interface IOutboxStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxTransaction> BeginTransaction(NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxMessage> Get(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task SetAsDispatched(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Store(NServiceBus.Outbox.OutboxMessage message, NServiceBus.Outbox.OutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context);
    }
    public class OutboxMessage
    {
        public OutboxMessage(string messageId, NServiceBus.Outbox.TransportOperation[] operations) { }
        public string MessageId { get; }
        public NServiceBus.Outbox.TransportOperation[] TransportOperations { get; }
    }
    public class OutboxSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        [System.ObsoleteAttribute("Use `InMemoryOutboxSettingsExtensions.TimeToKeepDeduplicationData(TimeSpan time)`" +
            " instead. The member currently throws a NotImplementedException. Will be removed" +
            " in version 7.0.0.", true)]
        public void TimeToKeepDeduplicationData(System.TimeSpan time) { }
    }
    public interface OutboxTransaction : System.IDisposable
    {
        System.Threading.Tasks.Task Commit();
    }
    public class TransportOperation
    {
        public TransportOperation(string messageId, System.Collections.Generic.Dictionary<string, string> options, byte[] body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public System.Collections.Generic.Dictionary<string, string> Options { get; }
    }
}
namespace NServiceBus.Performance.TimeToBeReceived
{
    public class DiscardIfNotReceivedBefore : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public DiscardIfNotReceivedBefore(System.TimeSpan maxTime) { }
        public System.TimeSpan MaxTime { get; }
    }
}
namespace NServiceBus.Persistence
{
    public interface CompletableSynchronizedStorageSession : NServiceBus.Persistence.SynchronizedStorageSession, System.IDisposable
    {
        System.Threading.Tasks.Task CompleteAsync();
    }
    public interface ISynchronizedStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> OpenSession(NServiceBus.Extensibility.ContextBag contextBag);
    }
    public interface ISynchronizedStorageAdapter
    {
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> TryAdapt(NServiceBus.Outbox.OutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> TryAdapt(NServiceBus.Transport.TransportTransaction transportTransaction, NServiceBus.Extensibility.ContextBag context);
    }
    public abstract class PersistenceDefinition
    {
        protected PersistenceDefinition() { }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> action) { }
        [System.ObsoleteAttribute("Use `HasSupportFor<T>()` instead. The member currently throws a NotImplementedExc" +
            "eption. Will be removed in version 7.0.0.", true)]
        public bool HasSupportFor(NServiceBus.Persistence.Storage storage) { }
        public bool HasSupportFor<T>()
            where T : NServiceBus.Persistence.StorageType { }
        public bool HasSupportFor(System.Type storageType) { }
        protected void Supports<T>(System.Action<NServiceBus.Settings.SettingsHolder> action)
            where T : NServiceBus.Persistence.StorageType { }
        [System.ObsoleteAttribute("Use `Supports<T>()` instead. The member currently throws a NotImplementedExceptio" +
            "n. Will be removed in version 7.0.0.", true)]
        protected void Supports(NServiceBus.Persistence.Storage storage, System.Action<NServiceBus.Settings.SettingsHolder> action) { }
    }
    [System.ObsoleteAttribute("Use `NServiceBus.Persistence.StorageType` instead. Will be removed in version 7.0" +
        ".0.", true)]
    public enum Storage
    {
        Timeouts = 1,
        Subscriptions = 2,
        Sagas = 3,
        GatewayDeduplication = 4,
        Outbox = 5,
    }
    public abstract class StorageType
    {
        public override string ToString() { }
        public sealed class GatewayDeduplication : NServiceBus.Persistence.StorageType { }
        public sealed class Outbox : NServiceBus.Persistence.StorageType { }
        public sealed class Sagas : NServiceBus.Persistence.StorageType { }
        public sealed class Subscriptions : NServiceBus.Persistence.StorageType { }
        public sealed class Timeouts : NServiceBus.Persistence.StorageType { }
    }
    public interface SynchronizedStorageSession { }
}
namespace NServiceBus.Persistence.Legacy
{
    public class MsmqPersistence : NServiceBus.Persistence.PersistenceDefinition { }
    public class static MsmqSubscriptionStorageConfigurationExtensions
    {
        public static void SubscriptionQueue(this NServiceBus.PersistenceExtensions<NServiceBus.Persistence.Legacy.MsmqPersistence> persistenceExtensions, string queue) { }
    }
}
namespace NServiceBus.Pipeline
{
    public abstract class Behavior<TContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TContext, TContext>
        where TContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected Behavior() { }
        public System.Threading.Tasks.Task Invoke(TContext context, System.Func<TContext, System.Threading.Tasks.Task> next) { }
        public abstract System.Threading.Tasks.Task Invoke(TContext context, System.Func<System.Threading.Tasks.Task> next);
    }
    public abstract class ForkConnector<TFromContext, TForkContext> : NServiceBus.Pipeline.Behavior<TFromContext>, NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TFromContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TForkContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected ForkConnector() { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<System.Threading.Tasks.Task> next, System.Func<TForkContext, System.Threading.Tasks.Task> fork);
        public virtual System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<System.Threading.Tasks.Task> next) { }
    }
    public interface IAuditContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        string AuditAddress { get; }
        NServiceBus.Transport.OutgoingMessage Message { get; }
        void AddAuditData(string key, string value);
    }
    public interface IBatchDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> Operations { get; }
    }
    public interface IBehavior { }
    [System.ObsoleteAttribute("Use `Behavior<T>` instead. Will be removed in version 7.0.0.", true)]
    public interface IBehavior<in TContext> { }
    public interface IBehavior<in TInContext, out TOutContext> : NServiceBus.Pipeline.IBehavior
        where in TInContext : NServiceBus.Pipeline.IBehaviorContext
        where out TOutContext : NServiceBus.Pipeline.IBehaviorContext
    {
        System.Threading.Tasks.Task Invoke(TInContext context, System.Func<TOutContext, System.Threading.Tasks.Task> next);
    }
    public interface IBehaviorContext : NServiceBus.Extensibility.IExtendable
    {
        NServiceBus.ObjectBuilder.IBuilder Builder { get; }
    }
    public interface IDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.IEnumerable<NServiceBus.Transport.TransportOperation> Operations { get; }
    }
    public interface IForwardingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        string Address { get; }
        NServiceBus.Transport.OutgoingMessage Message { get; }
    }
    public interface IIncomingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext { }
    public interface IIncomingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        NServiceBus.Pipeline.LogicalMessage Message { get; }
        bool MessageHandled { get; set; }
        void UpdateMessageInstance(object newInstance);
    }
    public interface IIncomingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        NServiceBus.Transport.IncomingMessage Message { get; }
        void UpdateMessage(byte[] body);
    }
    public interface IInvokeHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageHandlerContext, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        bool HandleCurrentMessageLaterWasCalled { get; }
        bool HandlerInvocationAborted { get; }
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        object MessageBeingHandled { get; }
        NServiceBus.Pipeline.MessageHandler MessageHandler { get; }
        NServiceBus.Unicast.Messages.MessageMetadata MessageMetadata { get; }
    }
    public interface IOutgoingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        string MessageId { get; }
    }
    public interface IOutgoingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessage(object newInstance);
    }
    public interface IOutgoingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        byte[] Body { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessage(byte[] body);
    }
    public interface IOutgoingPublishContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IOutgoingReplyContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IOutgoingSendContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IRoutingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transport.OutgoingMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; set; }
    }
    public interface ISubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Type EventType { get; }
    }
    public interface ITransportReceiveContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transport.IncomingMessage Message { get; }
        void AbortReceiveOperation();
    }
    public interface IUnsubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Type EventType { get; }
    }
    public class LogicalMessage
    {
        public LogicalMessage(NServiceBus.Unicast.Messages.MessageMetadata metadata, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Unicast.Messages.MessageMetadata Metadata { get; }
        [System.ObsoleteAttribute("Use `IIncomingLogicalMessageContext.UpdateMessageInstance(object newInstance)` in" +
            "stead. The member currently throws a NotImplementedException. Will be removed in" +
            " version 7.0.0.", true)]
        public void UpdateMessageInstance(object newInstance) { }
    }
    public class LogicalMessageFactory
    {
        public LogicalMessageFactory(NServiceBus.Unicast.Messages.MessageMetadataRegistry messageMetadataRegistry, NServiceBus.MessageInterfaces.IMessageMapper messageMapper) { }
        public NServiceBus.Pipeline.LogicalMessage Create(object message) { }
        public NServiceBus.Pipeline.LogicalMessage Create(System.Type messageType, object message) { }
    }
    public class MessageHandler
    {
        public MessageHandler(System.Func<object, object, NServiceBus.IMessageHandlerContext, System.Threading.Tasks.Task> invocation, System.Type handlerType) { }
        public System.Type HandlerType { get; }
        public object Instance { get; set; }
        public System.Threading.Tasks.Task Invoke(object message, NServiceBus.IMessageHandlerContext handlerContext) { }
    }
    public class OutgoingLogicalMessage
    {
        public OutgoingLogicalMessage(System.Type messageType, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
    }
    [System.ObsoleteAttribute("The pipeline context is no longer avaliable via dependency injection. Use a custo" +
        "m behavior as described in the version 6 upgrade guide. Will be removed in versi" +
        "on 7.0.0.", true)]
    public class PipelineExecutor
    {
        public PipelineExecutor() { }
    }
    public class PipelineSettings : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
    {
        public void Register(System.Type behavior, string description) { }
        public void Register(string stepId, System.Type behavior, string description) { }
        public void Register<T>(System.Func<NServiceBus.ObjectBuilder.IBuilder, T> factoryMethod, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(string stepId, System.Func<NServiceBus.ObjectBuilder.IBuilder, T> factoryMethod, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(T behavior, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(string stepId, T behavior, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<TRegisterStep>()
            where TRegisterStep : NServiceBus.Pipeline.RegisterStep, new () { }
        public void Register(NServiceBus.Pipeline.RegisterStep registration) { }
        public void Remove(string stepId) { }
        [System.ObsoleteAttribute("Use `Remove(string stepId)` instead. The member currently throws a NotImplemented" +
            "Exception. Will be removed in version 7.0.0.", true)]
        public void Remove(NServiceBus.Pipeline.WellKnownStep wellKnownStep) { }
        public void Replace(string stepId, System.Type newBehavior, string description = null) { }
        public void Replace<T>(string stepId, T newBehavior, string description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Replace<T>(string stepId, System.Func<NServiceBus.ObjectBuilder.IBuilder, T> factoryMethod, string description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
        [System.ObsoleteAttribute("Use `Replace(string stepId, Type newBehavior, string description)` instead. The m" +
            "ember currently throws a NotImplementedException. Will be removed in version 7.0" +
            ".0.", true)]
        public void Replace(NServiceBus.Pipeline.WellKnownStep wellKnownStep, System.Type newBehavior, string description = null) { }
    }
    public abstract class PipelineTerminator<T> : NServiceBus.Pipeline.StageConnector<T, NServiceBus.Pipeline.PipelineTerminator<T>.ITerminatingContext>
        where T : NServiceBus.Pipeline.IBehaviorContext
    {
        protected PipelineTerminator() { }
        public virtual System.Threading.Tasks.Task Invoke(T context, System.Func<NServiceBus.Pipeline.PipelineTerminator<T>.ITerminatingContext, System.Threading.Tasks.Task> next) { }
        protected abstract System.Threading.Tasks.Task Terminate(T context);
        public interface ITerminatingContext<T> : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
            where T : NServiceBus.Pipeline.IBehaviorContext { }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{StepId}({BehaviorType.FullName}) - {Description}")]
    public abstract class RegisterStep
    {
        protected RegisterStep(string stepId, System.Type behavior, string description, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Pipeline.IBehavior> factoryMethod = null) { }
        public System.Type BehaviorType { get; }
        public string Description { get; }
        public string StepId { get; }
        public void InsertAfter(string id) { }
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. The member currently throws a Not" +
            "ImplementedException. Will be removed in version 7.0.0.", true)]
        public void InsertAfter(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertAfterIfExists(string id) { }
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. The member currently throws a Not" +
            "ImplementedException. Will be removed in version 7.0.0.", true)]
        public void InsertAfterIfExists(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertBefore(string id) { }
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. The member currently throws a Not" +
            "ImplementedException. Will be removed in version 7.0.0.", true)]
        public void InsertBefore(NServiceBus.Pipeline.WellKnownStep step) { }
        public void InsertBeforeIfExists(string id) { }
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. The member currently throws a Not" +
            "ImplementedException. Will be removed in version 7.0.0.", true)]
        public void InsertBeforeIfExists(NServiceBus.Pipeline.WellKnownStep step) { }
        public virtual bool IsEnabled(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public abstract class StageConnector<TFromContext, TToContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TToContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TToContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected StageConnector() { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> stage);
    }
    public abstract class StageForkConnector<TFromContext, TToContext, TForkContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TToContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TToContext : NServiceBus.Pipeline.IBehaviorContext
        where TForkContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected StageForkConnector() { }
        public System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> next) { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> stage, System.Func<TForkContext, System.Threading.Tasks.Task> fork);
    }
    public class static TransportMessageContextExtensions
    {
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingReplyContext context, out NServiceBus.Transport.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context, out NServiceBus.Transport.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingPhysicalMessageContext context, out NServiceBus.Transport.IncomingMessage message) { }
    }
    [System.ObsoleteAttribute("WellKnownSteps are obsolete. Use an appropriate pipeline stage for your behavior " +
        "instead. Consult the pipeline extension documentation for more information. Will" +
        " be removed in version 7.0.0.", true)]
    public class WellKnownStep
    {
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep AuditProcessedMessage;
        [System.ObsoleteAttribute("The child container creation is now an integral part of the pipeline invocation a" +
            "nd no longer a separate behavior. Will be removed in version 7.0.0.", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep CreateChildContainer;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep DispatchMessageToTransport;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforcePublishBestPractices;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceReplyBestPractices;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceSendBestPractices;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceSubscribeBestPractices;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep EnforceUnsubscribeBestPractices;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep ExecuteUnitOfWork;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static NServiceBus.Pipeline.WellKnownStep HostInformation;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep InvokeHandlers;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep InvokeSaga;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateIncomingMessages;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateIncomingTransportMessage;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateOutgoingMessages;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static readonly NServiceBus.Pipeline.WellKnownStep MutateOutgoingTransportMessage;
        [System.ObsoleteAttribute("Use an appropriate pipeline stage for your behavior instead. Consult the pipeline" +
            " extension documentation for more information. Will be removed in version 7.0.0." +
            "", true)]
        public static NServiceBus.Pipeline.WellKnownStep ProcessingStatistics;
        public WellKnownStep() { }
    }
}
namespace NServiceBus.Pipeline.Contexts
{
    [System.ObsoleteAttribute("Use `OutgoingLogicalMessage` instead. Will be removed in version 7.0.0.", true)]
    public class OutgoingContext
    {
        public OutgoingContext() { }
    }
}
namespace NServiceBus.Routing
{
    public abstract class AddressTag
    {
        protected AddressTag() { }
    }
    public class DistributionContext : NServiceBus.Extensibility.IExtendable
    {
        public DistributionContext(string[] receiverAddresses, NServiceBus.Pipeline.OutgoingLogicalMessage message, string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.Func<NServiceBus.Routing.EndpointInstance, string> addressTranslation, NServiceBus.Extensibility.ContextBag extensions) { }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
        public string MessageId { get; }
        public string[] ReceiverAddresses { get; }
        public string ToTransportAddress(NServiceBus.Routing.EndpointInstance endpointInstance) { }
    }
    public abstract class DistributionStrategy
    {
        protected DistributionStrategy(string endpoint, NServiceBus.DistributionStrategyScope scope) { }
        public string Endpoint { get; }
        public NServiceBus.DistributionStrategyScope Scope { get; }
        public virtual string SelectDestination(NServiceBus.Routing.DistributionContext context) { }
        public abstract string SelectReceiver(string[] receiverAddresses);
    }
    public sealed class EndpointInstance
    {
        public EndpointInstance(string endpoint, string discriminator = null, System.Collections.Generic.IReadOnlyDictionary<string, string> properties = null) { }
        public string Discriminator { get; }
        public string Endpoint { get; }
        public System.Collections.Generic.IReadOnlyDictionary<string, string> Properties { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public NServiceBus.Routing.EndpointInstance SetProperty(string key, string value) { }
        public override string ToString() { }
    }
    public class EndpointInstances
    {
        public EndpointInstances() { }
        public void AddOrReplaceInstances(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.EndpointInstance> endpointInstances) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Routing.EndpointInstance> FindInstances(string endpoint) { }
    }
    public interface IMessageDrivenSubscriptionTransport { }
    public class MulticastAddressTag : NServiceBus.Routing.AddressTag
    {
        public MulticastAddressTag(System.Type messageType) { }
        public System.Type MessageType { get; }
    }
    public class MulticastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public MulticastRoutingStrategy(System.Type messageType) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public class RouteTableEntry
    {
        public RouteTableEntry(System.Type messageType, NServiceBus.Routing.UnicastRoute route) { }
        public System.Type MessageType { get; }
        public NServiceBus.Routing.UnicastRoute Route { get; }
    }
    public abstract class RoutingStrategy
    {
        protected RoutingStrategy() { }
        public abstract NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers);
    }
    public class SingleInstanceRoundRobinDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public SingleInstanceRoundRobinDistributionStrategy(string endpoint, NServiceBus.DistributionStrategyScope scope) { }
        public override string SelectReceiver(string[] receiverAddresses) { }
    }
    public class UnicastAddressTag : NServiceBus.Routing.AddressTag
    {
        public UnicastAddressTag(string destination) { }
        public string Destination { get; }
    }
    public class UnicastRoute
    {
        public string Endpoint { get; }
        public NServiceBus.Routing.EndpointInstance Instance { get; }
        public string PhysicalAddress { get; }
        public static NServiceBus.Routing.UnicastRoute CreateFromEndpointInstance(NServiceBus.Routing.EndpointInstance instance) { }
        public static NServiceBus.Routing.UnicastRoute CreateFromEndpointName(string endpoint) { }
        public static NServiceBus.Routing.UnicastRoute CreateFromPhysicalAddress(string physicalAddress) { }
        public override string ToString() { }
    }
    public class UnicastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public UnicastRoutingStrategy(string destination) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public class UnicastRoutingTable
    {
        public UnicastRoutingTable() { }
        public void AddOrReplaceRoutes(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.RouteTableEntry> entries) { }
    }
}
namespace NServiceBus.Routing.Legacy
{
    public class static ConfigureMSMQDistributor
    {
        public static void EnlistWithLegacyMSMQDistributor(this NServiceBus.EndpointConfiguration config, string masterNodeAddress, string masterNodeControlAddress, int capacity) { }
    }
}
namespace NServiceBus.Routing.MessageDrivenSubscriptions
{
    public class PublisherAddress
    {
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromEndpointInstances(params NServiceBus.Routing.EndpointInstance[] instances) { }
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromEndpointName(string endpoint) { }
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromPhysicalAddresses(params string[] addresses) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class Publishers
    {
        public Publishers() { }
        public void AddOrReplacePublishers(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.MessageDrivenSubscriptions.PublisherTableEntry> entries) { }
    }
    public class PublisherTableEntry
    {
        public PublisherTableEntry(System.Type eventType, NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress address) { }
        public NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress Address { get; }
        public System.Type EventType { get; }
    }
}
namespace NServiceBus.Routing.StorageDrivenPublishing
{
    [System.ObsoleteAttribute("No longer an extension point, if you want to list events without subscribers you " +
        "can take a dependency on ISubscriptionStorage and query it for the event types y" +
        "ou want to check. Will be removed in version 7.0.0.", true)]
    public class SubscribersForEvent
    {
        public SubscribersForEvent(System.Collections.Generic.List<string> subscribers, System.Type eventType) { }
        public System.Type EventType { get; }
        public System.Collections.Generic.IEnumerable<string> Subscribers { get; }
    }
}
namespace NServiceBus.Sagas
{
    public class ActiveSagaInstance
    {
        public ActiveSagaInstance(NServiceBus.Saga saga, NServiceBus.Sagas.SagaMetadata metadata, System.Func<System.DateTime> currentUtcDateTimeProvider) { }
        public System.DateTime Created { get; }
        public NServiceBus.Saga Instance { get; }
        public bool IsNew { get; }
        public System.DateTime Modified { get; }
        public bool NotFound { get; }
        public string SagaId { get; }
        [System.ObsoleteAttribute("Use `.Metadata.SagaType` instead. The member currently throws a NotImplementedExc" +
            "eption. Will be removed in version 7.0.0.", true)]
        public System.Type SagaType { get; }
        public void AttachNewEntity(NServiceBus.IContainSagaData sagaEntity) { }
    }
    public interface IFinder { }
    public abstract class IFindSagas<T>
        where T : NServiceBus.IContainSagaData
    {
        protected IFindSagas() { }
        public interface Using<T, M> : NServiceBus.Sagas.IFinder
            where T : NServiceBus.IContainSagaData
        {
            System.Threading.Tasks.Task<T> FindBy(M message, NServiceBus.Persistence.SynchronizedStorageSession storageSession, NServiceBus.Extensibility.ReadOnlyContextBag context);
        }
    }
    public interface IHandleSagaNotFound
    {
        System.Threading.Tasks.Task Handle(object message, NServiceBus.IMessageProcessingContext context);
    }
    public interface ISagaIdGenerator
    {
        System.Guid Generate(NServiceBus.Sagas.SagaIdGeneratorContext context);
    }
    public interface ISagaPersister
    {
        System.Threading.Tasks.Task Complete(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(System.Guid sagaId, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context)
            where TSagaData : NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(string propertyName, object propertyValue, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context)
            where TSagaData : NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task Save(NServiceBus.IContainSagaData sagaData, NServiceBus.Sagas.SagaCorrelationProperty correlationProperty, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Update(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
    }
    public class SagaCorrelationProperty
    {
        public SagaCorrelationProperty(string name, object value) { }
        public string Name { get; }
        public static NServiceBus.Sagas.SagaCorrelationProperty None { get; }
        public object Value { get; }
    }
    public class SagaFinderDefinition
    {
        public System.Type MessageType { get; }
        public string MessageTypeName { get; }
        public System.Collections.Generic.Dictionary<string, object> Properties { get; }
        public System.Type Type { get; }
    }
    public class SagaIdGeneratorContext : NServiceBus.Extensibility.IExtendable
    {
        public SagaIdGeneratorContext(NServiceBus.Sagas.SagaCorrelationProperty correlationProperty, NServiceBus.Sagas.SagaMetadata sagaMetadata, NServiceBus.Extensibility.ContextBag extensions) { }
        public NServiceBus.Sagas.SagaCorrelationProperty CorrelationProperty { get; }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public NServiceBus.Sagas.SagaMetadata SagaMetadata { get; }
    }
    public class SagaMessage
    {
        public bool IsAllowedToStartSaga { get; }
        public System.Type MessageType { get; }
        public string MessageTypeName { get; }
    }
    public class SagaMetadata
    {
        public SagaMetadata(string name, System.Type sagaType, string entityName, System.Type sagaEntityType, NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata correlationProperty, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> messages, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> finders) { }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> AssociatedMessages { get; }
        public string EntityName { get; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> Finders { get; }
        public string Name { get; }
        public System.Type SagaEntityType { get; }
        public System.Type SagaType { get; }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType) { }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType, System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
        public bool IsMessageAllowedToStartTheSaga(string messageType) { }
        public bool TryGetCorrelationProperty(out NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata property) { }
        public bool TryGetFinder(string messageType, out NServiceBus.Sagas.SagaFinderDefinition finderDefinition) { }
        public class CorrelationPropertyMetadata
        {
            public CorrelationPropertyMetadata(string name, System.Type type) { }
            public string Name { get; }
            public System.Type Type { get; }
        }
    }
    public class SagaMetadataCollection : System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMetadata>, System.Collections.IEnumerable
    {
        public SagaMetadataCollection() { }
        public NServiceBus.Sagas.SagaMetadata Find(System.Type sagaType) { }
        public NServiceBus.Sagas.SagaMetadata FindByEntity(System.Type entityType) { }
        public System.Collections.Generic.IEnumerator<NServiceBus.Sagas.SagaMetadata> GetEnumerator() { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
    }
    [System.ObsoleteAttribute("There is no need for this attribute anymore, all mapped properties are automatica" +
        "lly correlated. Will be removed in version 7.0.0.", true)]
    public sealed class UniqueAttribute : System.Attribute
    {
        public UniqueAttribute() { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. The member currently throws a NotImplementedException. " +
            "Will be removed in version 7.0.0.", true)]
        public static System.Collections.Generic.IDictionary<string, object> GetUniqueProperties(NServiceBus.IContainSagaData entity) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. The member currently throws a NotImplementedException. " +
            "Will be removed in version 7.0.0.", true)]
        public static System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> GetUniqueProperties(System.Type type) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. The member currently throws a NotImplementedException. " +
            "Will be removed in version 7.0.0.", true)]
        public static System.Reflection.PropertyInfo GetUniqueProperty(System.Type type) { }
        [System.ObsoleteAttribute("Use the new SagaMetadata. The member currently throws a NotImplementedException. " +
            "Will be removed in version 7.0.0.", true)]
        public static System.Nullable<System.Collections.Generic.KeyValuePair<string, object>> GetUniqueProperty(NServiceBus.IContainSagaData entity) { }
    }
}
namespace NServiceBus.Satellites
{
    [System.ObsoleteAttribute("No longer an extension point. Instead create a Feature and use FeatureConfigurati" +
        "onContext.AddSatelliteReceiver(...). Will be removed in version 7.0.0.", true)]
    public interface IAdvancedSatellite { }
    [System.ObsoleteAttribute("No longer an extension point. Instead create a Feature and use FeatureConfigurati" +
        "onContext.AddSatelliteReceiver(...). Will be removed in version 7.0.0.", true)]
    public interface ISatellite { }
}
namespace NServiceBus.SecondLevelRetries.Config
{
    [System.ObsoleteAttribute("Use `NServiceBus.SecondLevelRetriesSettings` instead. Will be removed in version " +
        "7.0.0.", true)]
    public class SecondLevelRetriesSettings
    {
        public SecondLevelRetriesSettings() { }
        [System.ObsoleteAttribute("Use `NServiceBus.SecondLevelRetriesSettings.CustomRetryPolicy(Func<IncomingMessag" +
            "e, TimeSpan> customPolicy)` instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 7.0.0.", true)]
        public void CustomRetryPolicy(System.Func<NServiceBus.TransportMessage, System.TimeSpan> customPolicy) { }
    }
}
namespace NServiceBus.Serialization
{
    [System.ObsoleteAttribute("To use a custom serializer derive from SerializationDefinition and provide a fact" +
        "ory method for creating the serializer instance. Will be removed in version 7.0." +
        "0.", true)]
    public abstract class ConfigureSerialization
    {
        protected ConfigureSerialization() { }
    }
    public interface IMessageSerializer
    {
        string ContentType { get; }
        object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypes = null);
        void Serialize(object message, System.IO.Stream stream);
    }
    public abstract class SerializationDefinition
    {
        protected SerializationDefinition() { }
        public abstract System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings);
    }
    public class SerializationExtensions<T> : NServiceBus.Configuration.AdvanceExtensibility.ExposeSettings
        where T : NServiceBus.Serialization.SerializationDefinition
    {
        public SerializationExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.Serializers.Json
{
    [System.ObsoleteAttribute("Built-in serializers are internal. Switch to an alternative (e.g. Json.net) or co" +
        "py the serializer code. Will be removed in version 7.0.0.", true)]
    public class JsonMessageSerializer
    {
        public JsonMessageSerializer() { }
    }
}
namespace NServiceBus.Serializers.XML
{
    [System.ObsoleteAttribute("Built-in serializers are internal. Switch to an  alternative (e.g. XmlSerializer)" +
        " or copy the serializer code. Will be removed in version 7.0.0.", true)]
    public class XmlMessageSerializer
    {
        public XmlMessageSerializer() { }
    }
}
namespace NServiceBus.Settings.NServiceBus
{
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class static TransactionSettingsExtentions
    {
        [System.ObsoleteAttribute("No longer used, can safely be removed. The member currently throws a NotImplement" +
            "edException. Will be removed in version 7.0.0.", true)]
        public static NServiceBus.Settings.TransactionSettings Transactions(this NServiceBus.EndpointConfiguration config) { }
    }
}
namespace NServiceBus.Settings
{
    public interface ReadOnlySettings
    {
        T Get<T>();
        T Get<T>(string key);
        object Get(string key);
        T GetOrDefault<T>();
        T GetOrDefault<T>(string key);
        bool HasExplicitValue(string key);
        bool HasExplicitValue<T>();
        bool HasSetting(string key);
        bool HasSetting<T>();
        bool TryGet<T>(out T val);
        bool TryGet<T>(string key, out T val);
    }
    public class static ReadOnlySettingsExtensions
    {
        [System.ObsoleteAttribute(@"Setting property values explicitly is no longer supported via this API. Use `.ConfigureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full control over handler creation. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public static void ApplyTo<T>(NServiceBus.ObjectBuilder.IComponentConfig config) { }
        [System.ObsoleteAttribute(@"Setting property values explicitly is no longer supported via this API. Use `.ConfigureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full control over handler creation. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public static void ApplyTo(System.Type componentType, NServiceBus.ObjectBuilder.IComponentConfig config) { }
    }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class ScaleOutSettings
    {
        public ScaleOutSettings() { }
        [System.ObsoleteAttribute("Not required any more as for MSMQ this is the default behavior and for other tran" +
            "sports the unique instance ID has to be provided. The member currently throws a " +
            "NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void UniqueQueuePerEndpointInstance() { }
        [System.ObsoleteAttribute("Use `EndpointConfiguration.MakeInstanceUniquelyAddressable(string discriminator)`" +
            " instead. The member currently throws a NotImplementedException. Will be removed" +
            " in version 7.0.0.", true)]
        public void UniqueQueuePerEndpointInstance(string discriminator) { }
        [System.ObsoleteAttribute("This is the default starting with V6. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 7.0.0.", true)]
        public void UseSingleBrokerQueue() { }
        [System.ObsoleteAttribute("Not required any more as for MSMQ this is the default behavior and for other tran" +
            "sports the unique instance ID has to be provided. The member currently throws a " +
            "NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void UseUniqueBrokerQueuePerMachine() { }
    }
    public class SettingsHolder : NServiceBus.Settings.ReadOnlySettings
    {
        public SettingsHolder() { }
        [System.ObsoleteAttribute(@"Setting property values explicitly is no longer supported via this API. Use `.ConfigureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full control over handler creation. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void ApplyTo<T>(NServiceBus.ObjectBuilder.IComponentConfig config) { }
        [System.ObsoleteAttribute(@"Setting property values explicitly is no longer supported via this API. Use `.ConfigureComponent(b=> new MyMessageHandler(){ MyProperty = X})` to get full control over handler creation. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void ApplyTo(System.Type componentType, NServiceBus.ObjectBuilder.IComponentConfig config) { }
        public void Clear() { }
        public T Get<T>(string key) { }
        public T Get<T>() { }
        public object Get(string key) { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public T GetOrDefault<T>() { }
        public T GetOrDefault<T>(string key) { }
        public bool HasExplicitValue(string key) { }
        public bool HasExplicitValue<T>() { }
        public bool HasSetting(string key) { }
        public bool HasSetting<T>() { }
        public void Set(string key, object value) { }
        public void Set<T>(object value) { }
        public void Set<T>(System.Action value) { }
        public void SetDefault<T>(object value) { }
        public void SetDefault<T>(System.Action value) { }
        public void SetDefault(string key, object value) { }
        [System.ObsoleteAttribute("Use `Set(string key, object value)` instead. The member currently throws a NotImp" +
            "lementedException. Will be removed in version 7.0.0.", true)]
        public void SetProperty<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        [System.ObsoleteAttribute("Use `Set(string key, object value)` instead. The member currently throws a NotImp" +
            "lementedException. Will be removed in version 7.0.0.", true)]
        public void SetPropertyDefault<T>(System.Linq.Expressions.Expression<System.Func<T, object>> property, object value) { }
        public bool TryGet<T>(out T val) { }
        public bool TryGet<T>(string key, out T val) { }
    }
    public class TransactionSettings
    {
        public TransactionSettings() { }
        [System.ObsoleteAttribute("Use `config.UnitOfWork().WrapHandlersInATransactionScope(timeout: TimeSpan.FromSe" +
            "conds(X));` instead. The member currently throws a NotImplementedException. Will" +
            " be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings DefaultTimeout(System.TimeSpan defaultTimeout) { }
        [System.ObsoleteAttribute("Use `config.UseTransport<MyTransport>().Transactions(TransportTransactionMode.Non" +
            "e);` instead. The member currently throws a NotImplementedException. Will be rem" +
            "oved in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings Disable() { }
        [System.ObsoleteAttribute("Use `config.UseTransport<MyTransport>().Transactions(TransportTransactionMode.Rec" +
            "eiveOnly|TransportTransactionMode.SendsAtomicWithReceive);` instead. The member " +
            "currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings DisableDistributedTransactions() { }
        [System.ObsoleteAttribute(@"DoNotWrapHandlersExecutionInATransactionScope() has been removed since transaction scopes are no longer used by non DTC transports delay the dispatch of all outgoing operations until handlers have been executed.\r\nIn Version 6 handlers will only be wrapped in a transactionscope if running the MSMQ or SQLServer transports in default mode. This means that performing storage operations against data sources also supporting transaction scopes\r\nwill escalate to a distributed transaction. Previous versions allowed opting out of this behavior using config.Transactions().DoNotWrapHandlersExecutionInATransactionScope(). In Version 6 it's recommended to use `EndpointConfiguration.UseTransport<MyTransport>().Transactions(TransportTransactionMode.ReceiveOnly)` to lean on native transport transaction and the new batched dispatch support to achieve the same level of consistency with better performance.\r\nSuppressing the ambient transaction created by the MSMQ and SQL Server transports can still be achieved by creating a custom pipeline behavior with a suppressed transaction scope. The member currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings DoNotWrapHandlersExecutionInATransactionScope() { }
        [System.ObsoleteAttribute("Use `config.UseTransport<MyTransport>().Transactions(TransportTransactionMode.Rec" +
            "eiveOnly|TransportTransactionMode.SendsAtomicWithReceive);` instead. The member " +
            "currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings Enable() { }
        [System.ObsoleteAttribute("Use `config.UseTransport<MyTransport>().Transactions(TransportTransactionMode.Tra" +
            "nsactionScope);` instead. The member currently throws a NotImplementedException." +
            " Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings EnableDistributedTransactions() { }
        [System.ObsoleteAttribute("Use `config.UnitOfWork().WrapHandlersInATransactionScope(isolationLevel: Isolatio" +
            "nLevel.X);` instead. The member currently throws a NotImplementedException. Will" +
            " be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings IsolationLevel(System.Transactions.IsolationLevel isolationLevel) { }
        [System.ObsoleteAttribute("Use `config.UnitOfWork().WrapHandlersInATransactionScope();` instead. The member " +
            "currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Settings.TransactionSettings WrapHandlersExecutionInATransactionScope() { }
    }
}
namespace NServiceBus.Support
{
    public class static RuntimeEnvironment
    {
        public static string MachineName { get; }
        public static System.Func<string> MachineNameAction { get; set; }
    }
}
namespace NServiceBus.Timeout.Core
{
    public interface IPersistTimeouts
    {
        System.Threading.Tasks.Task Add(NServiceBus.Timeout.Core.TimeoutData timeout, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutData> Peek(string timeoutId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task RemoveTimeoutBy(System.Guid sagaId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<bool> TryRemove(string timeoutId, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IQueryTimeouts
    {
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutsChunk> GetNextChunk(System.DateTime startSlice);
    }
    public class TimeoutData
    {
        [System.ObsoleteAttribute("Not used anymore. Will be removed in version 7.0.0.", true)]
        public const string OriginalReplyToAddress = "NServiceBus.Timeout.ReplyToAddress";
        public TimeoutData() { }
        public string Destination { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
        public string Id { get; set; }
        public string OwningTimeoutManager { get; set; }
        public System.Guid SagaId { get; set; }
        public byte[] State { get; set; }
        public System.DateTime Time { get; set; }
        [System.ObsoleteAttribute("Use new SendOptions() instead. The member currently throws a NotImplementedExcept" +
            "ion. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Unicast.SendOptions ToSendOptions(NServiceBus.Address replyToAddress) { }
        [System.ObsoleteAttribute("Use new SendOptions() instead. The member currently throws a NotImplementedExcept" +
            "ion. Will be removed in version 7.0.0.", true)]
        public NServiceBus.Unicast.SendOptions ToSendOptions(string replyToAddress) { }
        public override string ToString() { }
        [System.ObsoleteAttribute("Use new OutgoingMessage(timeoutData.State) instead. The member currently throws a" +
            " NotImplementedException. Will be removed in version 7.0.0.", true)]
        public NServiceBus.TransportMessage ToTransportMessage() { }
    }
    public class TimeoutsChunk
    {
        public TimeoutsChunk(Timeout[] dueTimeouts, System.DateTime nextTimeToQuery) { }
        public Timeout[] DueTimeouts { get; }
        public System.DateTime NextTimeToQuery { get; }
        public struct Timeout
        {
            public Timeout(string id, System.DateTime dueTime) { }
            public System.DateTime DueTime { get; }
            public string Id { get; }
        }
    }
}
namespace NServiceBus.Transport
{
    public enum DispatchConsistency
    {
        Default = 1,
        Isolated = 2,
    }
    public class ErrorContext
    {
        public ErrorContext(System.Exception exception, System.Collections.Generic.Dictionary<string, string> headers, string transportMessageId, byte[] body, NServiceBus.Transport.TransportTransaction transportTransaction, int immediateProcessingFailures) { }
        public int DelayedDeliveriesPerformed { get; }
        public System.Exception Exception { get; }
        public int ImmediateProcessingFailures { get; }
        public NServiceBus.Transport.IncomingMessage Message { get; }
        public NServiceBus.Transport.TransportTransaction TransportTransaction { get; }
    }
    public enum ErrorHandleResult
    {
        Handled = 0,
        RetryRequired = 1,
    }
    public interface ICancelDeferredMessages
    {
        System.Threading.Tasks.Task CancelDeferredMessages(string messageKey, NServiceBus.Pipeline.IBehaviorContext context);
    }
    public interface ICreateQueues
    {
        System.Threading.Tasks.Task CreateQueueIfNecessary(NServiceBus.Transport.QueueBindings queueBindings, string identity);
    }
    public interface IDispatchMessages
    {
        System.Threading.Tasks.Task Dispatch(NServiceBus.Transport.TransportOperations outgoingMessages, NServiceBus.Transport.TransportTransaction transaction, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IManageSubscriptions
    {
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
    }
    public class IncomingMessage
    {
        public IncomingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static IncomingMessageExtensions
    {
        public static NServiceBus.MessageIntentEnum GetMesssageIntent(this NServiceBus.Transport.IncomingMessage message) { }
        public static string GetReplyToAddress(this NServiceBus.Transport.IncomingMessage message) { }
    }
    public interface IOutgoingTransportOperation
    {
        System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        NServiceBus.Transport.OutgoingMessage Message { get; }
        NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
    public interface IPushMessages
    {
        System.Threading.Tasks.Task Init(System.Func<NServiceBus.Transport.MessageContext, System.Threading.Tasks.Task> onMessage, System.Func<NServiceBus.Transport.ErrorContext, System.Threading.Tasks.Task<NServiceBus.Transport.ErrorHandleResult>> onError, NServiceBus.CriticalError criticalError, NServiceBus.Transport.PushSettings settings);
        void Start(NServiceBus.Transport.PushRuntimeSettings limitations);
        System.Threading.Tasks.Task Stop();
    }
    public class static LogicalAddressExtensions
    {
        public static string GetTransportAddress(this NServiceBus.Settings.ReadOnlySettings settings, NServiceBus.LogicalAddress logicalAddress) { }
    }
    public class MessageContext : NServiceBus.Extensibility.IExtendable
    {
        public MessageContext(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, NServiceBus.Transport.TransportTransaction transportTransaction, System.Threading.CancellationTokenSource receiveCancellationTokenSource, NServiceBus.Extensibility.ContextBag context) { }
        public byte[] Body { get; }
        [System.ObsoleteAttribute("Use `Extensions` instead. Will be treated as an error from version 7.0.0. Will be" +
            " removed in version 7.0.0.", false)]
        public NServiceBus.Extensibility.ContextBag Context { get; }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public System.Threading.CancellationTokenSource ReceiveCancellationTokenSource { get; }
        public NServiceBus.Transport.TransportTransaction TransportTransaction { get; }
    }
    public class MulticastTransportOperation : NServiceBus.Transport.IOutgoingTransportOperation
    {
        public MulticastTransportOperation(NServiceBus.Transport.OutgoingMessage message, System.Type messageType, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
    public class OutboundRoutingPolicy
    {
        public OutboundRoutingPolicy(NServiceBus.Transport.OutboundRoutingType sends, NServiceBus.Transport.OutboundRoutingType publishes, NServiceBus.Transport.OutboundRoutingType replies) { }
        public NServiceBus.Transport.OutboundRoutingType Publishes { get; }
        public NServiceBus.Transport.OutboundRoutingType Replies { get; }
        public NServiceBus.Transport.OutboundRoutingType Sends { get; }
    }
    public enum OutboundRoutingType
    {
        Unicast = 0,
        Multicast = 1,
    }
    public class OutgoingMessage
    {
        public OutgoingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class PushRuntimeSettings
    {
        public PushRuntimeSettings() { }
        public PushRuntimeSettings(int maxConcurrency) { }
        public static NServiceBus.Transport.PushRuntimeSettings Default { get; }
        public int MaxConcurrency { get; }
    }
    public class PushSettings
    {
        public PushSettings(string inputQueue, string errorQueue, bool purgeOnStartup, NServiceBus.TransportTransactionMode requiredTransactionMode) { }
        public string ErrorQueue { get; }
        public string InputQueue { get; }
        public bool PurgeOnStartup { get; }
        public NServiceBus.TransportTransactionMode RequiredTransactionMode { get; }
    }
    public class QueueBindings
    {
        public QueueBindings() { }
        public System.Collections.Generic.IReadOnlyCollection<string> ReceivingAddresses { get; }
        public System.Collections.Generic.IReadOnlyCollection<string> SendingAddresses { get; }
        public void BindReceiving(string address) { }
        public void BindSending(string transportAddress) { }
    }
    public class StartupCheckResult
    {
        public static readonly NServiceBus.Transport.StartupCheckResult Success;
        public string ErrorMessage { get; }
        public bool Succeeded { get; }
        public static NServiceBus.Transport.StartupCheckResult Failed(string errorMessage) { }
    }
    public abstract class TransportDefinition
    {
        protected TransportDefinition() { }
        public abstract string ExampleConnectionStringForErrorMessage { get; }
        [System.ObsoleteAttribute("Use TransportInfrastructure.OutboundRoutingPolicy.Publishes == OutboundRoutingTyp" +
            "e.Multicast instead. The member currently throws a NotImplementedException. Will" +
            " be removed in version 7.0.0.", true)]
        public bool HasNativePubSubSupport { get; set; }
        [System.ObsoleteAttribute("The concept of centralized publish and subscribe is no longer available. The memb" +
            "er currently throws a NotImplementedException. Will be removed in version 7.0.0." +
            "", true)]
        public bool HasSupportForCentralizedPubSub { get; set; }
        [System.ObsoleteAttribute("Use TransportInfrastructure.TransactionMode == TransportTransactionMode.Transacti" +
            "onScope instead. The member currently throws a NotImplementedException. Will be " +
            "removed in version 7.0.0.", true)]
        public System.Nullable<bool> HasSupportForDistributedTransactions { get; set; }
        [System.ObsoleteAttribute("Use TransportInfrastructure.TransactionMode == TransportTransactionMode.SendsAtom" +
            "icWithReceive instead. The member currently throws a NotImplementedException. Wi" +
            "ll be removed in version 7.0.0.", true)]
        public bool HasSupportForMultiQueueNativeTransactions { get; set; }
        public virtual bool RequiresConnectionString { get; }
        public abstract NServiceBus.Transport.TransportInfrastructure Initialize(NServiceBus.Settings.SettingsHolder settings, string connectionString);
    }
    public abstract class TransportInfrastructure
    {
        protected TransportInfrastructure() { }
        public abstract System.Collections.Generic.IEnumerable<System.Type> DeliveryConstraints { get; }
        public abstract NServiceBus.Transport.OutboundRoutingPolicy OutboundRoutingPolicy { get; }
        [System.ObsoleteAttribute("The outbox consent is no longer required. It is safe to ignore this property. Wil" +
            "l be treated as an error from version 7.0.0. Will be removed in version 8.0.0.", false)]
        public bool RequireOutboxConsent { get; set; }
        public abstract NServiceBus.TransportTransactionMode TransactionMode { get; }
        public abstract NServiceBus.Routing.EndpointInstance BindToLocalEndpoint(NServiceBus.Routing.EndpointInstance instance);
        public abstract NServiceBus.Transport.TransportReceiveInfrastructure ConfigureReceiveInfrastructure();
        public abstract NServiceBus.Transport.TransportSendInfrastructure ConfigureSendInfrastructure();
        public abstract NServiceBus.Transport.TransportSubscriptionInfrastructure ConfigureSubscriptionInfrastructure();
        public virtual string MakeCanonicalForm(string transportAddress) { }
        public virtual System.Threading.Tasks.Task Start() { }
        public virtual System.Threading.Tasks.Task Stop() { }
        public abstract string ToTransportAddress(NServiceBus.LogicalAddress logicalAddress);
    }
    public class TransportOperation
    {
        public TransportOperation(NServiceBus.Transport.OutgoingMessage message, NServiceBus.Routing.AddressTag addressTag, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public NServiceBus.Routing.AddressTag AddressTag { get; }
        public System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; set; }
    }
    public class TransportOperations
    {
        public TransportOperations(params NServiceBus.Transport.TransportOperation[] transportOperations) { }
        public System.Collections.Generic.List<NServiceBus.Transport.MulticastTransportOperation> MulticastTransportOperations { get; }
        public System.Collections.Generic.List<NServiceBus.Transport.UnicastTransportOperation> UnicastTransportOperations { get; }
    }
    public class TransportReceiveInfrastructure
    {
        public TransportReceiveInfrastructure(System.Func<NServiceBus.Transport.IPushMessages> messagePumpFactory, System.Func<NServiceBus.Transport.ICreateQueues> queueCreatorFactory, System.Func<System.Threading.Tasks.Task<NServiceBus.Transport.StartupCheckResult>> preStartupCheck) { }
        public System.Func<NServiceBus.Transport.IPushMessages> MessagePumpFactory { get; }
        public System.Func<NServiceBus.Transport.ICreateQueues> QueueCreatorFactory { get; }
    }
    public class TransportSendInfrastructure
    {
        public TransportSendInfrastructure(System.Func<NServiceBus.Transport.IDispatchMessages> dispatcherFactory, System.Func<System.Threading.Tasks.Task<NServiceBus.Transport.StartupCheckResult>> preStartupCheck) { }
        public System.Func<NServiceBus.Transport.IDispatchMessages> DispatcherFactory { get; }
    }
    public class TransportSubscriptionInfrastructure
    {
        public TransportSubscriptionInfrastructure(System.Func<NServiceBus.Transport.IManageSubscriptions> subscriptionManagerFactory) { }
    }
    public sealed class TransportTransaction : NServiceBus.Extensibility.ContextBag
    {
        public TransportTransaction() { }
    }
    public class UnicastTransportOperation : NServiceBus.Transport.IOutgoingTransportOperation
    {
        public UnicastTransportOperation(NServiceBus.Transport.OutgoingMessage message, string destination, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public string Destination { get; }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
}
namespace NServiceBus.Transport.Msmq
{
    public class HeaderInfo
    {
        public HeaderInfo() { }
        public string Key { get; set; }
        public string Value { get; set; }
    }
}
namespace NServiceBus.Transports
{
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public interface IAuditMessages { }
    [System.ObsoleteAttribute("Use `NServiceBus.Transport.IDispatchMessages` instead. Will be removed in version" +
        " 7.0.0.", true)]
    public interface IDeferMessages
    {
        [System.ObsoleteAttribute("Use `NServiceBus.Transport.ICancelDeferredMessages` instead. Will be removed in v" +
            "ersion 7.0.0.", true)]
        void ClearDeferredMessages(string headerKey, string headerValue);
    }
    [System.ObsoleteAttribute("Use `NServiceBus.Transport.IPushMessages` instead. Will be removed in version 7.0" +
        ".0.", true)]
    public interface IDequeueMessages
    {
        void Init(NServiceBus.Address address, NServiceBus.Unicast.Transport.TransactionSettings transactionSettings, System.Func<NServiceBus.TransportMessage, bool> tryProcessMessage, System.Action<NServiceBus.TransportMessage, System.Exception> endProcessMessage);
        void Start(int maximumConcurrencyLevel);
        void Stop();
    }
    [System.ObsoleteAttribute("Use `NServiceBus.Transport.IDispatchMessages` instead. Will be removed in version" +
        " 7.0.0.", true)]
    public interface IPublishMessages { }
    [System.ObsoleteAttribute("Use `NServiceBus.Transport.IDispatchMessages` instead. Will be removed in version" +
        " 7.0.0.", true)]
    public interface ISendMessages
    {
        void Send(NServiceBus.TransportMessage message, NServiceBus.Unicast.SendOptions sendOptions);
    }
    [System.ObsoleteAttribute("The namespace NServiceBus.Transports was renamed to NServiceBus.Transport. Use `N" +
        "ServiceBus.Transport.TransportDefinition` instead. Will be removed in version 7." +
        "0.0.", true)]
    public abstract class TransportDefinition
    {
        protected TransportDefinition() { }
    }
}
namespace NServiceBus.Transports.Msmq.Config
{
    [System.ObsoleteAttribute("No longer available, see the documentation for native sends for alternative solut" +
        "ions. Will be removed in version 7.0.0.", true)]
    public class MsmqSettings
    {
        public MsmqSettings() { }
    }
}
namespace NServiceBus.Transports.Msmq
{
    [System.ObsoleteAttribute("No longer available, resolve an instance of IPushMessages from the container inst" +
        "ead. Will be removed in version 7.0.0.", true)]
    public class MsmqDequeueStrategy
    {
        public MsmqDequeueStrategy() { }
    }
    [System.ObsoleteAttribute("No longer available, see the documentation for native sends for alternative solut" +
        "ions. Will be removed in version 7.0.0.", true)]
    public class MsmqMessageSender
    {
        public MsmqMessageSender() { }
    }
    [System.ObsoleteAttribute("The msmq transaction is now available via the pipeline context. Will be removed i" +
        "n version 7.0.0.", true)]
    public class MsmqUnitOfWork
    {
        public MsmqUnitOfWork() { }
    }
}
namespace NServiceBus.Unicast.Behaviors
{
    public class MessageHandler
    {
        [System.ObsoleteAttribute("Use `NServiceBus.Pipeline.MessageHandler(Action<object, object, object> invocatio" +
            "n, Type handlerType)` instead. Will be removed in version 7.0.0.", true)]
        public MessageHandler() { }
        [System.ObsoleteAttribute("Use `NServiceBus.Pipeline.MessageHandler.Invoke` instead. The member currently th" +
            "rows a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public System.Action<object, object> Invocation { get; set; }
    }
}
namespace NServiceBus.Unicast
{
    public class static BuilderExtensions
    {
        public static void ForEach<T>(this NServiceBus.ObjectBuilder.IBuilder builder, System.Action<T> action) { }
    }
    [System.ObsoleteAttribute("No longer used, use the new callbacks api described in the version 6 upgrade guid" +
        "e. Will be removed in version 7.0.0.", true)]
    public class BusAsyncResult
    {
        public BusAsyncResult() { }
    }
    public class DeliveryMessageOptions
    {
        public DeliveryMessageOptions() { }
        [System.ObsoleteAttribute("Use the ConsistencyGuarantee class instead. The member currently throws a NotImpl" +
            "ementedException. Will be removed in version 7.0.0.", true)]
        public bool EnlistInReceiveTransaction { get; set; }
        [System.ObsoleteAttribute("Use context.TryGetDeliveryConstraint<NonDurableDelivery> instead. The member curr" +
            "ently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public System.Nullable<bool> NonDurable { get; set; }
        [System.ObsoleteAttribute("Use context.TryGetDeliveryConstraint<DiscardIfNotReceivedBefore> instead. The mem" +
            "ber currently throws a NotImplementedException. Will be removed in version 7.0.0" +
            ".", true)]
        public System.Nullable<System.TimeSpan> TimeToBeReceived { get; set; }
    }
    [System.ObsoleteAttribute("Use `NServiceBus.UnicastBus.DeliveryMessageOptions` instead. Will be removed in v" +
        "ersion 7.0.0.", true)]
    public abstract class DeliveryOptions
    {
        protected DeliveryOptions() { }
        [System.ObsoleteAttribute("Turn best practices check off using configuration.DisableFeature<BestPracticeEnfo" +
            "rcement>(). The member currently throws a NotImplementedException. Will be remov" +
            "ed in version 7.0.0.", true)]
        public bool EnforceMessagingBestPractices { get; set; }
        [System.ObsoleteAttribute("Reply to address can be get/set using the `NServiceBus.ReplyToAddress` header. Th" +
            "e member currently throws a NotImplementedException. Will be removed in version " +
            "7.0.0.", true)]
        public string ReplyToAddress { get; set; }
    }
    [System.ObsoleteAttribute("Not a public API. Use `MessageHandlerRegistry` instead. Will be removed in versio" +
        "n 7.0.0.", true)]
    public interface IMessageHandlerRegistry { }
    [System.ObsoleteAttribute("Will be removed in version 7.0.0.", true)]
    public class MessageContext
    {
        public MessageContext() { }
    }
    public class MessageEventArgs : System.EventArgs
    {
        public MessageEventArgs(object msg) { }
        public object Message { get; }
    }
    public class MessageHandlerRegistry
    {
        [System.ObsoleteAttribute("Use `MessageHandlerRegistry.RegisterHandler(Type handlerType)` instead. The membe" +
            "r currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void CacheMethodForHandler(System.Type handler, System.Type messageType) { }
        public void Clear() { }
        public System.Collections.Generic.List<NServiceBus.Pipeline.MessageHandler> GetHandlersFor(System.Type messageType) { }
        [System.ObsoleteAttribute("Use `MessageHandlerRegistry.GetHandlersFor(Type messageType)` instead. The member" +
            " currently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public System.Collections.Generic.IEnumerable<System.Type> GetHandlerTypes(System.Type messageType) { }
        public System.Collections.Generic.IEnumerable<System.Type> GetMessageTypes() { }
        [System.ObsoleteAttribute("Use `MessageHandler.Invoke(object message, object context)` instead. The member c" +
            "urrently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void InvokeHandle(object handler, object message) { }
        [System.ObsoleteAttribute("Use `MessageHandler.Invoke(object message, object context)` instead. The member c" +
            "urrently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public void InvokeTimeout(object handler, object state) { }
        public void RegisterHandler(System.Type handlerType) { }
    }
    public class MessagesEventArgs : System.EventArgs
    {
        public MessagesEventArgs(object[] messages) { }
        public object[] Messages { get; }
    }
    [System.ObsoleteAttribute("Use context.Intent to detect of the message is a event being published and use co" +
        "ntext.MessageType to get the actual event type. Will be removed in version 7.0.0" +
        ".", true)]
    public class PublishOptions : NServiceBus.Unicast.DeliveryOptions
    {
        public PublishOptions() { }
    }
    [System.ObsoleteAttribute("Not used anymore, use the \'NServiceBus.MessageIntent\' header to detect if the mes" +
        "sage is a reply. Will be removed in version 7.0.0.", true)]
    public class ReplyOptions
    {
        public ReplyOptions() { }
    }
    [System.ObsoleteAttribute("Use `NServiceBus.UnicastBus.SendMessageOptions` instead. Will be removed in versi" +
        "on 7.0.0.", true)]
    public class SendOptions : NServiceBus.Unicast.DeliveryOptions
    {
        [System.ObsoleteAttribute("Use `SendMessageOptions(string)` instead. The member currently throws a NotImplem" +
            "entedException. Will be removed in version 7.0.0.", true)]
        public SendOptions(NServiceBus.Address destination) { }
        [System.ObsoleteAttribute("Reply to address can be get/set using the `NServiceBus.CorrelationId` header. The" +
            " member currently throws a NotImplementedException. Will be removed in version 7" +
            ".0.0.", true)]
        public string CorrelationId { get; set; }
        [System.ObsoleteAttribute("Use `DelayDeliveryFor` instead. The member currently throws a NotImplementedExcep" +
            "tion. Will be removed in version 7.0.0.", true)]
        public System.Nullable<System.TimeSpan> DelayDeliveryWith { get; set; }
    }
    [System.ObsoleteAttribute("UnicastBus has been made internal. Use IEndpointInstance instead. Will be removed" +
        " in version 7.0.0.", true)]
    public class UnicastBus
    {
        public UnicastBus() { }
    }
}
namespace NServiceBus.Unicast.Messages
{
    public class MessageMetadata
    {
        public MessageMetadata(System.Type messageType) { }
        public MessageMetadata(System.Type messageType, System.Type[] messageHierarchy) { }
        public System.Type[] MessageHierarchy { get; }
        public System.Type MessageType { get; }
        [System.ObsoleteAttribute("You can access Recoverable via the DeliveryConstraints collection on the outgoing" +
            " context, the new constraint is called NonDurableDelivery. The member currently " +
            "throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public bool Recoverable { get; }
        [System.ObsoleteAttribute("You can access TTBR via the DeliveryConstraints collection on the outgoing contex" +
            "t. The member currently throws a NotImplementedException. Will be removed in ver" +
            "sion 7.0.0.", true)]
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class MessageMetadataRegistry
    {
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(System.Type messageType) { }
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(string messageTypeIdentifier) { }
    }
}
namespace NServiceBus.Unicast.Queuing
{
    [System.ObsoleteAttribute("Use `QueueBindings` instead. Will be removed in version 7.0.0.", true)]
    public interface IWantQueueCreated { }
    public class QueueNotFoundException : System.Exception
    {
        public QueueNotFoundException() { }
        [System.ObsoleteAttribute("Use `QueueNotFoundException(string queue, string message, Exception inner)` inste" +
            "ad. The member currently throws a NotImplementedException. Will be removed in ve" +
            "rsion 7.0.0.", true)]
        public QueueNotFoundException(NServiceBus.Address queue, string message, System.Exception inner) { }
        public QueueNotFoundException(string queue, string message, System.Exception inner) { }
        protected QueueNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public string Queue { get; set; }
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
}
namespace NServiceBus.Unicast.Routing
{
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class StaticMessageRouter
    {
        public StaticMessageRouter() { }
        [System.ObsoleteAttribute("Use `config.AutoSubscribe().AutoSubscribePlainMessages()` instead. The member cur" +
            "rently throws a NotImplementedException. Will be removed in version 7.0.0.", true)]
        public bool SubscribeToPlainMessages { get; set; }
    }
}
namespace NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions
{
    public interface IInitializableSubscriptionStorage : NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.ISubscriptionStorage
    {
        void Init();
    }
    public interface ISubscriptionStorage
    {
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber>> GetSubscriberAddressesForMessage(System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Subscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, NServiceBus.Unicast.Subscriptions.MessageType messageType, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, NServiceBus.Unicast.Subscriptions.MessageType messageType, NServiceBus.Extensibility.ContextBag context);
    }
    public class Subscriber
    {
        public Subscriber(string transportAddress, string endpoint) { }
        public string Endpoint { get; }
        public string TransportAddress { get; }
    }
}
namespace NServiceBus.Unicast.Subscriptions
{
    public class MessageType
    {
        public MessageType(System.Type type) { }
        public MessageType(string messageTypeString) { }
        public MessageType(string typeName, string versionString) { }
        public MessageType(string typeName, System.Version version) { }
        public string TypeName { get; }
        public System.Version Version { get; }
        public bool Equals(NServiceBus.Unicast.Subscriptions.MessageType other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    [System.ObsoleteAttribute("No longer used, safe to remove. Will be removed in version 7.0.0.", true)]
    public class SubscriptionEventArgs
    {
        public SubscriptionEventArgs() { }
    }
}
namespace NServiceBus.Unicast.Transport
{
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class static ControlMessage { }
    public class static ControlMessageFactory
    {
        public static NServiceBus.Transport.OutgoingMessage Create(NServiceBus.MessageIntentEnum intent) { }
    }
    [System.ObsoleteAttribute("Use the pipeline to catch failures. Will be removed in version 7.0.0.", true)]
    public class FailedMessageProcessingEventArgs : System.EventArgs
    {
        public FailedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class FinishedMessageProcessingEventArgs : System.EventArgs
    {
        public FinishedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("Use `NServiceBus.Transport.IPushMessages` instead. Will be removed in version 7.0" +
        ".0.", true)]
    public interface ITransport { }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class StartedMessageProcessingEventArgs
    {
        public StartedMessageProcessingEventArgs() { }
    }
    [System.ObsoleteAttribute("Transaction settings is no longer available via this class. See obsoletes on indi" +
        "vidual members for further details. Will be removed in version 7.0.0.", true)]
    public class TransactionSettings
    {
        [System.ObsoleteAttribute("No longer used. Will be removed in version 7.0.0.", true)]
        public TransactionSettings(bool isTransactional, System.TimeSpan transactionTimeout, System.Transactions.IsolationLevel isolationLevel, bool suppressDistributedTransactions, bool doNotWrapHandlersExecutionInATransactionScope) { }
        [System.ObsoleteAttribute("DoNotWrapHandlersExecutionInATransactionScope is no longer used here. Use setting" +
            "s.GetOrDefault<bool>(\'Transactions.DoNotWrapHandlersExecutionInATransactionScope" +
            "\') instead. Will be removed in version 7.0.0.", true)]
        public bool DoNotWrapHandlersExecutionInATransactionScope { get; set; }
        [System.ObsoleteAttribute("Isolation level are now controlled explicitly for the transaction scope unit of w" +
            "ork using config.UnitOfWork().WrapHandlersInATransactionScope(isolationlevel: X)" +
            ". Will be removed in version 7.0.0.", true)]
        public System.Transactions.IsolationLevel IsolationLevel { get; set; }
        [System.ObsoleteAttribute("IsTransactional is no longer used here. Use `context.Settings.GetRequiredTransact" +
            "ionModeForReceives() != Transactions.None` instead. Will be removed in version 7" +
            ".0.0.", true)]
        public bool IsTransactional { get; set; }
        [System.ObsoleteAttribute("SuppressDistributedTransactions is no longer used here. Use `context.Settings.Get" +
            "RequiredTransactionModeForReceives() != Transactions.TransactionScope` instead. " +
            "Will be removed in version 7.0.0.", true)]
        public bool SuppressDistributedTransactions { get; set; }
        [System.ObsoleteAttribute("Timeouts are now controlled explicitly for the transaction scope unit of work usi" +
            "ng config.UnitOfWork().WrapHandlersInATransactionScope(timeout: X). Will be remo" +
            "ved in version 7.0.0.", true)]
        public System.TimeSpan TransactionTimeout { get; set; }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportMessageAvailableEventArgs
    {
        public TransportMessageAvailableEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportMessageReceivedEventArgs
    {
        public TransportMessageReceivedEventArgs() { }
    }
    [System.ObsoleteAttribute("No longer used, can safely be removed. Will be removed in version 7.0.0.", true)]
    public class TransportReceiver
    {
        public TransportReceiver() { }
    }
}
namespace NServiceBus.UnitOfWork
{
    public interface IManageUnitsOfWork
    {
        System.Threading.Tasks.Task Begin();
        System.Threading.Tasks.Task End(System.Exception ex = null);
    }
}