[assembly: System.CLSCompliant(false)]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"NServiceBus.AcceptanceTesting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"NServiceBus.ContainerTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"NServiceBus.Core.Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"NServiceBus.PersistenceTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.InteropServices.ComVisible(false)]
namespace NServiceBus
{
    public enum AddressMode
    {
        Local = 0,
        Remote = 1,
    }
    public class AssemblyScannerConfiguration
    {
        public AssemblyScannerConfiguration() { }
        public string? AdditionalAssemblyScanningPath { get; set; }
        public bool Disable { get; set; }
        public bool ScanAppDomainAssemblies { get; set; }
        public bool ScanAssembliesInNestedDirectories { get; set; }
        public bool ScanFileSystemAssemblies { get; set; }
        public bool ThrowExceptions { get; set; }
        public void ExcludeAssemblies(params string[] assemblies) { }
        public void ExcludeTypes(params System.Type[] types) { }
    }
    public static class AssemblyScannerConfigurationExtensions
    {
        public static NServiceBus.AssemblyScannerConfiguration AssemblyScanner(this NServiceBus.EndpointConfiguration configuration) { }
    }
    public static class AuditConfigReader
    {
        public static bool TryGetAuditMessageExpiration(this NServiceBus.Settings.IReadOnlySettings settings, out System.TimeSpan auditMessageExpiration) { }
        public static bool TryGetAuditQueueAddress(this NServiceBus.Settings.IReadOnlySettings settings, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? address) { }
    }
    public static class AuditContextExtensions
    {
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.IAuditActionContext context, NServiceBus.Transport.OutgoingMessage auditMessage, NServiceBus.Routing.RoutingStrategy routingStrategy) { }
    }
    public static class AutoSubscribeSettingsExtensions
    {
        public static NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings AutoSubscribe(this NServiceBus.EndpointConfiguration config) { }
    }
    public static class BestPracticesOptionExtensions
    {
        public static void DoNotEnforceBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingPublishContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingReplyContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingSendContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.ISubscribeContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IUnsubscribeContext context) { }
        public static bool IgnoredBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public static class ConfigureAudit
    {
        public static void AuditProcessedMessagesTo(this NServiceBus.EndpointConfiguration config, string auditQueue, System.TimeSpan? timeToBeReceived = default) { }
    }
    public static class ConfigureCriticalErrorAction
    {
        public static void DefineCriticalErrorAction(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Func<NServiceBus.ICriticalErrorContext, System.Threading.CancellationToken, System.Threading.Tasks.Task> onCriticalError) { }
    }
    public static class ConfigureError
    {
        public static void SendFailedMessagesTo(this NServiceBus.EndpointConfiguration config, string errorQueue) { }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public static class ConfigureFileShareDataBus
    {
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public static NServiceBus.DataBus.DataBusExtensions<NServiceBus.FileShareDataBus> BasePath(this NServiceBus.DataBus.DataBusExtensions<NServiceBus.FileShareDataBus> config, string basePath) { }
    }
    public static class ConfigureLicenseExtensions
    {
        public static void License(this NServiceBus.EndpointConfiguration config, string licenseText) { }
        public static void LicensePath(this NServiceBus.EndpointConfiguration config, string licenseFile) { }
    }
    public static class ConfigurePurging
    {
        public static void PurgeOnStartup(this NServiceBus.EndpointConfiguration config, bool value) { }
    }
    public static class ConnectorContextExtensions
    {
        public static NServiceBus.Pipeline.IAuditContext CreateAuditContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IAuditContext> forkConnector, NServiceBus.Transport.OutgoingMessage message, string auditAddress, System.TimeSpan? timeToBeReceived, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IBatchDispatchContext CreateBatchDispatchContext(this NServiceBus.Pipeline.StageForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IBatchDispatchContext> stageForkConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IDispatchContext CreateDispatchContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IBatchDispatchContext, NServiceBus.Pipeline.IDispatchContext> stageConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IBatchDispatchContext sourceContext) { }
        public static NServiceBus.Pipeline.IDispatchContext CreateDispatchContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IRoutingContext, NServiceBus.Pipeline.IDispatchContext> stageConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IRoutingContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingLogicalMessageContext CreateIncomingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IIncomingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.LogicalMessage logicalMessage, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext> stageConnector, NServiceBus.Transport.IncomingMessage incomingMessage, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(this NServiceBus.Pipeline.StageForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IBatchDispatchContext> stageForkConnector, NServiceBus.Transport.IncomingMessage incomingMessage, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IInvokeHandlerContext CreateInvokeHandlerContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IIncomingLogicalMessageContext, NServiceBus.Pipeline.IInvokeHandlerContext> stageConnector, NServiceBus.Pipeline.MessageHandler messageHandler, NServiceBus.Persistence.ICompletableSynchronizedStorageSession storageSession, NServiceBus.Pipeline.IIncomingLogicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingPublishContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingPublishContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingReplyContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingReplyContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingSendContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingSendContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingPhysicalMessageContext CreateOutgoingPhysicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingLogicalMessageContext, NServiceBus.Pipeline.IOutgoingPhysicalMessageContext> stageConnector, System.ReadOnlyMemory<byte> messageBody, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingLogicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IRoutingContext> forkConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, string localAddress, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IAuditContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy, NServiceBus.Pipeline.IAuditContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingPhysicalMessageContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingPhysicalMessageContext sourceContext) { }
    }
    public abstract class ContainSagaData : NServiceBus.IContainSagaData
    {
        protected ContainSagaData() { }
        public virtual System.Guid Id { get; set; }
        public virtual string? OriginalMessageId { get; set; }
        public virtual string? Originator { get; set; }
    }
    public static class ContentTypes
    {
        public const string Json = "application/json";
        public const string Xml = "text/xml";
    }
    public class Conventions
    {
        public Conventions() { }
        public void AddSystemMessagesConventions(System.Func<System.Type, bool> definesMessageType) { }
        public bool IsCommandType(System.Type t) { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public bool IsDataBusProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEventType(System.Type t) { }
        public bool IsInSystemConventionList(System.Type t) { }
        public bool IsMessageType(System.Type t) { }
    }
    public class ConventionsBuilder : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public ConventionsBuilder(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.Conventions Conventions { get; }
        public NServiceBus.ConventionsBuilder Add(NServiceBus.IMessageConvention messageConvention) { }
        public NServiceBus.ConventionsBuilder DefiningCommandsAs(System.Func<System.Type, bool> definesCommandType) { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public NServiceBus.ConventionsBuilder DefiningDataBusPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesDataBusProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEventsAs(System.Func<System.Type, bool> definesEventType) { }
        public NServiceBus.ConventionsBuilder DefiningMessagesAs(System.Func<System.Type, bool> definesMessageType) { }
    }
    public class ConversationId
    {
        public static NServiceBus.ConversationId Default { get; }
        public static NServiceBus.ConversationId Custom(string customValue) { }
    }
    public class ConversationIdStrategyContext
    {
        public ConversationIdStrategyContext(NServiceBus.Pipeline.OutgoingLogicalMessage message, System.Collections.Generic.IReadOnlyDictionary<string, string> headers) { }
        public System.Collections.Generic.IReadOnlyDictionary<string, string> Headers { get; }
        public NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public static class ConversationRoutingExtensions
    {
        public static void StartNewConversation(this NServiceBus.SendOptions sendOptions, string? conversationId = null) { }
    }
    public class CorrelatedSagaPropertyMapper<TSagaData>
        where TSagaData :  class, NServiceBus.IContainSagaData
    {
        public NServiceBus.CorrelatedSagaPropertyMapper<TSagaData> ToMessage<TMessage>(System.Linq.Expressions.Expression<System.Func<TMessage, object?>> messageProperty) { }
        public NServiceBus.CorrelatedSagaPropertyMapper<TSagaData> ToMessageHeader<TMessage>(string headerName) { }
    }
    public class CriticalError
    {
        public CriticalError(System.Func<NServiceBus.ICriticalErrorContext, System.Threading.CancellationToken, System.Threading.Tasks.Task>? onCriticalErrorAction) { }
        public virtual void Raise(string errorMessage, System.Exception exception, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public class CriticalErrorContext : NServiceBus.ICriticalErrorContext
    {
        public CriticalErrorContext(System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task> stop, string error, System.Exception exception) { }
        public string Error { get; }
        public System.Exception Exception { get; }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task> Stop { get; }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public class DataBusProperty<T> : NServiceBus.IDataBusProperty
        where T :  class
    {
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public DataBusProperty() { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public DataBusProperty(T value) { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public bool HasValue { get; set; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public string Key { get; set; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        [System.Text.Json.Serialization.JsonIgnore]
        public System.Type Type { get; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        [System.Text.Json.Serialization.JsonIgnore]
        [System.Xml.Serialization.XmlIgnore]
        public T Value { get; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public object GetValue() { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public void SetValue(object valueToSet) { }
    }
    public static class DateTimeOffsetHelper
    {
        public static System.DateTimeOffset ToDateTimeOffset(string wireFormattedString) { }
        public static string ToWireFormattedString(System.DateTimeOffset dateTime) { }
    }
    public static class DefaultRecoverabilityPolicy
    {
        public static NServiceBus.RecoverabilityAction Invoke(NServiceBus.RecoverabilityConfig config, NServiceBus.Transport.ErrorContext errorContext) { }
    }
    public class DelayedConfig
    {
        public DelayedConfig(int maxNumberOfRetries, System.TimeSpan timeIncrease) { }
        public int MaxNumberOfRetries { get; }
        public System.TimeSpan TimeIncrease { get; }
    }
    public static class DelayedDeliveryOptionExtensions
    {
        public static void DelayDeliveryWith(this NServiceBus.SendOptions options, System.TimeSpan delay) { }
        public static void DoNotDeliverBefore(this NServiceBus.SendOptions options, System.DateTimeOffset at) { }
        public static System.DateTimeOffset? GetDeliveryDate(this NServiceBus.SendOptions options) { }
        public static System.TimeSpan? GetDeliveryDelay(this NServiceBus.SendOptions options) { }
    }
    public class DelayedRetriesSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public NServiceBus.DelayedRetriesSettings NumberOfRetries(int numberOfRetries) { }
        public NServiceBus.DelayedRetriesSettings OnMessageBeingRetried(System.Func<NServiceBus.Faults.DelayedRetryMessage, System.Threading.CancellationToken, System.Threading.Tasks.Task> notificationCallback) { }
        public NServiceBus.DelayedRetriesSettings TimeIncrease(System.TimeSpan timeIncrease) { }
    }
    public class DelayedRetry : NServiceBus.RecoverabilityAction
    {
        protected DelayedRetry(System.TimeSpan delay) { }
        public System.TimeSpan Delay { get; }
        public override NServiceBus.Transport.ErrorHandleResult ErrorHandleResult { get; }
        public override System.Collections.Generic.IReadOnlyCollection<NServiceBus.Pipeline.IRoutingContext> GetRoutingContexts(NServiceBus.Pipeline.IRecoverabilityActionContext context) { }
    }
    public enum DependencyLifecycle
    {
        SingleInstance = 0,
        InstancePerUnitOfWork = 1,
        InstancePerCall = 2,
    }
    public static class DiagnosticSettingsExtensions
    {
        public static void AddStartupDiagnosticsSection(this NServiceBus.Settings.IReadOnlySettings settings, string sectionName, object section) { }
        public static void CustomDiagnosticsWriter(this NServiceBus.EndpointConfiguration config, System.Func<string, System.Threading.CancellationToken, System.Threading.Tasks.Task> customDiagnosticsWriter) { }
        public static void SetDiagnosticsPath(this NServiceBus.EndpointConfiguration config, string path) { }
    }
    public class Discard : NServiceBus.RecoverabilityAction
    {
        public Discard(string reason) { }
        public override NServiceBus.Transport.ErrorHandleResult ErrorHandleResult { get; }
        public string Reason { get; }
        public override System.Collections.Generic.IReadOnlyCollection<NServiceBus.Pipeline.IRoutingContext> GetRoutingContexts(NServiceBus.Pipeline.IRecoverabilityActionContext context) { }
    }
    public class DistributionPolicy : NServiceBus.IDistributionPolicy
    {
        public DistributionPolicy() { }
        public void SetDistributionStrategy(NServiceBus.Routing.DistributionStrategy distributionStrategy) { }
    }
    public enum DistributionStrategyScope
    {
        Send = 0,
        Publish = 1,
    }
    public static class Endpoint
    {
        public static System.Threading.Tasks.Task<NServiceBus.IStartableEndpoint> Create(NServiceBus.EndpointConfiguration configuration, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start(NServiceBus.EndpointConfiguration configuration, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public class EndpointConfiguration : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public EndpointConfiguration(string endpointName) { }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        public NServiceBus.ConventionsBuilder Conventions() { }
        public void RegisterComponents(System.Action<Microsoft.Extensions.DependencyInjection.IServiceCollection> registration) { }
        public void SendOnly() { }
    }
    public static class EndpointConfigurationExtensions
    {
        [System.Obsolete("Use \'DisableFeature<T>(this EndpointConfiguration config)\' instead. Will be remov" +
            "ed in version 11.0.0.", true)]
        public static void DisableFeature(this NServiceBus.EndpointConfiguration config, System.Type featureType) { }
        public static void DisableFeature<TFeature>(this NServiceBus.EndpointConfiguration config)
            where TFeature : NServiceBus.Features.Feature, new () { }
        [System.Obsolete("Use \'EnableFeature<T>(this EndpointConfiguration config)\' instead. Will be remove" +
            "d in version 11.0.0.", true)]
        public static void EnableFeature(this NServiceBus.EndpointConfiguration config, System.Type featureType) { }
        public static void EnableFeature<TFeature>(this NServiceBus.EndpointConfiguration config)
            where TFeature : NServiceBus.Features.Feature, new () { }
    }
    public static class EndpointInstanceExtensions
    {
        public static System.Threading.Tasks.Task Stop(this NServiceBus.IEndpointInstance endpoint, System.TimeSpan gracefulStopTimeout) { }
    }
    public static class EndpointWithExternallyManagedContainer
    {
        public static NServiceBus.IStartableEndpointWithExternallyManagedContainer Create(NServiceBus.EndpointConfiguration configuration, Microsoft.Extensions.DependencyInjection.IServiceCollection serviceCollection) { }
    }
    public static class EnvelopeConfigExtensions
    {
        extension(NServiceBus.Features.FeatureConfigurationContext context)
        {
            public void AddEnvelopeHandler<THandler>()
                where THandler :  class, NServiceBus.IEnvelopeHandler { }
        }
    }
    public static class ErrorQueueSettings
    {
        public const string SettingsKey = "errorQueue";
        extension(NServiceBus.Settings.IReadOnlySettings settings)
        {
            public string ErrorQueueAddress() { }
            public bool TryGetExplicitlyConfiguredErrorQueueAddress([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out string? errorQueue) { }
        }
    }
    public class FailedConfig
    {
        public FailedConfig(string errorQueue, System.Collections.Generic.HashSet<System.Type> unrecoverableExceptionTypes) { }
        public string ErrorQueue { get; }
        public System.Collections.Generic.HashSet<System.Type> UnrecoverableExceptionTypes { get; }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public class FileShareDataBus : NServiceBus.DataBus.DataBusDefinition
    {
        public FileShareDataBus() { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        protected override System.Type ProvidedByFeature() { }
    }
    public static class HeaderOptionExtensions
    {
        public static System.Collections.Generic.IReadOnlyDictionary<string, string> GetHeaders(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void SetHeader(this NServiceBus.Extensibility.ExtendableOptions options, string key, string value) { }
    }
    public static class Headers
    {
        public const string ContentType = "NServiceBus.ContentType";
        public const string ControlMessageHeader = "NServiceBus.ControlMessage";
        public const string ConversationId = "NServiceBus.ConversationId";
        public const string CorrelationId = "NServiceBus.CorrelationId";
        public const string DataBusConfigContentType = "NServiceBus.DataBusConfig.ContentType";
        public const string DelayedRetries = "NServiceBus.Retries";
        public const string DelayedRetriesTimestamp = "NServiceBus.Retries.Timestamp";
        public const string DeliverAt = "NServiceBus.DeliverAt";
        public const string DestinationSites = "NServiceBus.DestinationSites";
        public const string DiagnosticsBaggage = "baggage";
        public const string DiagnosticsTraceParent = "traceparent";
        public const string DiagnosticsTraceState = "tracestate";
        public const string EnclosedMessageTypes = "NServiceBus.EnclosedMessageTypes";
        public const string HasLicenseExpired = "$.diagnostics.license.expired";
        public const string HostDisplayName = "$.diagnostics.hostdisplayname";
        public const string HostId = "$.diagnostics.hostid";
        public const string HttpFrom = "NServiceBus.From";
        public const string HttpTo = "NServiceBus.To";
        public const string ImmediateRetries = "NServiceBus.FLRetries";
        public const string IsDeferredMessage = "NServiceBus.IsDeferredMessage";
        public const string IsSagaTimeoutMessage = "NServiceBus.IsSagaTimeoutMessage";
        public const string MessageId = "NServiceBus.MessageId";
        public const string MessageIntent = "NServiceBus.MessageIntent";
        public const string NServiceBusVersion = "NServiceBus.Version";
        public const string NonDurableMessage = "NServiceBus.NonDurableMessage";
        public const string OriginatingAddress = "NServiceBus.OriginatingAddress";
        public const string OriginatingEndpoint = "NServiceBus.OriginatingEndpoint";
        public const string OriginatingHostId = "$.diagnostics.originating.hostid";
        public const string OriginatingMachine = "NServiceBus.OriginatingMachine";
        public const string OriginatingSagaId = "NServiceBus.OriginatingSagaId";
        public const string OriginatingSagaType = "NServiceBus.OriginatingSagaType";
        public const string OriginatingSite = "NServiceBus.OriginatingSite";
        public const string PreviousConversationId = "NServiceBus.PreviousConversationId";
        public const string ProcessingEnded = "NServiceBus.ProcessingEnded";
        public const string ProcessingEndpoint = "NServiceBus.ProcessingEndpoint";
        public const string ProcessingMachine = "NServiceBus.ProcessingMachine";
        public const string ProcessingStarted = "NServiceBus.ProcessingStarted";
        public const string RelatedTo = "NServiceBus.RelatedTo";
        public const string ReplyToAddress = "NServiceBus.ReplyToAddress";
        public const string ReturnMessageErrorCodeHeader = "NServiceBus.ReturnMessage.ErrorCode";
        public const string RouteTo = "NServiceBus.Header.RouteTo";
        public const string SagaId = "NServiceBus.SagaId";
        public const string SagaType = "NServiceBus.SagaType";
        public const string StartNewTrace = "NServiceBus.OpenTelemetry.StartNewTrace";
        public const string SubscriberEndpoint = "NServiceBus.SubscriberEndpoint";
        public const string SubscriberTransportAddress = "NServiceBus.SubscriberAddress";
        public const string SubscriptionMessageType = "SubscriptionMessageType";
        public const string TimeSent = "NServiceBus.TimeSent";
        public const string TimeToBeReceived = "NServiceBus.TimeToBeReceived";
    }
    public static class HostInfoConfigurationExtensions
    {
        public static NServiceBus.HostInfoSettings UniquelyIdentifyRunningInstance(this NServiceBus.EndpointConfiguration config) { }
    }
    public class HostInfoSettings
    {
        public NServiceBus.HostInfoSettings UsingCustomDisplayName(string displayName) { }
        public NServiceBus.HostInfoSettings UsingCustomIdentifier(System.Guid id) { }
        public NServiceBus.HostInfoSettings UsingHostName(string hostName) { }
        public NServiceBus.HostInfoSettings UsingInstalledFilePath() { }
        public NServiceBus.HostInfoSettings UsingNames(string instanceName, string hostName) { }
    }
    public interface IAmStartedByMessages<T> : NServiceBus.IHandleMessages, NServiceBus.IHandleMessages<T> { }
    public interface ICancellableContext
    {
        System.Threading.CancellationToken CancellationToken { get; }
    }
    public interface IConfigureHowToFindSagaWithFinder
    {
        void ConfigureMapping<TSagaEntity, TMessage, TFinder>()
            where TSagaEntity :  class, NServiceBus.IContainSagaData
            where TFinder :  class, NServiceBus.Sagas.ISagaFinder<TSagaEntity, TMessage>;
    }
    public interface IConfigureHowToFindSagaWithMessage
    {
        void ConfigureMapping<TSagaEntity, TMessage>(System.Linq.Expressions.Expression<System.Func<TSagaEntity, object?>> sagaEntityProperty, System.Linq.Expressions.Expression<System.Func<TMessage, object?>> messageProperty)
            where TSagaEntity :  class, NServiceBus.IContainSagaData;
    }
    public interface IConfigureHowToFindSagaWithMessageHeaders
    {
        void ConfigureMapping<TSagaEntity, TMessage>(System.Linq.Expressions.Expression<System.Func<TSagaEntity, object?>> sagaEntityProperty, string headerName)
            where TSagaEntity :  class, NServiceBus.IContainSagaData;
    }
    public interface IConfigureSagaNotFoundHandler
    {
        void ConfigureSagaNotFoundHandler<TNotFoundHandler>()
            where TNotFoundHandler : NServiceBus.ISagaNotFoundHandler;
    }
    public interface IContainSagaData
    {
        System.Guid Id { get; set; }
        string? OriginalMessageId { get; set; }
        string? Originator { get; set; }
    }
    public interface ICriticalErrorContext
    {
        string Error { get; }
        System.Exception Exception { get; }
        System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task> Stop { get; }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public interface IDataBusProperty
    {
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        bool HasValue { get; set; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        string Key { get; set; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        System.Type Type { get; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        object GetValue();
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        void SetValue(object value);
    }
    public interface IDistributionPolicy
    {
        NServiceBus.Routing.DistributionStrategy GetDistributionStrategy(string endpointName, NServiceBus.DistributionStrategyScope scope);
    }
    public interface IEndpointInstance : NServiceBus.IMessageSession
    {
        System.Threading.Tasks.Task Stop(System.Threading.CancellationToken cancellationToken = default);
    }
    public interface IEnvelopeHandler
    {
        System.Collections.Generic.Dictionary<string, string>? UnwrapEnvelope(string nativeMessageId, System.Collections.Generic.IDictionary<string, string> incomingHeaders, System.ReadOnlySpan<byte> incomingBody, NServiceBus.Extensibility.ContextBag extensions, System.Buffers.IBufferWriter<byte> bodyWriter);
    }
    public interface IHandleMessages { }
    public interface IHandleMessages<T> : NServiceBus.IHandleMessages
    {
        System.Threading.Tasks.Task Handle(T message, NServiceBus.IMessageHandlerContext context);
    }
    public interface IHandleTimeouts<T>
    {
        System.Threading.Tasks.Task Timeout(T state, NServiceBus.IMessageHandlerContext context);
    }
    public interface IMessageConvention
    {
        string Name { get; }
        bool IsCommandType(System.Type type);
        bool IsEventType(System.Type type);
        bool IsMessageType(System.Type type);
    }
    public interface IMessageCreator
    {
        object CreateInstance(System.Type messageType);
        T CreateInstance<T>();
        T CreateInstance<T>(System.Action<T> action);
    }
    public interface IMessageHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext
    {
        NServiceBus.Persistence.ISynchronizedStorageSession SynchronizedStorageSession { get; }
        void DoNotContinueDispatchingCurrentMessageToHandlers();
    }
    public interface IMessageProcessingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IPipelineContext
    {
        System.Collections.Generic.IReadOnlyDictionary<string, string> MessageHeaders { get; }
        string MessageId { get; }
        string ReplyToAddress { get; }
        System.Threading.Tasks.Task ForwardCurrentMessageTo(string destination);
        System.Threading.Tasks.Task Reply(object message, NServiceBus.ReplyOptions options);
        System.Threading.Tasks.Task Reply<T>(System.Action<T> messageConstructor, NServiceBus.ReplyOptions options);
    }
    public interface IMessageSession
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions publishOptions, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions sendOptions, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions sendOptions, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.SubscribeOptions subscribeOptions, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.UnsubscribeOptions unsubscribeOptions, System.Threading.CancellationToken cancellationToken = default);
    }
    public interface INeedInitialization
    {
        void Customize(NServiceBus.EndpointConfiguration configuration);
    }
    public interface IPipelineContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
    }
    public interface ISagaNotFoundHandler
    {
        System.Threading.Tasks.Task Handle(object message, NServiceBus.IMessageProcessingContext context);
    }
    public interface IStartableEndpoint
    {
        System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start(System.Threading.CancellationToken cancellationToken = default);
    }
    public interface IStartableEndpointWithExternallyManagedContainer
    {
        System.Lazy<NServiceBus.IMessageSession> MessageSession { get; }
        System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start(System.IServiceProvider builder, System.Threading.CancellationToken cancellationToken = default);
    }
    [System.Obsolete("The old saga mapping API has been obsoleted, use \'mapper.MapSaga(...)\' instead. W" +
        "ill be removed in version 11.0.0.", true)]
    public interface IToSagaExpression<TSagaData>
        where TSagaData : NServiceBus.IContainSagaData
    {
        void ToSaga(System.Linq.Expressions.Expression<System.Func<TSagaData, object>> sagaEntityProperty);
    }
    [System.Obsolete(@"Final adjustments to settings before configuration is finalized should be applied via an explicit last configuration step on the endpoint configuration, instead of via implementations of this interface discovered by scanning. Will be treated as an error from version 11.0.0. Will be removed in version 12.0.0.", false)]
    public interface IWantToRunBeforeConfigurationIsFinalized
    {
        void Run(NServiceBus.Settings.SettingsHolder settings);
    }
    public class ImmediateConfig
    {
        public ImmediateConfig(int maxNumberOfRetries) { }
        public int MaxNumberOfRetries { get; }
    }
    public static class ImmediateDispatchOptionExtensions
    {
        public static bool IsImmediateDispatchSet(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void RequireImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public class ImmediateRetriesSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public void NumberOfRetries(int numberOfRetries) { }
        public NServiceBus.ImmediateRetriesSettings OnMessageBeingRetried(System.Func<NServiceBus.Faults.ImmediateRetryMessage, System.Threading.CancellationToken, System.Threading.Tasks.Task> notificationCallback) { }
    }
    public class ImmediateRetry : NServiceBus.RecoverabilityAction
    {
        protected ImmediateRetry() { }
        public override NServiceBus.Transport.ErrorHandleResult ErrorHandleResult { get; }
        public override System.Collections.Generic.IReadOnlyCollection<NServiceBus.Pipeline.IRoutingContext> GetRoutingContexts(NServiceBus.Pipeline.IRecoverabilityActionContext context) { }
    }
    public sealed class IncomingPipelineMetricTags
    {
        public IncomingPipelineMetricTags() { }
        public void Add(string tagKey, object value) { }
        public void ApplyTag(ref System.Diagnostics.TagList tagList, string tagKey) { }
        public void ApplyTags(ref System.Diagnostics.TagList tagList, System.ReadOnlySpan<string> tagKeys) { }
    }
    public static class InstallConfigExtensions
    {
        public static void AddInstaller<TInstaller>(this NServiceBus.EndpointConfiguration config)
            where TInstaller :  class, NServiceBus.Installation.INeedToInstallSomething { }
        public static void AddInstaller<TInstaller>(this NServiceBus.Features.FeatureConfigurationContext context)
            where TInstaller :  class, NServiceBus.Installation.INeedToInstallSomething { }
        public static void EnableInstallers(this NServiceBus.EndpointConfiguration config, string? username = null) { }
    }
    public class LearningPersistence : NServiceBus.Persistence.PersistenceDefinition, NServiceBus.Persistence.IPersistenceDefinitionFactory<NServiceBus.LearningPersistence> { }
    public static class LearningSagaPersisterConfigurationExtensions
    {
        public static void SagaStorageDirectory(this NServiceBus.PersistenceExtensions<NServiceBus.LearningPersistence> persistenceExtensions, string path) { }
    }
    public class LearningTransport : NServiceBus.Transport.TransportDefinition
    {
        public LearningTransport() { }
        public bool RestrictPayloadSize { get; set; }
        public string StorageDirectory { get; set; }
        public override System.Collections.Generic.IReadOnlyCollection<NServiceBus.TransportTransactionMode> GetSupportedTransactionModes() { }
        public override System.Threading.Tasks.Task<NServiceBus.Transport.TransportInfrastructure> Initialize(NServiceBus.Transport.HostSettings hostSettings, NServiceBus.Transport.ReceiveSettings[] receivers, string[] sendingAddresses, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public static class LearningTransportConfigurationExtensions
    {
        public static void NoPayloadSizeRestriction(this NServiceBus.TransportExtensions<NServiceBus.LearningTransport> transportExtensions) { }
        public static void StorageDirectory(this NServiceBus.TransportExtensions<NServiceBus.LearningTransport> transportExtensions, string path) { }
        public static NServiceBus.TransportExtensions<NServiceBus.LearningTransport> UseTransport<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.LearningTransport { }
    }
    [System.Obsolete("Use AddHandler<TMessageHandler>(); to control order of handler invocation.. Will " +
        "be removed in version 11.0.0.", true)]
    public static class LoadMessageHandlersExtensions
    {
        [System.Obsolete("Use AddHandler<TMessageHandler>(); to control order of handler invocation.. Will " +
            "be removed in version 11.0.0.", true)]
        public static void ExecuteTheseHandlersFirst(this NServiceBus.EndpointConfiguration config, System.Collections.Generic.IEnumerable<System.Type> handlerTypes) { }
        [System.Obsolete("Use AddHandler<TMessageHandler>(); to control order of handler invocation.. Will " +
            "be removed in version 11.0.0.", true)]
        public static void ExecuteTheseHandlersFirst(this NServiceBus.EndpointConfiguration config, params System.Type[] handlerTypes) { }
    }
    public static class MessageCausationConfigurationExtensions
    {
        public static void CustomConversationIdStrategy(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Func<NServiceBus.ConversationIdStrategyContext, NServiceBus.ConversationId> customStrategy) { }
    }
    public class MessageDeserializationException : System.Runtime.Serialization.SerializationException
    {
        public MessageDeserializationException(string message) { }
        public MessageDeserializationException(string messageId, System.Exception innerException) { }
    }
    public static class MessageDrivenSubscriptionsConfigExtensions
    {
        public static void DisablePublishing<T>(this NServiceBus.RoutingSettings<T> routingSettings)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Reflection.Assembly assembly, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Type eventType, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Reflection.Assembly assembly, string @namespace, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void SubscriptionAuthorizer<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Func<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, bool> authorizer)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
    }
    public static class MessageHandlerRegistrationExtensions
    {
        public static void AddHandler<THandler>(this NServiceBus.EndpointConfiguration config)
            where THandler : NServiceBus.IHandleMessages { }
    }
    public static class MessageIdExtensions
    {
        extension(NServiceBus.Extensibility.ExtendableOptions options)
        {
            public void SetMessageId(string messageId) { }
            public string? GetMessageId() { }
        }
    }
    public enum MessageIntent
    {
        Send = 1,
        Publish = 2,
        Subscribe = 3,
        Unsubscribe = 4,
        Reply = 5,
    }
    public static class MessageProcessingContextExtensions
    {
        public static System.Threading.Tasks.Task Reply(this NServiceBus.IMessageProcessingContext context, object message) { }
        public static System.Threading.Tasks.Task Reply<T>(this NServiceBus.IMessageProcessingContext context, System.Action<T> messageConstructor) { }
    }
    public static class MessageProcessingOptimizationExtensions
    {
        extension(NServiceBus.EndpointConfiguration config)
        {
            public void LimitMessageProcessingConcurrencyTo(int maxConcurrency) { }
        }
    }
    public static class MessageSessionExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IMessageSession session, object message, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IMessageSession session, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IMessageSession session, object message, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IMessageSession session, string destination, object message, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IMessageSession session, string destination, System.Action<T> messageConstructor, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IMessageSession session, object message, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Subscribe(this NServiceBus.IMessageSession session, System.Type messageType, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Subscribe<T>(this NServiceBus.IMessageSession session, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Unsubscribe(this NServiceBus.IMessageSession session, System.Type messageType, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task Unsubscribe<T>(this NServiceBus.IMessageSession session, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public class MoveToError : NServiceBus.RecoverabilityAction
    {
        protected MoveToError(string errorQueue) { }
        public override NServiceBus.Transport.ErrorHandleResult ErrorHandleResult { get; }
        public string ErrorQueue { get; }
        public override System.Collections.Generic.IReadOnlyCollection<NServiceBus.Pipeline.IRoutingContext> GetRoutingContexts(NServiceBus.Pipeline.IRecoverabilityActionContext context) { }
    }
    public class NServiceBusMarkerInterfaceConvention : NServiceBus.IMessageConvention
    {
        public NServiceBusMarkerInterfaceConvention() { }
        public string Name { get; }
        public bool IsCommandType(System.Type type) { }
        public bool IsEventType(System.Type type) { }
        public bool IsMessageType(System.Type type) { }
    }
    public delegate System.Threading.Tasks.Task OnSatelliteMessage(System.IServiceProvider serviceProvider, NServiceBus.Transport.MessageContext messageContext, System.Threading.CancellationToken cancellationToken = default);
    public static class OpenTelemetryConfigurationExtensions
    {
        [System.Obsolete("OpenTelemetry is now enabled by default. This method is no longer required. Will " +
            "be removed in version 11.0.0.", true)]
        public static void EnableOpenTelemetry(this NServiceBus.EndpointConfiguration endpointConfiguration) { }
    }
    public static class OpenTelemetryExtensions
    {
        public static void ContinueExistingTraceOnReceive(this NServiceBus.PublishOptions publishOptions) { }
        public static void StartNewTraceOnReceive(this NServiceBus.SendOptions sendOptions) { }
    }
    public static class OutboxConfigExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings EnableOutbox(this NServiceBus.EndpointConfiguration config) { }
    }
    public class PendingTransportOperations
    {
        public PendingTransportOperations() { }
        public bool HasOperations { get; }
        public NServiceBus.Transport.TransportOperation[] Operations { get; }
        public void Add(NServiceBus.Transport.TransportOperation transportOperation) { }
        public void AddRange(NServiceBus.Transport.TransportOperation[] transportOperations) { }
    }
    public static class PersistenceConfig
    {
        [System.Obsolete("Use \'UsePersistence<T>\' instead. Will be removed in version 11.0.0.", true)]
        public static NServiceBus.PersistenceExtensions UsePersistence(this NServiceBus.EndpointConfiguration config, System.Type definitionType) { }
        public static NServiceBus.PersistenceExtensions<T> UsePersistence<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition, NServiceBus.Persistence.IPersistenceDefinitionFactory<T> { }
        public static NServiceBus.PersistenceExtensions<T, S> UsePersistence<T, S>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition, NServiceBus.Persistence.IPersistenceDefinitionFactory<T>
            where S : NServiceBus.StorageType, new () { }
    }
    [System.Obsolete("Use \'PersistenceExtensions<T>\' instead. Will be removed in version 11.0.0.", true)]
    public class PersistenceExtensions : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public PersistenceExtensions(System.Type definitionType, NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
    }
    public class PersistenceExtensions<T> : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
        where T : NServiceBus.Persistence.PersistenceDefinition, NServiceBus.Persistence.IPersistenceDefinitionFactory<T>
    {
        public PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        [System.Obsolete("Use \'PersistenceExtensions(SettingsHolder settings, StorageType? storageType = nu" +
            "ll)\' instead. Will be removed in version 11.0.0.", true)]
        protected PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
    }
    public class PersistenceExtensions<T, S> : NServiceBus.PersistenceExtensions<T>
        where T : NServiceBus.Persistence.PersistenceDefinition, NServiceBus.Persistence.IPersistenceDefinitionFactory<T>
        where S : NServiceBus.StorageType, new ()
    {
        public PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public static class PipelineContextExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IPipelineContext context) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IPipelineContext context, string destination, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IPipelineContext context, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
    }
    public class PublishOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public PublishOptions() { }
    }
    public class RateLimitSettings
    {
        public RateLimitSettings(System.TimeSpan? timeToWaitBetweenThrottledAttempts = default, System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task>? onRateLimitStarted = null, System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task>? onRateLimitEnded = null) { }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task> OnRateLimitEnded { get; }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task> OnRateLimitStarted { get; }
        public System.TimeSpan TimeToWaitBetweenThrottledAttempts { get; }
    }
    public class ReceiveAddresses
    {
        public ReceiveAddresses(string mainReceiveAddress, string? instanceReceiveAddress = null, string[]? satelliteReceiveAddresses = null) { }
        public string? InstanceReceiveAddress { get; }
        public string MainReceiveAddress { get; }
        public string[] SatelliteReceiveAddresses { get; }
    }
    public static class ReceiveFeatureConfigurationContextExtensions
    {
        extension(NServiceBus.Features.FeatureConfigurationContext config)
        {
            public NServiceBus.Transport.QueueAddress LocalQueueAddress() { }
            public NServiceBus.Transport.QueueAddress? InstanceSpecificQueueAddress() { }
        }
    }
    public class ReceivePipelineCompleted
    {
        public ReceivePipelineCompleted(NServiceBus.Transport.IncomingMessage processedMessage, System.DateTimeOffset startedAt, System.DateTimeOffset completedAt) { }
        public System.DateTimeOffset CompletedAt { get; }
        public NServiceBus.Transport.IncomingMessage ProcessedMessage { get; }
        public System.DateTimeOffset StartedAt { get; }
    }
    public static class ReceivePipelineConfigExtensions
    {
        public static void OnReceivePipelineCompleted(this NServiceBus.Pipeline.PipelineSettings pipelineSettings, System.Func<NServiceBus.ReceivePipelineCompleted, System.Threading.CancellationToken, System.Threading.Tasks.Task> subscription) { }
    }
    public static class ReceiveSettingsExtensions
    {
        public static void MakeInstanceUniquelyAddressable(this NServiceBus.EndpointConfiguration config, string discriminator) { }
        public static void OverrideLocalAddress(this NServiceBus.EndpointConfiguration config, string baseInputQueueName) { }
    }
    public abstract class RecoverabilityAction
    {
        protected RecoverabilityAction() { }
        public abstract NServiceBus.Transport.ErrorHandleResult ErrorHandleResult { get; }
        public abstract System.Collections.Generic.IReadOnlyCollection<NServiceBus.Pipeline.IRoutingContext> GetRoutingContexts(NServiceBus.Pipeline.IRecoverabilityActionContext context);
        public static NServiceBus.DelayedRetry DelayedRetry(System.TimeSpan timeSpan) { }
        public static NServiceBus.Discard Discard(string reason) { }
        public static NServiceBus.ImmediateRetry ImmediateRetry() { }
        public static NServiceBus.MoveToError MoveToError(string errorQueue) { }
    }
    public class RecoverabilityConfig
    {
        public RecoverabilityConfig(NServiceBus.ImmediateConfig immediateConfig, NServiceBus.DelayedConfig delayedConfig, NServiceBus.FailedConfig failedConfig) { }
        public NServiceBus.DelayedConfig Delayed { get; }
        public NServiceBus.FailedConfig Failed { get; }
        public NServiceBus.ImmediateConfig Immediate { get; }
    }
    public static class RecoverabilityEndpointConfigurationExtensions
    {
        public static NServiceBus.RecoverabilitySettings Recoverability(this NServiceBus.EndpointConfiguration configuration) { }
    }
    public class RecoverabilitySettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public NServiceBus.RecoverabilitySettings AddUnrecoverableException(System.Type exceptionType) { }
        public NServiceBus.RecoverabilitySettings AddUnrecoverableException<T>()
            where T : System.Exception { }
        public NServiceBus.RecoverabilitySettings CustomPolicy(System.Func<NServiceBus.RecoverabilityConfig, NServiceBus.Transport.ErrorContext, NServiceBus.RecoverabilityAction> custom) { }
        public NServiceBus.RecoverabilitySettings Delayed(System.Action<NServiceBus.DelayedRetriesSettings> customizations) { }
        public NServiceBus.RecoverabilitySettings Failed(System.Action<NServiceBus.RetryFailedSettings> customizations) { }
        public NServiceBus.RecoverabilitySettings Immediate(System.Action<NServiceBus.ImmediateRetriesSettings> customizations) { }
        public NServiceBus.RecoverabilitySettings OnConsecutiveFailures(int numberOfConsecutiveFailures, NServiceBus.RateLimitSettings settings) { }
    }
    public static class RecoverabilitySettingsExtensions
    {
        public static void AddUnrecoverableException(this NServiceBus.Settings.SettingsHolder settings, System.Type exceptionType) { }
    }
    public class ReplyOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public ReplyOptions() { }
    }
    public class RetryFailedSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public NServiceBus.RetryFailedSettings HeaderCustomization(System.Action<System.Collections.Generic.Dictionary<string, string>> customization) { }
        public NServiceBus.RetryFailedSettings OnMessageSentToErrorQueue(System.Func<NServiceBus.Faults.FailedMessage, System.Threading.CancellationToken, System.Threading.Tasks.Task> notificationCallback) { }
    }
    public static class RoutingFeatureSettingsExtensions
    {
        public static void OverridePublicReturnAddress(this NServiceBus.EndpointConfiguration configuration, string address) { }
    }
    public static class RoutingOptionExtensions
    {
        public static string? GetDestination(this NServiceBus.ReplyOptions options) { }
        public static string? GetDestination(this NServiceBus.SendOptions options) { }
        public static string? GetReplyToRoute(this NServiceBus.ReplyOptions options) { }
        public static string? GetReplyToRoute(this NServiceBus.SendOptions options) { }
        public static string? GetRouteToSpecificInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToAnyInstance(this NServiceBus.ReplyOptions options) { }
        public static bool IsRoutingReplyToAnyInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToThisInstance(this NServiceBus.ReplyOptions options) { }
        public static bool IsRoutingReplyToThisInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingToThisEndpoint(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingToThisInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyTo(this NServiceBus.ReplyOptions options, string address) { }
        public static void RouteReplyTo(this NServiceBus.SendOptions options, string address) { }
        public static void RouteReplyToAnyInstance(this NServiceBus.ReplyOptions options) { }
        public static void RouteReplyToAnyInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyToThisInstance(this NServiceBus.ReplyOptions options) { }
        public static void RouteReplyToThisInstance(this NServiceBus.SendOptions options) { }
        public static void RouteToSpecificInstance(this NServiceBus.SendOptions options, string instanceId) { }
        public static void RouteToThisEndpoint(this NServiceBus.SendOptions options) { }
        public static void RouteToThisInstance(this NServiceBus.SendOptions options) { }
        public static void SetDestination(this NServiceBus.ReplyOptions options, string destination) { }
        public static void SetDestination(this NServiceBus.SendOptions options, string destination) { }
    }
    public class RoutingSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public RoutingSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public void DoNotEnforceBestPractices() { }
        public void RouteToEndpoint(System.Reflection.Assembly assembly, string destination) { }
        public void RouteToEndpoint(System.Type messageType, string destination) { }
        public void RouteToEndpoint(System.Reflection.Assembly assembly, string @namespace, string destination) { }
    }
    public class RoutingSettings<T> : NServiceBus.RoutingSettings
        where T : NServiceBus.Transport.TransportDefinition
    {
        public RoutingSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public abstract class Saga
    {
        protected Saga() { }
        public bool Completed { get; }
        public NServiceBus.IContainSagaData Entity { get; set; }
        protected abstract void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
        protected void MarkAsComplete() { }
        protected System.Threading.Tasks.Task ReplyToOriginator(NServiceBus.IMessageHandlerContext context, object message, System.Collections.Generic.IReadOnlyDictionary<string, string>? outgoingHeaders = null) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTimeOffset at)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTimeOffset at, TTimeoutMessageType timeoutMessage) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
    }
    public class SagaPropertyMapper<TSagaData>
        where TSagaData :  class, NServiceBus.IContainSagaData
    {
        public void ConfigureFinderMapping<TMessage, TFinder>()
            where TFinder :  class, NServiceBus.Sagas.ISagaFinder<TSagaData, TMessage> { }
        [System.Obsolete("The old API for mapping messages to sagas using headers has been obsoleted, use \'" +
            "mapper.MapSaga(...).ToMessageHeader<MyMessage>(...)\' instead. Will be removed in" +
            " version 11.0.0.", true)]
        public NServiceBus.IToSagaExpression<TSagaData> ConfigureHeaderMapping<TMessage>(string headerName) { }
        [System.Obsolete("The old API for mapping messages to sagas has been obsoleted, use \'mapper.MapSaga" +
            "(...).ToMessage<MyMessage>(...)\' instead. Will be removed in version 11.0.0.", true)]
        public NServiceBus.ToSagaExpression<TSagaData, TMessage> ConfigureMapping<TMessage>(System.Linq.Expressions.Expression<System.Func<TMessage, object?>> messageProperty) { }
        public void ConfigureNotFoundHandler<TNotFoundHandler>()
            where TNotFoundHandler : NServiceBus.ISagaNotFoundHandler { }
        public NServiceBus.CorrelatedSagaPropertyMapper<TSagaData> MapSaga(System.Linq.Expressions.Expression<System.Func<TSagaData, object?>> sagaProperty) { }
    }
    public static class SagaRegistrationExtensions
    {
        public static void AddSaga<TSaga>(this NServiceBus.EndpointConfiguration config)
            where TSaga : NServiceBus.Saga, NServiceBus.IHandleMessages { }
    }
    public abstract class Saga<TSagaData> : NServiceBus.Saga
        where TSagaData :  class, NServiceBus.IContainSagaData, new ()
    {
        protected Saga() { }
        public TSagaData Data { get; set; }
        protected override void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration) { }
        protected abstract void ConfigureHowToFindSaga(NServiceBus.SagaPropertyMapper<TSagaData> mapper);
    }
    public static class SagasConfigExtensions
    {
        public static NServiceBus.Sagas.SagaSettings Sagas(this NServiceBus.EndpointConfiguration config) { }
    }
    public class SendOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SendOptions() { }
    }
    public static class SerializationConfigExtensions
    {
        public static NServiceBus.Serialization.SerializationExtensions<T> AddDeserializer<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtensions<T> AddDeserializer<T>(this NServiceBus.EndpointConfiguration config, T serializationDefinition)
            where T : NServiceBus.Serialization.SerializationDefinition { }
        public static NServiceBus.Serialization.SerializationExtensions<T> UseSerialization<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtensions<T> UseSerialization<T>(this NServiceBus.EndpointConfiguration config, T serializationDefinition)
            where T : NServiceBus.Serialization.SerializationDefinition { }
    }
    public static class SerializationContextExtensions
    {
        public static bool ShouldSkipSerialization(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context) { }
        public static void SkipSerialization(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context) { }
    }
    public static class SerializationExtensionsExtensions
    {
        public static void DisableDynamicTypeLoading<T>(this NServiceBus.Serialization.SerializationExtensions<T> config)
            where T : NServiceBus.Serialization.SerializationDefinition { }
        public static void DisableMessageTypeInference<T>(this NServiceBus.Serialization.SerializationExtensions<T> config)
            where T : NServiceBus.Serialization.SerializationDefinition { }
    }
    public static class SettingsExtensions
    {
        public static string EndpointName(this NServiceBus.Settings.IReadOnlySettings settings) { }
        public static string EndpointQueueName(this NServiceBus.Settings.IReadOnlySettings settings) { }
        public static System.Collections.Generic.IList<System.Type> GetAvailableTypes(this NServiceBus.Settings.IReadOnlySettings settings) { }
    }
    public class StartupDiagnosticEntries
    {
        public StartupDiagnosticEntries() { }
        public void Add(string sectionName, object section) { }
        public class StartupDiagnosticEntry
        {
            public StartupDiagnosticEntry() { }
            public required object Data { get; set; }
            public required string Name { get; set; }
        }
    }
    public static class StaticHeadersConfigExtensions
    {
        public static void AddHeaderToAllOutgoingMessages(this NServiceBus.EndpointConfiguration config, string key, string value) { }
    }
    public abstract class StorageType
    {
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        protected virtual bool Supports(NServiceBus.StorageType.Options options) { }
        public override string ToString() { }
        public class Options : System.IEquatable<NServiceBus.StorageType.Options>
        {
            public Options() { }
        }
        public sealed class Outbox : NServiceBus.StorageType
        {
            public Outbox() { }
        }
        public sealed class Sagas : NServiceBus.StorageType
        {
            public Sagas() { }
            protected override bool Supports(NServiceBus.StorageType.Options options) { }
        }
        public sealed class SagasOptions : NServiceBus.StorageType.Options, System.IEquatable<NServiceBus.StorageType.SagasOptions>
        {
            public SagasOptions() { }
            public bool SupportsFinders { get; init; }
        }
        public sealed class Subscriptions : NServiceBus.StorageType
        {
            public Subscriptions() { }
        }
    }
    public class SubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SubscribeOptions() { }
    }
    public class SubscriptionMigrationModeSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public SubscriptionMigrationModeSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public void RegisterPublisher(System.Reflection.Assembly assembly, string publisherEndpoint) { }
        public void RegisterPublisher(System.Type eventType, string publisherEndpoint) { }
        public void RegisterPublisher(System.Reflection.Assembly assembly, string @namespace, string publisherEndpoint) { }
        public void SubscriptionAuthorizer(System.Func<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, bool> authorizer) { }
    }
    public static class SystemJsonConfigurationExtensions
    {
        public static void ContentType(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.SystemJsonSerializer> config, string contentType) { }
        public static void Options(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.SystemJsonSerializer> config, System.Text.Json.JsonSerializerOptions options) { }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public class SystemJsonDataBusSerializer : NServiceBus.DataBus.IDataBusSerializer
    {
        public SystemJsonDataBusSerializer() { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public string ContentType { get; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public object Deserialize(System.Type propertyType, System.IO.Stream stream) { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public void Serialize(object dataBusProperty, System.IO.Stream stream) { }
    }
    public class SystemJsonSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public SystemJsonSerializer() { }
        public override System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.IReadOnlySettings settings) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface)]
    public sealed class TimeToBeReceivedAttribute : System.Attribute
    {
        public TimeToBeReceivedAttribute(string timeSpan) { }
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public static class TimeToBeReceivedConventionExtensions
    {
        extension(NServiceBus.ConventionsBuilder builder)
        {
            public NServiceBus.ConventionsBuilder DefiningTimeToBeReceivedAs(System.Func<System.Type, System.TimeSpan> retrieveTimeToBeReceived) { }
        }
    }
    [System.Obsolete("The old saga mapping API has been obsoleted, use \'mapper.MapSaga(...)\' instead. W" +
        "ill be removed in version 11.0.0.", true)]
    public class ToSagaExpression<TSagaData, TMessage>
        where TSagaData :  class, NServiceBus.IContainSagaData
    {
        public ToSagaExpression(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
        public void ToSaga(System.Linq.Expressions.Expression<System.Func<TSagaData, object?>> sagaEntityProperty) { }
    }
    public static class TransportConfig
    {
        extension(NServiceBus.EndpointConfiguration endpointConfiguration)
        {
            public NServiceBus.RoutingSettings<TTransport> UseTransport<TTransport>(TTransport transportDefinition)
                where TTransport : NServiceBus.Transport.TransportDefinition { }
        }
    }
    public class TransportExtensions<T>
        where T : NServiceBus.Transport.TransportDefinition
    {
        public TransportExtensions(T transport, NServiceBus.RoutingSettings<T> routing) { }
        public T Transport { get; }
        public NServiceBus.RoutingSettings<T> Routing() { }
        public NServiceBus.TransportExtensions<T> Transactions(NServiceBus.TransportTransactionMode transportTransactionMode) { }
    }
    public enum TransportTransactionMode
    {
        None = 0,
        ReceiveOnly = 1,
        SendsAtomicWithReceive = 2,
        TransactionScope = 3,
    }
    public class UnitOfWorkSettings
    {
        public NServiceBus.UnitOfWorkSettings WrapHandlersInATransactionScope(System.TimeSpan? timeout = default, System.Transactions.IsolationLevel? isolationLevel = default) { }
    }
    public static class UnitOfWorkSettingsExtensions
    {
        public static NServiceBus.UnitOfWorkSettings UnitOfWork(this NServiceBus.EndpointConfiguration config) { }
    }
    public class UnsubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public UnsubscribeOptions() { }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public static class UseDataBusExtensions
    {
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public static NServiceBus.DataBus.DataBusExtensions UseDataBus(this NServiceBus.EndpointConfiguration config, System.Func<System.IServiceProvider, NServiceBus.DataBus.IDataBus> dataBusFactory, NServiceBus.DataBus.IDataBusSerializer dataBusSerializer) { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public static NServiceBus.DataBus.DataBusExtensions<TDataBusDefinition> UseDataBus<TDataBusDefinition>(this NServiceBus.EndpointConfiguration config, NServiceBus.DataBus.IDataBusSerializer dataBusSerializer)
            where TDataBusDefinition : NServiceBus.DataBus.DataBusDefinition, new () { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public static NServiceBus.DataBus.DataBusExtensions<TDataBusDefinition> UseDataBus<TDataBusDefinition, TDataBusSerializer>(this NServiceBus.EndpointConfiguration config)
            where TDataBusDefinition : NServiceBus.DataBus.DataBusDefinition, new ()
            where TDataBusSerializer : NServiceBus.DataBus.IDataBusSerializer, new () { }
    }
    public static class XmlSerializationExtensions
    {
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> DontWrapRawXml(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config) { }
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> Namespace(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config, string namespaceToUse) { }
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> SanitizeInput(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config) { }
    }
    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("XmlSerializer is not supported in trimming scenarios.")]
    public class XmlSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public XmlSerializer() { }
        public override System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.IReadOnlySettings settings) { }
    }
}
namespace NServiceBus.Audit
{
    public abstract class AuditAction
    {
        protected AuditAction() { }
        public abstract System.Collections.Generic.IReadOnlyCollection<NServiceBus.Pipeline.IRoutingContext> GetRoutingContexts(NServiceBus.Pipeline.IAuditActionContext context);
    }
    public class RouteToAudit : NServiceBus.Audit.AuditAction
    {
        protected RouteToAudit() { }
        public override System.Collections.Generic.IReadOnlyCollection<NServiceBus.Pipeline.IRoutingContext> GetRoutingContexts(NServiceBus.Pipeline.IAuditActionContext context) { }
    }
}
namespace NServiceBus.AutomaticSubscriptions.Config
{
    public class AutoSubscribeSettings
    {
        public NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings DisableFor(System.Type eventType) { }
        public NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings DisableFor<T>() { }
        public void DoNotAutoSubscribeSagas() { }
    }
}
namespace NServiceBus.Configuration.AdvancedExtensibility
{
    public static class AdvancedExtensibilityExtensions
    {
        public static NServiceBus.Settings.SettingsHolder GetSettings(this NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings config) { }
    }
    public abstract class ExposeSettings
    {
        protected ExposeSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.ConsistencyGuarantees
{
    public static class TransactionModeSettingsExtensions
    {
        public static NServiceBus.TransportTransactionMode GetRequiredTransactionModeForReceives(this NServiceBus.Settings.IReadOnlySettings settings) { }
    }
}
namespace NServiceBus.DataBus
{
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public abstract class DataBusDefinition
    {
        protected DataBusDefinition() { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        protected abstract System.Type ProvidedByFeature();
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public class DataBusExtensions : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public DataBusExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public NServiceBus.DataBus.DataBusExtensions AddDeserializer<TSerializer>()
            where TSerializer : NServiceBus.DataBus.IDataBusSerializer, new () { }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public NServiceBus.DataBus.DataBusExtensions AddDeserializer<TSerializer>(TSerializer serializer)
            where TSerializer : NServiceBus.DataBus.IDataBusSerializer { }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public class DataBusExtensions<T> : NServiceBus.DataBus.DataBusExtensions
        where T : NServiceBus.DataBus.DataBusDefinition
    {
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        public DataBusExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public interface IDataBus
    {
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        System.Threading.Tasks.Task<System.IO.Stream> Get(string key, System.Threading.CancellationToken cancellationToken = default);
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        System.Threading.Tasks.Task<string> Put(System.IO.Stream stream, System.TimeSpan timeToBeReceived, System.Threading.CancellationToken cancellationToken = default);
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        System.Threading.Tasks.Task Start(System.Threading.CancellationToken cancellationToken = default);
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public interface IDataBusSerializer
    {
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        string ContentType { get; }
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        object Deserialize(System.Type propertyType, System.IO.Stream stream);
        [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
            "heck\'. Will be removed in version 11.0.0.", true)]
        void Serialize(object databusProperty, System.IO.Stream stream);
    }
}
namespace NServiceBus.DelayedDelivery
{
    public class DelayDeliveryWith
    {
        public DelayDeliveryWith(System.TimeSpan delay) { }
        public System.TimeSpan Delay { get; }
    }
    public class DoNotDeliverBefore
    {
        public DoNotDeliverBefore(System.DateTimeOffset at) { }
        public System.DateTimeOffset At { get; }
    }
}
namespace NServiceBus.Extensibility
{
    public class ContextBag : NServiceBus.Extensibility.IReadOnlyContextBag
    {
        public ContextBag(NServiceBus.Extensibility.ContextBag? parentBag = null) { }
        public T Get<T>() { }
        public T Get<T>(string key) { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public void Remove(string key) { }
        public void Remove<T>() { }
        public void Set<T>(T t) { }
        public void Set<T>(string key, T t) { }
        public bool TryGet<T>([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T? result) { }
        public bool TryGet<T>(string key, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T? result) { }
    }
    public abstract class ExtendableOptions
    {
        protected ExtendableOptions() { }
    }
    public static class ExtendableOptionsExtensions
    {
        public static NServiceBus.Transport.DispatchProperties GetDispatchProperties(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static NServiceBus.Extensibility.ContextBag GetExtensions(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static NServiceBus.Extensibility.IReadOnlyContextBag GetOperationProperties(this NServiceBus.Pipeline.IOutgoingContext behaviorContext) { }
        public static NServiceBus.Extensibility.IReadOnlyContextBag GetOperationProperties(this NServiceBus.Pipeline.IRoutingContext behaviorContext) { }
        public static NServiceBus.Extensibility.IReadOnlyContextBag GetOperationProperties(this NServiceBus.Pipeline.ISubscribeContext behaviorContext) { }
        public static NServiceBus.Extensibility.IReadOnlyContextBag GetOperationProperties(this NServiceBus.Pipeline.IUnsubscribeContext behaviorContext) { }
    }
    public interface IExtendable
    {
        NServiceBus.Extensibility.ContextBag Extensions { get; }
    }
    public interface IReadOnlyContextBag
    {
        T Get<T>();
        T Get<T>(string key);
        bool TryGet<T>([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T? result);
        bool TryGet<T>(string key, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T? result);
    }
}
namespace NServiceBus.Faults
{
    public class DelayedRetryMessage
    {
        public DelayedRetryMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.ReadOnlyMemory<byte> body, System.Exception exception, int retryAttempt) { }
        public System.ReadOnlyMemory<byte> Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public int RetryAttempt { get; }
    }
    public class FailedMessage
    {
        public FailedMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.ReadOnlyMemory<byte> body, System.Exception exception, string errorQueue) { }
        public System.ReadOnlyMemory<byte> Body { get; }
        public string ErrorQueue { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public static class FaultsHeaderKeys
    {
        public const string ExceptionType = "NServiceBus.ExceptionInfo.ExceptionType";
        public const string FailedQ = "NServiceBus.FailedQ";
        public const string HelpLink = "NServiceBus.ExceptionInfo.HelpLink";
        public const string InnerExceptionType = "NServiceBus.ExceptionInfo.InnerExceptionType";
        public const string Message = "NServiceBus.ExceptionInfo.Message";
        public const string Source = "NServiceBus.ExceptionInfo.Source";
        public const string StackTrace = "NServiceBus.ExceptionInfo.StackTrace";
        public const string TimeOfFailure = "NServiceBus.TimeOfFailure";
    }
    public class ImmediateRetryMessage
    {
        public ImmediateRetryMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.ReadOnlyMemory<byte> body, System.Exception exception, int retryAttempt) { }
        public System.ReadOnlyMemory<byte> Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public int RetryAttempt { get; }
    }
}
namespace NServiceBus.Features
{
    public sealed class Audit : NServiceBus.Features.Feature
    {
        public Audit() { }
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public sealed class AutoSubscribe : NServiceBus.Features.Feature
    {
        public AutoSubscribe() { }
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.Obsolete("The DataBus feature has been released as a dedicated package, \'NServiceBus.ClaimC" +
        "heck\'. Will be removed in version 11.0.0.", true)]
    public class DataBus
    {
        public DataBus() { }
    }
    public abstract class Feature
    {
        protected Feature() { }
        public bool IsActive { get; }
        public bool IsEnabledByDefault { get; }
        public string Name { get; }
        public string Version { get; }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> settings) { }
        protected void DependsOn(string featureTypeName) { }
        protected void DependsOn<TFeature>()
            where TFeature : NServiceBus.Features.Feature, new () { }
        protected void DependsOnAtLeastOne(params System.Type[] features) { }
        protected void DependsOnAtLeastOne(params string[] featureNames) { }
        [System.Obsolete("Use \'DependsOnOptionally<T>()\' instead. Will be removed in version 11.0.0.", true)]
        protected void DependsOnOptionally(System.Type featureType) { }
        protected void DependsOnOptionally(string featureName) { }
        protected void DependsOnOptionally<TFeature>()
            where TFeature : NServiceBus.Features.Feature, new () { }
        protected void Enable<TFeature>()
            where TFeature : NServiceBus.Features.Feature, new () { }
        [System.Obsolete(@"In a future version of NServiceBus, Feature classes will not be automatically discovered by runtime assembly scanning. Instead, create an extension method on EndpointConfiguration and enable the feature within the extension method using EnableFeature<T>(). Will be treated as an error from version 11.0.0. Will be removed in version 12.0.0.", false)]
        protected void EnableByDefault() { }
        protected void Prerequisite(System.Func<NServiceBus.Features.FeatureConfigurationContext, bool> condition, string description) { }
        protected abstract void Setup(NServiceBus.Features.FeatureConfigurationContext context);
        public override string ToString() { }
    }
    public class FeatureConfigurationContext
    {
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        public Microsoft.Extensions.DependencyInjection.IServiceCollection Services { get; }
        public NServiceBus.Settings.IReadOnlySettings Settings { get; }
        public void AddSatelliteReceiver(string name, NServiceBus.Transport.QueueAddress transportAddress, NServiceBus.Transport.PushRuntimeSettings runtimeSettings, System.Func<NServiceBus.RecoverabilityConfig, NServiceBus.Transport.ErrorContext, NServiceBus.RecoverabilityAction> recoverabilityPolicy, NServiceBus.OnSatelliteMessage onMessage) { }
        public void RegisterStartupTask<TTask>()
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<System.IServiceProvider, TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(TTask startupTask)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
    }
    public abstract class FeatureStartupTask
    {
        protected FeatureStartupTask() { }
        protected abstract System.Threading.Tasks.Task OnStart(NServiceBus.IMessageSession session, System.Threading.CancellationToken cancellationToken = default);
        protected abstract System.Threading.Tasks.Task OnStop(NServiceBus.IMessageSession session, System.Threading.CancellationToken cancellationToken = default);
    }
    public enum FeatureState
    {
        Disabled = 0,
        Enabled = 1,
        Active = 2,
        Deactivated = 3,
    }
    public sealed class Outbox : NServiceBus.Features.Feature
    {
        public Outbox() { }
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public sealed class PlatformRetryNotifications : NServiceBus.Features.Feature
    {
        public PlatformRetryNotifications() { }
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public sealed class Sagas : NServiceBus.Features.Feature
    {
        public Sagas() { }
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public static class SettingsExtensions
    {
        public static void EnableFeature<TFeature>(this NServiceBus.Settings.SettingsHolder settings)
            where TFeature : NServiceBus.Features.Feature, new () { }
        [System.Obsolete(@"It is no longer possible to enable features by default on the settings. Features can enable other features by calling Enable<T> in the constructor. Enabling a feature outside the context of another feature can be done by calling EnableFeature<T> on the endpoint configuration or settings. Will be removed in version 11.0.0.", true)]
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault(this NServiceBus.Settings.SettingsHolder settings, System.Type featureType) { }
        [System.Obsolete(@"It is no longer possible to enable features by default on the settings. Features can enable other features by calling Enable<T> in the constructor. Enabling a feature outside the context of another feature can be done by calling EnableFeature<T> on the endpoint configuration or settings. Will be removed in version 11.0.0.", true)]
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault<T>(this NServiceBus.Settings.SettingsHolder settings)
            where T : NServiceBus.Features.Feature { }
        [System.Obsolete("Use \'IsFeatureActive<T>(this IReadOnlySettings settings)\' instead. Will be remove" +
            "d in version 11.0.0.", true)]
        public static bool IsFeatureActive(this NServiceBus.Settings.IReadOnlySettings settings, System.Type featureType) { }
        public static bool IsFeatureActive<TFeature>(this NServiceBus.Settings.IReadOnlySettings settings)
            where TFeature : NServiceBus.Features.Feature { }
        [System.Obsolete("Use \'IsFeatureEnabled<T>(this IReadOnlySettings settings)\' instead. Will be remov" +
            "ed in version 11.0.0.", true)]
        public static bool IsFeatureEnabled(this NServiceBus.Settings.IReadOnlySettings settings, System.Type featureType) { }
        public static bool IsFeatureEnabled<TFeature>(this NServiceBus.Settings.IReadOnlySettings settings)
            where TFeature : NServiceBus.Features.Feature { }
    }
    public sealed class SynchronizedStorage : NServiceBus.Features.Feature
    {
        public SynchronizedStorage() { }
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
}
namespace NServiceBus.Hosting.Helpers
{
    public class AssemblyScanner
    {
        public AssemblyScanner() { }
        public AssemblyScanner(string baseDirectoryToScan) { }
        public bool ScanAppDomainAssemblies { get; set; }
        public bool ScanFileSystemAssemblies { get; set; }
        public bool ThrowExceptions { get; set; }
        public NServiceBus.Hosting.Helpers.AssemblyScannerResults GetScannableAssemblies() { }
    }
    public class AssemblyScannerResults
    {
        public AssemblyScannerResults() { }
        public System.Collections.Generic.List<System.Reflection.Assembly> Assemblies { get; }
        public bool ErrorsThrownDuringScanning { get; }
        public System.Collections.Generic.List<NServiceBus.Hosting.Helpers.SkippedFile> SkippedFiles { get; }
        public System.Collections.Generic.List<System.Type> Types { get; }
    }
    public class SkippedFile
    {
        public string FilePath { get; }
        public string SkipReason { get; }
    }
}
namespace NServiceBus.Hosting
{
    public class HostInformation
    {
        public HostInformation(System.Guid hostId, string displayName) { }
        public HostInformation(System.Guid hostId, string displayName, System.Collections.Generic.Dictionary<string, string> properties) { }
        public string DisplayName { get; }
        public System.Guid HostId { get; }
        public System.Collections.Generic.Dictionary<string, string> Properties { get; }
    }
}
namespace NServiceBus.Installation
{
    public interface INeedToInstallSomething
    {
        System.Threading.Tasks.Task Install(string identity, System.Threading.CancellationToken cancellationToken = default);
    }
    public static class Installer
    {
        public static NServiceBus.Installation.InstallerWithExternallyManagedContainer CreateInstallerWithExternallyManagedContainer(NServiceBus.EndpointConfiguration configuration, Microsoft.Extensions.DependencyInjection.IServiceCollection serviceCollection) { }
        public static System.Threading.Tasks.Task Setup(NServiceBus.EndpointConfiguration configuration, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public class InstallerWithExternallyManagedContainer
    {
        public System.Threading.Tasks.Task Setup(System.IServiceProvider builder, System.Threading.CancellationToken cancellationToken = default) { }
    }
}
namespace NServiceBus.Logging
{
    public class DefaultFactory : NServiceBus.Logging.LoggingFactoryDefinition
    {
        public DefaultFactory() { }
        public void Directory(string directory) { }
        protected override NServiceBus.Logging.ILoggerFactory GetLoggingFactory() { }
        public void Level(NServiceBus.Logging.LogLevel level) { }
    }
    public interface ILog
    {
        bool IsDebugEnabled { get; }
        bool IsErrorEnabled { get; }
        bool IsFatalEnabled { get; }
        bool IsInfoEnabled { get; }
        bool IsWarnEnabled { get; }
        void Debug(string? message);
        void Debug(string? message, System.Exception? exception);
        void DebugFormat(string format, params object?[] args);
        void Error(string? message);
        void Error(string? message, System.Exception? exception);
        void ErrorFormat(string format, params object?[] args);
        void Fatal(string? message);
        void Fatal(string? message, System.Exception? exception);
        void FatalFormat(string format, params object?[] args);
        void Info(string? message);
        void Info(string? message, System.Exception? exception);
        void InfoFormat(string format, params object?[] args);
        void Warn(string? message);
        void Warn(string? message, System.Exception? exception);
        void WarnFormat(string format, params object?[] args);
    }
    public interface ILoggerFactory
    {
        NServiceBus.Logging.ILog GetLogger(System.Type type);
        NServiceBus.Logging.ILog GetLogger(string name);
    }
    public enum LogLevel
    {
        Debug = 0,
        Info = 1,
        Warn = 2,
        Error = 3,
        Fatal = 4,
    }
    public static class LogManager
    {
        public static NServiceBus.Logging.ILog GetLogger(System.Type type) { }
        public static NServiceBus.Logging.ILog GetLogger(string name) { }
        public static NServiceBus.Logging.ILog GetLogger<T>() { }
        public static T Use<T>()
            where T : NServiceBus.Logging.LoggingFactoryDefinition, new () { }
        public static void UseFactory(NServiceBus.Logging.ILoggerFactory loggerFactory) { }
    }
    public abstract class LoggingFactoryDefinition
    {
        protected LoggingFactoryDefinition() { }
        protected abstract NServiceBus.Logging.ILoggerFactory GetLoggingFactory();
    }
}
namespace NServiceBus.MessageInterfaces
{
    public interface IMessageMapper : NServiceBus.IMessageCreator
    {
        System.Type? GetMappedTypeFor(System.Type t);
        System.Type? GetMappedTypeFor(string typeName);
        void Initialize(System.Collections.Generic.IEnumerable<System.Type>? types);
    }
}
namespace NServiceBus.MessageInterfaces.MessageMapper.Reflection
{
    public class MessageMapper : NServiceBus.IMessageCreator, NServiceBus.MessageInterfaces.IMessageMapper
    {
        public MessageMapper() { }
        public object CreateInstance(System.Type t) { }
        public T CreateInstance<T>() { }
        public T CreateInstance<T>(System.Action<T> action) { }
        public System.Type? GetMappedTypeFor(System.Type t) { }
        public System.Type? GetMappedTypeFor(string typeName) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type>? types) { }
    }
}
namespace NServiceBus.MessageMutator
{
    public interface IMutateIncomingMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingMessageContext context);
    }
    public interface IMutateIncomingTransportMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingTransportMessageContext context);
    }
    public interface IMutateOutgoingMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingMessageContext context);
    }
    public interface IMutateOutgoingTransportMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingTransportMessageContext context);
    }
    public class MutateIncomingMessageContext : NServiceBus.ICancellableContext
    {
        public MutateIncomingMessageContext(object message, System.Collections.Generic.Dictionary<string, string> headers, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.CancellationToken CancellationToken { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public object Message { get; set; }
    }
    public class MutateIncomingTransportMessageContext : NServiceBus.ICancellableContext
    {
        public MutateIncomingTransportMessageContext(System.ReadOnlyMemory<byte> body, System.Collections.Generic.Dictionary<string, string> headers, System.Threading.CancellationToken cancellationToken = default) { }
        public System.ReadOnlyMemory<byte> Body { get; set; }
        public System.Threading.CancellationToken CancellationToken { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
    }
    public class MutateOutgoingMessageContext : NServiceBus.ICancellableContext
    {
        public MutateOutgoingMessageContext(object outgoingMessage, System.Collections.Generic.Dictionary<string, string> outgoingHeaders, object? incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string>? incomingHeaders, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.CancellationToken CancellationToken { get; }
        public System.Collections.Generic.Dictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; set; }
        public bool TryGetIncomingHeaders([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.Collections.Generic.IReadOnlyDictionary<string, string>? incomingHeaders) { }
        public bool TryGetIncomingMessage([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out object? incomingMessage) { }
    }
    public class MutateOutgoingTransportMessageContext : NServiceBus.ICancellableContext
    {
        public MutateOutgoingTransportMessageContext(System.ReadOnlyMemory<byte> outgoingBody, object outgoingMessage, System.Collections.Generic.Dictionary<string, string> outgoingHeaders, object? incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string>? incomingHeaders, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.CancellationToken CancellationToken { get; }
        public System.ReadOnlyMemory<byte> OutgoingBody { get; set; }
        public System.Collections.Generic.Dictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; }
        public bool TryGetIncomingHeaders([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out System.Collections.Generic.IReadOnlyDictionary<string, string>? incomingHeaders) { }
        public bool TryGetIncomingMessage([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out object? incomingMessage) { }
    }
    public static class MutatorRegistrationExtensions
    {
        public static void RegisterMessageMutator(this NServiceBus.EndpointConfiguration endpointConfiguration, object messageMutator) { }
    }
}
namespace NServiceBus.Outbox
{
    public interface IOutboxStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Outbox.IOutboxTransaction> BeginTransaction(NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxMessage> Get(string messageId, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task SetAsDispatched(string messageId, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Store(NServiceBus.Outbox.OutboxMessage message, NServiceBus.Outbox.IOutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
    }
    public interface IOutboxTransaction : System.IAsyncDisposable, System.IDisposable
    {
        System.Threading.Tasks.Task Commit(System.Threading.CancellationToken cancellationToken = default);
    }
    public class OutboxMessage
    {
        public OutboxMessage(string messageId, NServiceBus.Outbox.TransportOperation[] operations) { }
        public string MessageId { get; }
        public NServiceBus.Outbox.TransportOperation[] TransportOperations { get; }
    }
    public class OutboxSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings { }
    public class TransportOperation
    {
        public TransportOperation(string messageId, NServiceBus.Transport.DispatchProperties properties, System.ReadOnlyMemory<byte> body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public System.ReadOnlyMemory<byte> Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public NServiceBus.Transport.DispatchProperties Options { get; }
    }
}
namespace NServiceBus.Performance.TimeToBeReceived
{
    public class DiscardIfNotReceivedBefore
    {
        public DiscardIfNotReceivedBefore(System.TimeSpan maxTime) { }
        public System.TimeSpan MaxTime { get; }
    }
}
namespace NServiceBus.Persistence
{
    public static class CompletableSynchronizedStorageSessionExtensions
    {
        public static System.Threading.Tasks.ValueTask Open(this NServiceBus.Persistence.ICompletableSynchronizedStorageSession session, NServiceBus.Pipeline.IIncomingLogicalMessageContext context) { }
        public static System.Threading.Tasks.ValueTask Open(this NServiceBus.Persistence.ICompletableSynchronizedStorageSession session, NServiceBus.Outbox.IOutboxTransaction outboxTransaction, NServiceBus.Transport.TransportTransaction transportTransaction, NServiceBus.Extensibility.ContextBag contextBag, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public interface ICompletableSynchronizedStorageSession : NServiceBus.Persistence.ISynchronizedStorageSession, System.IAsyncDisposable, System.IDisposable
    {
        System.Threading.Tasks.Task CompleteAsync(System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Open(NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.ValueTask<bool> TryOpen(NServiceBus.Outbox.IOutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.ValueTask<bool> TryOpen(NServiceBus.Transport.TransportTransaction transportTransaction, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
    }
    public interface IPersistenceDefinitionFactory<out TDefinition>
        where out TDefinition : NServiceBus.Persistence.PersistenceDefinition, NServiceBus.Persistence.IPersistenceDefinitionFactory<TDefinition>
    {
        TDefinition Create();
    }
    public interface ISynchronizedStorageSession { }
    public abstract class PersistenceDefinition
    {
        protected PersistenceDefinition() { }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> action) { }
        [System.Obsolete("Use \'HasSupportFor<T>()\' instead. Will be removed in version 11.0.0.", true)]
        public bool HasSupportFor(System.Type storageType) { }
        public bool HasSupportFor<T>()
            where T : NServiceBus.StorageType, new () { }
        [System.Obsolete("Use \'Supports<TStorage, TFeature>()\' instead. Will be removed in version 11.0.0.", true)]
        protected void Supports<T>(System.Action<NServiceBus.Settings.SettingsHolder> action)
            where T : NServiceBus.StorageType { }
        protected void Supports<TStorage, TFeature>(NServiceBus.StorageType.Options? options = null)
            where TStorage : NServiceBus.StorageType, new ()
            where TFeature : NServiceBus.Features.Feature, new () { }
    }
}
namespace NServiceBus.Pipeline
{
    public abstract class Behavior<TContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TContext, TContext>
        where TContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected Behavior() { }
        public abstract System.Threading.Tasks.Task Invoke(TContext context, System.Func<System.Threading.Tasks.Task> next);
        public System.Threading.Tasks.Task Invoke(TContext context, System.Func<TContext, System.Threading.Tasks.Task> next) { }
    }
    public abstract class ForkConnector<TFromContext, TForkContext> : NServiceBus.Pipeline.Behavior<TFromContext>, NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TFromContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TForkContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected ForkConnector() { }
        public override sealed System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<System.Threading.Tasks.Task> next) { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<System.Threading.Tasks.Task> next, System.Func<TForkContext, System.Threading.Tasks.Task> fork);
    }
    public interface IAuditActionContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        string AuditAddress { get; }
        System.Collections.Generic.IReadOnlyDictionary<string, string> AuditMetadata { get; }
        NServiceBus.Transport.OutgoingMessage Message { get; }
        System.TimeSpan? TimeToBeReceived { get; }
    }
    public interface IAuditContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Audit.AuditAction AuditAction { get; set; }
        string AuditAddress { get; }
        System.Collections.Generic.Dictionary<string, string> AuditMetadata { get; }
        NServiceBus.Transport.OutgoingMessage Message { get; }
        System.TimeSpan? TimeToBeReceived { get; }
        NServiceBus.Pipeline.IAuditActionContext PreventChanges();
    }
    public interface IBatchDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> Operations { get; }
    }
    public interface IBehavior { }
    public interface IBehaviorContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext
    {
        System.IServiceProvider Builder { get; }
    }
    public interface IBehavior<in TInContext, out TOutContext> : NServiceBus.Pipeline.IBehavior
        where in TInContext : NServiceBus.Pipeline.IBehaviorContext
        where out TOutContext : NServiceBus.Pipeline.IBehaviorContext
    {
        System.Threading.Tasks.Task Invoke(TInContext context, System.Func<TOutContext, System.Threading.Tasks.Task> next);
    }
    public interface IDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.IEnumerable<NServiceBus.Transport.TransportOperation> Operations { get; }
    }
    public interface IIncomingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext { }
    public interface IIncomingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        NServiceBus.Pipeline.LogicalMessage Message { get; }
        bool MessageHandled { get; set; }
        void UpdateMessageInstance(object newInstance);
    }
    public interface IIncomingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        NServiceBus.Transport.IncomingMessage Message { get; }
        void UpdateMessage(System.ReadOnlyMemory<byte> body);
    }
    public interface IInvokeHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IMessageHandlerContext, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        bool HandlerInvocationAborted { get; }
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        object MessageBeingHandled { get; }
        NServiceBus.Pipeline.MessageHandler MessageHandler { get; }
        NServiceBus.Unicast.Messages.MessageMetadata MessageMetadata { get; }
    }
    public interface IOutgoingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        string MessageId { get; }
    }
    public interface IOutgoingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessage(object newInstance);
    }
    public interface IOutgoingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        System.ReadOnlyMemory<byte> Body { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessage(System.ReadOnlyMemory<byte> body);
    }
    public interface IOutgoingPublishContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IOutgoingReplyContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IOutgoingSendContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IRecoverabilityActionContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        int DelayedDeliveriesPerformed { get; }
        System.Exception Exception { get; }
        NServiceBus.Transport.IncomingMessage FailedMessage { get; }
        int ImmediateProcessingFailures { get; }
        System.Collections.Generic.IReadOnlyDictionary<string, string> Metadata { get; }
        string ReceiveAddress { get; }
    }
    public interface IRecoverabilityContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        int DelayedDeliveriesPerformed { get; }
        System.Exception Exception { get; }
        NServiceBus.Transport.IncomingMessage FailedMessage { get; }
        int ImmediateProcessingFailures { get; }
        System.Collections.Generic.Dictionary<string, string> Metadata { get; }
        string ReceiveAddress { get; }
        NServiceBus.RecoverabilityAction RecoverabilityAction { get; set; }
        NServiceBus.RecoverabilityConfig RecoverabilityConfiguration { get; }
        NServiceBus.Pipeline.IRecoverabilityActionContext PreventChanges();
    }
    public interface IRoutingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transport.OutgoingMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; set; }
    }
    public interface ISubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Type[] EventTypes { get; }
    }
    public interface ITransportReceiveContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transport.IncomingMessage Message { get; }
    }
    public interface IUnsubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Type EventType { get; }
    }
    public class LogicalMessage
    {
        public LogicalMessage(NServiceBus.Unicast.Messages.MessageMetadata metadata, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Unicast.Messages.MessageMetadata Metadata { get; }
    }
    public class LogicalMessageFactory
    {
        public LogicalMessageFactory(NServiceBus.Unicast.Messages.MessageMetadataRegistry messageMetadataRegistry, NServiceBus.MessageInterfaces.IMessageMapper messageMapper) { }
        public NServiceBus.Pipeline.LogicalMessage Create(object message) { }
        public NServiceBus.Pipeline.LogicalMessage Create(System.Type messageType, object message) { }
    }
    public class MessageHandler
    {
        public MessageHandler() { }
        [System.Obsolete("Use \'MessageHandler()\' instead. Will be removed in version 11.0.0.", true)]
        public MessageHandler(System.Func<object, object, NServiceBus.IMessageHandlerContext, System.Threading.Tasks.Task> invocation, System.Type handlerType) { }
        public virtual required System.Type HandlerType { get; init; }
        public virtual object? Instance { get; set; }
        public virtual System.Threading.Tasks.Task Invoke(object message, NServiceBus.IMessageHandlerContext handlerContext) { }
    }
    public class OutgoingLogicalMessage
    {
        public OutgoingLogicalMessage(System.Type messageType, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
    }
    public class PipelineSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public void Register(NServiceBus.Pipeline.RegisterStep registration) { }
        public void Register(System.Type behavior, string description) { }
        public void Register(string stepId, System.Type behavior, string description) { }
        public void Register<TRegisterStep>()
            where TRegisterStep : NServiceBus.Pipeline.RegisterStep, new () { }
        public void Register<T>(System.Func<System.IServiceProvider, T> factoryMethod, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(T behavior, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(string stepId, System.Func<System.IServiceProvider, T> factoryMethod, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(string stepId, T behavior, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void RegisterOrReplace(string stepId, System.Type behavior, string? description = null) { }
        public void RegisterOrReplace<T>(string stepId, System.Func<System.IServiceProvider, T> factoryMethod, string? description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void RegisterOrReplace<T>(string stepId, T behavior, string? description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Replace(string stepId, System.Type newBehavior, string? description = null) { }
        public void Replace<T>(string stepId, System.Func<System.IServiceProvider, T> factoryMethod, string? description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Replace<T>(string stepId, T newBehavior, string? description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
    }
    public abstract class PipelineTerminator<T> : NServiceBus.Pipeline.StageConnector<T, NServiceBus.Pipeline.PipelineTerminator<T>.ITerminatingContext>
        where T : NServiceBus.Pipeline.IBehaviorContext
    {
        protected PipelineTerminator() { }
        public override sealed System.Threading.Tasks.Task Invoke(T context, System.Func<NServiceBus.Pipeline.PipelineTerminator<T>.ITerminatingContext, System.Threading.Tasks.Task> next) { }
        protected abstract System.Threading.Tasks.Task Terminate(T context);
        public interface ITerminatingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.ICancellableContext, NServiceBus.Pipeline.IBehaviorContext { }
    }
    [System.Diagnostics.DebuggerDisplay("{StepId}({BehaviorType.FullName}) - {Description}")]
    public abstract class RegisterStep
    {
        protected RegisterStep(string stepId, System.Type behavior, string? description, System.Func<System.IServiceProvider, NServiceBus.Pipeline.IBehavior>? factoryMethod = null) { }
        public System.Type BehaviorType { get; }
        public string Description { get; }
        public string StepId { get; }
        public void InsertAfter(string id) { }
        public void InsertAfterIfExists(string id) { }
        public void InsertBefore(string id) { }
        public void InsertBeforeIfExists(string id) { }
    }
    public abstract class StageConnector<TFromContext, TToContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TToContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TToContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected StageConnector() { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> stage);
    }
    public abstract class StageForkConnector<TFromContext, TToContext, TForkContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TToContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TToContext : NServiceBus.Pipeline.IBehaviorContext
        where TForkContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected StageForkConnector() { }
        public System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> next) { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> stage, System.Func<TForkContext, System.Threading.Tasks.Task> fork);
    }
    public static class TransportMessageContextExtensions
    {
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out NServiceBus.Transport.IncomingMessage? message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingPhysicalMessageContext context, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out NServiceBus.Transport.IncomingMessage? message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingReplyContext context, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out NServiceBus.Transport.IncomingMessage? message) { }
    }
}
namespace NServiceBus.Recoverability
{
    public static class RecoverabilityContextExtensions
    {
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.IRecoverabilityActionContext context, NServiceBus.Transport.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy) { }
    }
}
namespace NServiceBus.Routing
{
    public abstract class AddressTag
    {
        protected AddressTag() { }
    }
    public class DistributionContext : NServiceBus.Extensibility.IExtendable
    {
        public DistributionContext(string[] receiverAddresses, NServiceBus.Pipeline.OutgoingLogicalMessage message, string messageId, System.Collections.Generic.Dictionary<string, string> headers, NServiceBus.Transport.ITransportAddressResolver addressTranslation, NServiceBus.Extensibility.ContextBag extensions) { }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
        public string MessageId { get; }
        public string[] ReceiverAddresses { get; }
        public string ToTransportAddress(NServiceBus.Routing.EndpointInstance endpointInstance) { }
    }
    public abstract class DistributionStrategy
    {
        protected DistributionStrategy(string endpoint, NServiceBus.DistributionStrategyScope scope) { }
        public string Endpoint { get; }
        public NServiceBus.DistributionStrategyScope Scope { get; }
        public abstract string SelectDestination(NServiceBus.Routing.DistributionContext context);
    }
    public sealed class EndpointInstance
    {
        public EndpointInstance(string endpoint, string discriminator = null, System.Collections.Generic.IReadOnlyDictionary<string, string> properties = null) { }
        public string Discriminator { get; }
        public string Endpoint { get; }
        public System.Collections.Generic.IReadOnlyDictionary<string, string> Properties { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public NServiceBus.Routing.EndpointInstance SetProperty(string key, string value) { }
        public override string ToString() { }
        public static bool operator !=(NServiceBus.Routing.EndpointInstance left, NServiceBus.Routing.EndpointInstance right) { }
        public static bool operator ==(NServiceBus.Routing.EndpointInstance left, NServiceBus.Routing.EndpointInstance right) { }
    }
    public class EndpointInstances
    {
        public EndpointInstances() { }
        public void AddOrReplaceInstances(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.EndpointInstance> endpointInstances) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Routing.EndpointInstance> FindInstances(string endpoint) { }
    }
    public interface IMessageDrivenSubscriptionTransport { }
    public class MulticastAddressTag : NServiceBus.Routing.AddressTag
    {
        public MulticastAddressTag(System.Type messageType) { }
        public System.Type MessageType { get; }
    }
    public class MulticastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public MulticastRoutingStrategy(System.Type messageType) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public class RouteTableEntry
    {
        public RouteTableEntry(System.Type messageType, NServiceBus.Routing.UnicastRoute route) { }
        public System.Type MessageType { get; }
        public NServiceBus.Routing.UnicastRoute Route { get; }
    }
    public abstract class RoutingStrategy
    {
        protected RoutingStrategy() { }
        public abstract NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers);
    }
    public class SingleInstanceRoundRobinDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public SingleInstanceRoundRobinDistributionStrategy(string endpoint, NServiceBus.DistributionStrategyScope scope) { }
        public override string SelectDestination(NServiceBus.Routing.DistributionContext context) { }
    }
    public class UnicastAddressTag : NServiceBus.Routing.AddressTag
    {
        public UnicastAddressTag(string destination) { }
        public string Destination { get; }
    }
    public class UnicastRoute
    {
        public string Endpoint { get; }
        public NServiceBus.Routing.EndpointInstance Instance { get; }
        public string PhysicalAddress { get; }
        public override string ToString() { }
        public static NServiceBus.Routing.UnicastRoute CreateFromEndpointInstance(NServiceBus.Routing.EndpointInstance instance) { }
        public static NServiceBus.Routing.UnicastRoute CreateFromEndpointName(string endpoint) { }
        public static NServiceBus.Routing.UnicastRoute CreateFromPhysicalAddress(string physicalAddress) { }
    }
    public class UnicastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public UnicastRoutingStrategy(string destination) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public class UnicastRoutingTable
    {
        public UnicastRoutingTable() { }
        public void AddOrReplaceRoutes(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.RouteTableEntry> entries) { }
    }
}
namespace NServiceBus.Routing.MessageDrivenSubscriptions
{
    public class PublisherAddress
    {
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromEndpointInstances(params NServiceBus.Routing.EndpointInstance[] instances) { }
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromEndpointName(string endpoint) { }
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromPhysicalAddresses(params string[] addresses) { }
    }
    public class PublisherTableEntry
    {
        public PublisherTableEntry(System.Type eventType, NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress address) { }
        public NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress Address { get; }
        public System.Type EventType { get; }
    }
    public class Publishers
    {
        public Publishers() { }
        public void AddOrReplacePublishers(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.MessageDrivenSubscriptions.PublisherTableEntry> entries) { }
    }
}
namespace NServiceBus.Sagas
{
    public class ActiveSagaInstance
    {
        public ActiveSagaInstance(NServiceBus.Saga saga, NServiceBus.Sagas.SagaMetadata metadata, System.Func<System.DateTimeOffset> currentDateTimeOffsetProvider) { }
        public System.DateTimeOffset Created { get; }
        public NServiceBus.Saga Instance { get; }
        public bool IsNew { get; }
        public System.DateTimeOffset Modified { get; }
        public bool NotFound { get; }
        public string SagaId { get; }
        public void AttachNewEntity(NServiceBus.IContainSagaData sagaEntity) { }
    }
    public abstract class CorrelationPropertyAccessor
    {
        protected CorrelationPropertyAccessor() { }
        public abstract object? AccessFrom(NServiceBus.IContainSagaData sagaData);
        public abstract void WriteTo(NServiceBus.IContainSagaData sagaData, object value);
    }
    public interface IFinder { }
    [System.Obsolete(@"Saga not found handlers are no longer automatically registered during assembly scanning. Handlers are no longer global and should be registered for each saga using mapper.ConfigureNotFoundHandler<MyNotFoundHandler>(). Use 'ISagaNotFoundHandler' instead. Will be removed in version 11.0.0.", true)]
    public interface IHandleSagaNotFound
    {
        System.Threading.Tasks.Task Handle(object message, NServiceBus.IMessageProcessingContext context);
    }
    public interface ISagaFinder<TSagaData, TMessage> : NServiceBus.Sagas.IFinder
        where TSagaData : NServiceBus.IContainSagaData
    {
        System.Threading.Tasks.Task<TSagaData?> FindBy(TMessage message, NServiceBus.Persistence.ISynchronizedStorageSession storageSession, NServiceBus.Extensibility.IReadOnlyContextBag context, System.Threading.CancellationToken cancellationToken = default);
    }
    public interface ISagaIdGenerator
    {
        System.Guid Generate(NServiceBus.Sagas.SagaIdGeneratorContext context);
    }
    public interface ISagaPersister
    {
        System.Threading.Tasks.Task Complete(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.ISynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(System.Guid sagaId, NServiceBus.Persistence.ISynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default)
            where TSagaData :  class, NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(string propertyName, object propertyValue, NServiceBus.Persistence.ISynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default)
            where TSagaData :  class, NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task Save(NServiceBus.IContainSagaData sagaData, NServiceBus.Sagas.SagaCorrelationProperty correlationProperty, NServiceBus.Persistence.ISynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Update(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.ISynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
    }
    public abstract class MessagePropertyAccessor
    {
        protected MessagePropertyAccessor() { }
        public abstract System.Type MessageType { get; }
        public abstract object? AccessFrom(object message);
    }
    public abstract class MessagePropertyAccessor<TMessage> : NServiceBus.Sagas.MessagePropertyAccessor
    {
        protected MessagePropertyAccessor() { }
        public override sealed System.Type MessageType { get; }
        protected abstract object? AccessFrom(TMessage message);
        public override sealed object? AccessFrom(object message) { }
    }
    public class SagaCorrelationProperty
    {
        public SagaCorrelationProperty(string name, object value) { }
        public string Name { get; }
        public object Value { get; }
        public static NServiceBus.Sagas.SagaCorrelationProperty None { get; }
    }
    public class SagaFinderDefinition
    {
        public System.Type MessageType { get; }
        [System.Obsolete("Use MessageType.FullName instead. Will be removed in version 11.0.0.", true)]
        public string MessageTypeName { get; }
        [System.Obsolete("Finder properties are no longer used. Will be removed in version 11.0.0.", true)]
        public System.Collections.Generic.Dictionary<string, object> Properties { get; }
        public System.Type Type { get; }
    }
    public class SagaIdGeneratorContext : NServiceBus.Extensibility.IExtendable
    {
        public SagaIdGeneratorContext(NServiceBus.Sagas.SagaCorrelationProperty correlationProperty, NServiceBus.Sagas.SagaMetadata sagaMetadata, NServiceBus.Extensibility.ContextBag extensions) { }
        public NServiceBus.Sagas.SagaCorrelationProperty CorrelationProperty { get; }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public NServiceBus.Sagas.SagaMetadata SagaMetadata { get; }
    }
    public sealed class SagaMessage : System.IEquatable<NServiceBus.Sagas.SagaMessage>
    {
        public SagaMessage(System.Type messageType, bool isAllowedToStart, bool isTimeout) { }
        public bool IsAllowedToStartSaga { get; }
        public bool IsTimeout { get; }
        public System.Type MessageType { get; }
        public string MessageTypeName { get; }
    }
    public class SagaMetadata
    {
        [System.Obsolete("Use SagaMetadata.Create to create metadata objects. Will be removed in version 11" +
            ".0.0.", true)]
        public SagaMetadata(string name, System.Type sagaType, string entityName, System.Type sagaEntityType, NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata correlationProperty, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> messages, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> finders) { }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> AssociatedMessages { get; }
        public string EntityName { get; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> Finders { get; }
        public string Name { get; }
        public System.Type SagaEntityType { get; }
        public System.Type SagaType { get; }
        public bool IsMessageAllowedToStartTheSaga(string messageType) { }
        public bool TryGetCorrelationProperty([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata? property) { }
        public bool TryGetFinder(string messageType, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out NServiceBus.Sagas.SagaFinderDefinition? finderDefinition) { }
        [System.Obsolete("Use \'Create<TSagaType>()\' instead. Will be removed in version 11.0.0.", true)]
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType) { }
        [System.Obsolete("Use the overload without available types and conventions. Will be removed in vers" +
            "ion 11.0.0.", true)]
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType, System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
        public static NServiceBus.Sagas.SagaMetadata Create<TSaga>()
            where TSaga : NServiceBus.Saga { }
        public static NServiceBus.Sagas.SagaMetadata Create<TSaga, TSagaData>(System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> associatedMessages, NServiceBus.Sagas.CorrelationPropertyAccessor? correlationPropertyAccessor = null, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.MessagePropertyAccessor>? propertyAccessors = null)
            where TSaga : NServiceBus.Saga<TSagaData>
            where TSagaData :  class, NServiceBus.IContainSagaData, new () { }
        public static System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMetadata> CreateMany(System.Collections.Generic.IEnumerable<System.Type> sagaTypes) { }
        public class CorrelationPropertyMetadata
        {
            public CorrelationPropertyMetadata(string name, System.Type type, NServiceBus.Sagas.CorrelationPropertyAccessor propertyAccessor) { }
            public NServiceBus.Sagas.CorrelationPropertyAccessor Accessor { get; }
            public string Name { get; }
            public System.Type Type { get; }
        }
    }
    public class SagaMetadataCollection : System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMetadata>, System.Collections.IEnumerable
    {
        public SagaMetadataCollection() { }
        public bool HasMetadata { get; }
        public void Add(NServiceBus.Sagas.SagaMetadata metadata) { }
        public void AddRange(System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMetadata> metadata) { }
        public NServiceBus.Sagas.SagaMetadata Find(System.Type sagaType) { }
        public NServiceBus.Sagas.SagaMetadata FindByEntity(System.Type entityType) { }
        public System.Collections.Generic.IEnumerator<NServiceBus.Sagas.SagaMetadata> GetEnumerator() { }
        [System.Obsolete("Use \'SagaMetadata.CreateMany\' instead. Will be removed in version 11.0.0.", true)]
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes) { }
        [System.Obsolete("Use \'SagaMetadata.CreateMany\' instead. Will be removed in version 11.0.0.", true)]
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
    }
    public class SagaSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public void DisableBestPracticeValidation() { }
    }
}
namespace NServiceBus.Serialization
{
    public interface IMessageSerializer
    {
        string ContentType { get; }
        object[] Deserialize(System.ReadOnlyMemory<byte> body, System.Collections.Generic.IList<System.Type> messageTypes = null);
        void Serialize(object message, System.IO.Stream stream);
    }
    public abstract class SerializationDefinition
    {
        protected SerializationDefinition() { }
        public abstract System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.IReadOnlySettings settings);
    }
    public class SerializationExtensions<T> : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
        where T : NServiceBus.Serialization.SerializationDefinition
    {
        public SerializationExtensions(NServiceBus.Settings.SettingsHolder serializerSettings, NServiceBus.Settings.SettingsHolder endpointConfigurationSettings) { }
    }
}
namespace NServiceBus.Settings
{
    public interface IReadOnlySettings
    {
        object Get(string key);
        T Get<T>();
        T Get<T>(string key);
        T GetOrDefault<T>();
        T GetOrDefault<T>(string key);
        bool HasExplicitValue(string key);
        bool HasExplicitValue<T>();
        bool HasSetting(string key);
        bool HasSetting<T>();
        bool TryGet<T>(out T val);
        bool TryGet<T>(string key, out T val);
    }
    public class SettingsHolder : NServiceBus.Settings.IReadOnlySettings
    {
        public SettingsHolder() { }
        public void Clear() { }
        public object Get(string key) { }
        public T Get<T>() { }
        public T Get<T>(string key) { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public T GetOrDefault<T>() { }
        public T GetOrDefault<T>(string key) { }
        public bool HasExplicitValue(string key) { }
        public bool HasExplicitValue<T>() { }
        public bool HasSetting(string key) { }
        public bool HasSetting<T>() { }
        public void Set(string key, object value) { }
        public void Set<T>(System.Action value) { }
        public void Set<T>(T value) { }
        public void SetDefault(string key, object value) { }
        public void SetDefault<T>(System.Action value) { }
        public void SetDefault<T>(T value) { }
        public bool TryGet<T>(out T val) { }
        public bool TryGet<T>(string key, out T val) { }
    }
}
namespace NServiceBus.Support
{
    public static class RuntimeEnvironment
    {
        public static string MachineName { get; }
    }
}
namespace NServiceBus.Transport
{
    public enum DispatchConsistency
    {
        Default = 1,
        Isolated = 2,
    }
    public class DispatchProperties : System.Collections.Generic.Dictionary<string, string>
    {
        public DispatchProperties() { }
        public DispatchProperties(System.Collections.Generic.Dictionary<string, string> properties) { }
        public NServiceBus.DelayedDelivery.DelayDeliveryWith DelayDeliveryWith { get; set; }
        public NServiceBus.Performance.TimeToBeReceived.DiscardIfNotReceivedBefore DiscardIfNotReceivedBefore { get; set; }
        public NServiceBus.DelayedDelivery.DoNotDeliverBefore DoNotDeliverBefore { get; set; }
    }
    public class ErrorContext
    {
        public ErrorContext(System.Exception exception, System.Collections.Generic.Dictionary<string, string> headers, string nativeMessageId, System.ReadOnlyMemory<byte> body, NServiceBus.Transport.TransportTransaction transportTransaction, int immediateProcessingFailures, string receiveAddress, NServiceBus.Extensibility.ContextBag context) { }
        public int DelayedDeliveriesPerformed { get; }
        public System.Exception Exception { get; }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public int ImmediateProcessingFailures { get; }
        public NServiceBus.Transport.IncomingMessage Message { get; }
        public string ReceiveAddress { get; }
        public NServiceBus.Transport.TransportTransaction TransportTransaction { get; }
    }
    public enum ErrorHandleResult
    {
        Handled = 0,
        RetryRequired = 1,
    }
    public class HostSettings
    {
        public HostSettings(string name, string hostDisplayName, NServiceBus.StartupDiagnosticEntries startupDiagnostic, System.Action<string, System.Exception, System.Threading.CancellationToken> criticalErrorAction, bool setupInfrastructure, NServiceBus.Settings.IReadOnlySettings? coreSettings = null) { }
        public NServiceBus.Settings.IReadOnlySettings? CoreSettings { get; }
        public System.Action<string, System.Exception, System.Threading.CancellationToken> CriticalErrorAction { get; }
        public string HostDisplayName { get; }
        [System.Diagnostics.CodeAnalysis.MemberNotNullWhen(false, "CoreSettings")]
        [get: System.Diagnostics.CodeAnalysis.MemberNotNullWhen(false, "CoreSettings")]
        public bool IsRawMode { get; }
        public string Name { get; }
        public System.IServiceProvider? ServiceProvider { get; set; }
        public bool SetupInfrastructure { get; }
        public NServiceBus.StartupDiagnosticEntries StartupDiagnostic { get; }
        [System.Diagnostics.CodeAnalysis.MemberNotNullWhen(true, "ServiceProvider")]
        [get: System.Diagnostics.CodeAnalysis.MemberNotNullWhen(true, "ServiceProvider")]
        public bool SupportsDependencyInjection { get; }
    }
    public interface IMessageDispatcher
    {
        System.Threading.Tasks.Task Dispatch(NServiceBus.Transport.TransportOperations outgoingMessages, NServiceBus.Transport.TransportTransaction transaction, System.Threading.CancellationToken cancellationToken = default);
    }
    public interface IMessageReceiver
    {
        string Id { get; }
        string ReceiveAddress { get; }
        NServiceBus.Transport.ISubscriptionManager Subscriptions { get; }
        System.Threading.Tasks.Task ChangeConcurrency(NServiceBus.Transport.PushRuntimeSettings limitations, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Initialize(NServiceBus.Transport.PushRuntimeSettings limitations, NServiceBus.Transport.OnMessage onMessage, NServiceBus.Transport.OnError onError, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task StartReceive(System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task StopReceive(System.Threading.CancellationToken cancellationToken = default);
    }
    public interface IOutgoingTransportOperation
    {
        NServiceBus.Transport.OutgoingMessage Message { get; }
        NServiceBus.Transport.DispatchProperties Properties { get; }
        NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
    public interface ISubscriptionManager
    {
        System.Threading.Tasks.Task SubscribeAll(NServiceBus.Unicast.Messages.MessageMetadata[] eventTypes, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Unsubscribe(NServiceBus.Unicast.Messages.MessageMetadata eventType, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
    }
    public interface ITransportAddressResolver
    {
        string ToTransportAddress(NServiceBus.Transport.QueueAddress queueAddress);
    }
    public class IncomingMessage
    {
        public IncomingMessage(string nativeMessageId, System.Collections.Generic.Dictionary<string, string> headers, System.ReadOnlyMemory<byte> body) { }
        public System.ReadOnlyMemory<byte> Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public string NativeMessageId { get; }
    }
    public static class IncomingMessageExtensions
    {
        public static NServiceBus.MessageIntent GetMessageIntent(this NServiceBus.Transport.IncomingMessage message) { }
        public static string GetReplyToAddress(this NServiceBus.Transport.IncomingMessage message) { }
    }
    public class MessageContext : NServiceBus.Extensibility.IExtendable
    {
        public MessageContext(string nativeMessageId, System.Collections.Generic.Dictionary<string, string> headers, System.ReadOnlyMemory<byte> body, NServiceBus.Transport.TransportTransaction transportTransaction, string receiveAddress, NServiceBus.Extensibility.ContextBag context) { }
        public System.ReadOnlyMemory<byte> Body { get; }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string NativeMessageId { get; }
        public string ReceiveAddress { get; }
        public NServiceBus.Transport.TransportTransaction TransportTransaction { get; }
    }
    public class MulticastTransportOperation : NServiceBus.Transport.IOutgoingTransportOperation
    {
        public MulticastTransportOperation(NServiceBus.Transport.OutgoingMessage message, System.Type messageType, NServiceBus.Transport.DispatchProperties properties, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1) { }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Transport.DispatchProperties Properties { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
    public delegate System.Threading.Tasks.Task<NServiceBus.Transport.ErrorHandleResult> OnError(NServiceBus.Transport.ErrorContext errorContext, System.Threading.CancellationToken cancellationToken = default);
    public delegate System.Threading.Tasks.Task OnMessage(NServiceBus.Transport.MessageContext messageContext, System.Threading.CancellationToken cancellationToken = default);
    public class OutgoingMessage
    {
        public OutgoingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.ReadOnlyMemory<byte> body) { }
        public System.ReadOnlyMemory<byte> Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public void UpdateBody(System.ReadOnlyMemory<byte> updatedBody) { }
    }
    public class PushRuntimeSettings
    {
        public PushRuntimeSettings() { }
        public PushRuntimeSettings(int maxConcurrency) { }
        public int MaxConcurrency { get; }
        public static NServiceBus.Transport.PushRuntimeSettings Default { get; }
    }
    public class QueueAddress
    {
        public QueueAddress(string baseAddress, string discriminator = null, System.Collections.Generic.IReadOnlyDictionary<string, string> properties = null, string qualifier = null) { }
        public string BaseAddress { get; }
        public string Discriminator { get; }
        public System.Collections.Generic.IReadOnlyDictionary<string, string> Properties { get; }
        public string Qualifier { get; }
        public override string ToString() { }
    }
    public class QueueBindings
    {
        public QueueBindings() { }
        public System.Collections.Generic.IReadOnlyCollection<string> SendingAddresses { get; }
        public void BindSending(string transportAddress) { }
    }
    public class ReceiveSettings
    {
        public ReceiveSettings(string id, NServiceBus.Transport.QueueAddress receiveAddress, bool usePublishSubscribe, bool purgeOnStartup, string errorQueue) { }
        public string ErrorQueue { get; }
        public string Id { get; set; }
        public bool PurgeOnStartup { get; set; }
        public NServiceBus.Transport.QueueAddress ReceiveAddress { get; }
        public bool UsePublishSubscribe { get; set; }
    }
    public abstract class TransportDefinition
    {
        protected TransportDefinition(NServiceBus.TransportTransactionMode defaultTransactionMode, bool supportsDelayedDelivery, bool supportsPublishSubscribe, bool supportsTTBR) { }
        public bool SupportsDelayedDelivery { get; }
        public bool SupportsPublishSubscribe { get; }
        public bool SupportsTTBR { get; }
        public virtual NServiceBus.TransportTransactionMode TransportTransactionMode { get; set; }
        public void ConfigureServices(Microsoft.Extensions.DependencyInjection.IServiceCollection services) { }
        protected virtual void ConfigureServicesCore(Microsoft.Extensions.DependencyInjection.IServiceCollection services) { }
        protected void EnableEndpointFeature<T>()
            where T : NServiceBus.Features.Feature, new () { }
        public abstract System.Collections.Generic.IReadOnlyCollection<NServiceBus.TransportTransactionMode> GetSupportedTransactionModes();
        public abstract System.Threading.Tasks.Task<NServiceBus.Transport.TransportInfrastructure> Initialize(NServiceBus.Transport.HostSettings hostSettings, NServiceBus.Transport.ReceiveSettings[] receivers, string[] sendingAddresses, System.Threading.CancellationToken cancellationToken = default);
    }
    public abstract class TransportInfrastructure
    {
        protected TransportInfrastructure() { }
        public NServiceBus.Transport.IMessageDispatcher Dispatcher { get; protected set; }
        public System.Collections.Generic.IReadOnlyDictionary<string, NServiceBus.Transport.IMessageReceiver> Receivers { get; protected set; }
        public abstract System.Threading.Tasks.Task Shutdown(System.Threading.CancellationToken cancellationToken = default);
        public abstract string ToTransportAddress(NServiceBus.Transport.QueueAddress address);
    }
    public class TransportOperation
    {
        public TransportOperation(NServiceBus.Transport.OutgoingMessage message, NServiceBus.Routing.AddressTag addressTag, NServiceBus.Transport.DispatchProperties properties = null, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1) { }
        public NServiceBus.Routing.AddressTag AddressTag { get; }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public NServiceBus.Transport.DispatchProperties Properties { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; set; }
    }
    public class TransportOperations
    {
        public TransportOperations(params NServiceBus.Transport.TransportOperation[] transportOperations) { }
        public System.Collections.Generic.List<NServiceBus.Transport.MulticastTransportOperation> MulticastTransportOperations { get; }
        public System.Collections.Generic.List<NServiceBus.Transport.UnicastTransportOperation> UnicastTransportOperations { get; }
    }
    public sealed class TransportTransaction : NServiceBus.Extensibility.ContextBag
    {
        public TransportTransaction() { }
    }
    public class UnicastTransportOperation : NServiceBus.Transport.IOutgoingTransportOperation
    {
        public UnicastTransportOperation(NServiceBus.Transport.OutgoingMessage message, string destination, NServiceBus.Transport.DispatchProperties properties, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1) { }
        public string Destination { get; }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public NServiceBus.Transport.DispatchProperties Properties { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
}
namespace NServiceBus.Unicast
{
    public class MessageEventArgs : System.EventArgs
    {
        public MessageEventArgs(object msg) { }
        public object Message { get; }
    }
    public class MessageHandlerRegistry
    {
        public MessageHandlerRegistry() { }
        public void AddHandler<THandler>()
            where THandler : NServiceBus.IHandleMessages { }
        public void AddMessageHandlerForMessage<THandler, TMessage>()
            where THandler :  class, NServiceBus.IHandleMessages<TMessage> { }
        public void AddScannedHandlers(System.Collections.Generic.IEnumerable<System.Type> orderedTypes) { }
        public void AddTimeoutHandlerForMessage<THandler, TMessage>()
            where THandler :  class, NServiceBus.IHandleTimeouts<TMessage> { }
        public void Clear() { }
        public System.Collections.Generic.List<NServiceBus.Pipeline.MessageHandler> GetHandlersFor(System.Type messageType) { }
        public System.Collections.Generic.IEnumerable<System.Type> GetMessageTypes() { }
        [System.Obsolete("Deprecated in favor of a strongly-typed alternative. Use \'AddHandler<THandler>()\'" +
            " instead. Will be treated as an error from version 11.0.0. Will be removed in ve" +
            "rsion 12.0.0.", false)]
        public void RegisterHandler(System.Type handlerType) { }
    }
    public class MessagesEventArgs : System.EventArgs
    {
        public MessagesEventArgs(object[] messages) { }
        public object[] Messages { get; }
    }
}
namespace NServiceBus.Unicast.Messages
{
    public class MessageMetadata
    {
        public MessageMetadata(System.Type messageType) { }
        public MessageMetadata(System.Type messageType, System.Type[] messageHierarchy) { }
        public System.Type[] MessageHierarchy { get; }
        public string MessageHierarchySerialized { get; }
        public System.Type MessageType { get; }
    }
    public class MessageMetadataRegistry
    {
        public MessageMetadataRegistry() { }
        [System.Obsolete("Use \'MessageMetadataRegistry.Initialize\' instead. Will be removed in version 11.0" +
            ".0.", true)]
        public MessageMetadataRegistry(System.Func<System.Type, bool> isMessageType, bool allowDynamicTypeLoading) { }
        public NServiceBus.Unicast.Messages.MessageMetadata[] GetAllMessages() { }
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(System.Type messageType) { }
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(string messageTypeIdentifier) { }
        public void Initialize(System.Func<System.Type, bool> isMessageType, bool allowDynamicTypeLoading) { }
        public void RegisterMessageTypeWithHierarchy(System.Type messageType, System.Collections.Generic.IEnumerable<System.Type> parentMessages) { }
        public void RegisterMessageTypes(System.Collections.Generic.IEnumerable<System.Type> messageTypes) { }
    }
}
namespace NServiceBus.Unicast.Queuing
{
    public class QueueNotFoundException : System.Exception
    {
        public QueueNotFoundException() { }
        public QueueNotFoundException(string queue, string message, System.Exception inner) { }
        public string Queue { get; set; }
    }
}
namespace NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions
{
    public interface ISubscriptionStorage
    {
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber>> GetSubscriberAddressesForMessage(System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Subscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, NServiceBus.Unicast.Subscriptions.MessageType messageType, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
        System.Threading.Tasks.Task Unsubscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, NServiceBus.Unicast.Subscriptions.MessageType messageType, NServiceBus.Extensibility.ContextBag context, System.Threading.CancellationToken cancellationToken = default);
    }
    public class Subscriber
    {
        public Subscriber(string transportAddress, string endpoint) { }
        public string Endpoint { get; }
        public string TransportAddress { get; }
    }
}
namespace NServiceBus.Unicast.Subscriptions
{
    public class MessageType
    {
        public MessageType(System.Type type) { }
        public MessageType(string messageTypeString) { }
        public MessageType(string typeName, System.Version version) { }
        public MessageType(string typeName, string versionString) { }
        public string TypeName { get; }
        public System.Version Version { get; }
        public bool Equals(NServiceBus.Unicast.Subscriptions.MessageType other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
        public static bool operator !=(NServiceBus.Unicast.Subscriptions.MessageType left, NServiceBus.Unicast.Subscriptions.MessageType right) { }
        public static bool operator ==(NServiceBus.Unicast.Subscriptions.MessageType left, NServiceBus.Unicast.Subscriptions.MessageType right) { }
    }
}
namespace NServiceBus.Unicast.Transport
{
    public static class ControlMessageFactory
    {
        public static NServiceBus.Transport.OutgoingMessage Create(NServiceBus.MessageIntent intent) { }
    }
}