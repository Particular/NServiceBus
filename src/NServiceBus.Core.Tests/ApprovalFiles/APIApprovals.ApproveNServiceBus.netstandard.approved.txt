[assembly: System.CLSCompliantAttribute(true)]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.AcceptanceTesting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Core.Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.Hosting.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100dde965e6172e019ac82c2639ffe494dd2e7dd16347c34762a05732b492e110f2e4e2e1b5ef2d85c848ccfb671ee20a47c8d1376276708dc30a90ff1121b647ba3b7259a6bc383b2034938ef0e275b58b920375ac605076178123693c6c4f1331661a62eba28c249386855637780e3ff5f23a6d854700eaa6803ef48907513b92")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(@"NServiceBus.PerformanceTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001007f16e21368ff041183fab592d9e8ed37e7be355e93323147a1d29983d6e591b04282e4da0c9e18bd901e112c0033925eb7d7872c2f1706655891c5c9d57297994f707d16ee9a8f40d978f064ee1ffc73c0db3f4712691b23bf596f75130f4ec978cf78757ec034625a5f27e6bb50c618931ea49f6f628fd74271c32959efb1c5")]
[assembly: System.Runtime.InteropServices.ComVisibleAttribute(false)]
[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.0", FrameworkDisplayName="")]
namespace NServiceBus
{
    public enum AddressMode
    {
        Local = 0,
        Remote = 1,
    }
    public class AssemblyScannerConfiguration
    {
        public AssemblyScannerConfiguration() { }
        public bool ScanAppDomainAssemblies { get; set; }
        public bool ScanAssembliesInNestedDirectories { get; set; }
        public bool ThrowExceptions { get; set; }
        public void ExcludeAssemblies(params string[] assemblies) { }
        public void ExcludeTypes(params System.Type[] types) { }
    }
    public class static AssemblyScannerConfigurationExtensions
    {
        public static NServiceBus.AssemblyScannerConfiguration AssemblyScanner(this NServiceBus.EndpointConfiguration configuration) { }
    }
    public class static AuditConfigReader
    {
        public static bool TryGetAuditMessageExpiration(this NServiceBus.Settings.ReadOnlySettings settings, out System.TimeSpan auditMessageExpiration) { }
        public static bool TryGetAuditQueueAddress(this NServiceBus.Settings.ReadOnlySettings settings, out string address) { }
    }
    public class static AutoSubscribeSettingsExtensions
    {
        public static NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings AutoSubscribe(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static BestPracticesOptionExtensions
    {
        public static void DoNotEnforceBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingReplyContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingSendContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.ISubscribeContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IOutgoingPublishContext context) { }
        public static void DoNotEnforceBestPractices(this NServiceBus.Pipeline.IUnsubscribeContext context) { }
        public static bool IgnoredBestPractices(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public class static ConfigurationTimeoutExtensions
    {
        public static void TimeToWaitBeforeTriggeringCriticalErrorOnTimeoutOutages(this NServiceBus.EndpointConfiguration config, System.TimeSpan timeToWait) { }
    }
    public class static ConfigureAudit
    {
        public static void AuditProcessedMessagesTo(this NServiceBus.EndpointConfiguration config, string auditQueue, System.Nullable<System.TimeSpan> timeToBeReceived = null) { }
    }
    public class static ConfigureCriticalErrorAction
    {
        public static void DefineCriticalErrorAction(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Func<NServiceBus.ICriticalErrorContext, System.Threading.Tasks.Task> onCriticalError) { }
    }
    public class static ConfigureError
    {
        public static void SendFailedMessagesTo(this NServiceBus.EndpointConfiguration config, string errorQueue) { }
    }
    public class static ConfigureFileShareDataBus
    {
        public static NServiceBus.DataBus.DataBusExtensions<NServiceBus.FileShareDataBus> BasePath(this NServiceBus.DataBus.DataBusExtensions<NServiceBus.FileShareDataBus> config, string basePath) { }
    }
    public class static ConfigureForwarding
    {
        public static void ForwardReceivedMessagesTo(this NServiceBus.EndpointConfiguration config, string address) { }
    }
    public class static ConfigureLicenseExtensions
    {
        public static void License(this NServiceBus.EndpointConfiguration config, string licenseText) { }
        public static void LicensePath(this NServiceBus.EndpointConfiguration config, string licenseFile) { }
    }
    public class static ConfigurePurging
    {
        public static void PurgeOnStartup(this NServiceBus.EndpointConfiguration config, bool value) { }
    }
    public class static ConfigureQueueCreation
    {
        public static bool CreateQueues(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static void DoNotCreateQueues(this NServiceBus.EndpointConfiguration config) { }
    }
    [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. Will be removed in version 8.0.0.", true)]
    public class static ConfigureRijndaelEncryptionService
    {
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. The member currently throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static void RegisterEncryptionService(this NServiceBus.EndpointConfiguration config, System.Func<NServiceBus.IEncryptionService> func) { }
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. The member currently throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config) { }
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. The member currently throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config, string encryptionKeyIdentifier, byte[] encryptionKey, System.Collections.Generic.IList<byte[]> decryptionKeys = null) { }
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. Use `NServiceBus.Encryption.MessageProperty.EncryptionConfigurationExtensions.EnableMessagePropertyEncryption` instead. The member currently throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static void RijndaelEncryptionService(this NServiceBus.EndpointConfiguration config, string encryptionKeyIdentifier, System.Collections.Generic.IDictionary<string, byte[]> keys, System.Collections.Generic.IList<byte[]> decryptionKeys = null) { }
    }
    public class static ConnectorContextExtensions
    {
        public static NServiceBus.Pipeline.IAuditContext CreateAuditContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IAuditContext> forkConnector, NServiceBus.Transport.OutgoingMessage message, string auditAddress, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IBatchDispatchContext CreateBatchDispatchContext(this NServiceBus.Pipeline.StageForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IBatchDispatchContext> stageForkConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IDispatchContext CreateDispatchContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IBatchDispatchContext, NServiceBus.Pipeline.IDispatchContext> stageConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IBatchDispatchContext sourceContext) { }
        public static NServiceBus.Pipeline.IDispatchContext CreateDispatchContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IRoutingContext, NServiceBus.Pipeline.IDispatchContext> stageConnector, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> transportOperations, NServiceBus.Pipeline.IRoutingContext sourceContext) { }
        public static NServiceBus.Pipeline.IForwardingContext CreateForwardingContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IForwardingContext> forwardingContext, NServiceBus.Transport.OutgoingMessage message, string forwardingAddress, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingLogicalMessageContext CreateIncomingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IIncomingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.LogicalMessage logicalMessage, NServiceBus.Pipeline.IIncomingPhysicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(this NServiceBus.Pipeline.StageForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext, NServiceBus.Pipeline.IBatchDispatchContext> stageForkConnector, NServiceBus.Transport.IncomingMessage incomingMessage, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IIncomingPhysicalMessageContext> stageConnector, NServiceBus.Transport.IncomingMessage incomingMessage, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IInvokeHandlerContext CreateInvokeHandlerContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IIncomingLogicalMessageContext, NServiceBus.Pipeline.IInvokeHandlerContext> stageConnector, NServiceBus.Pipeline.MessageHandler messageHandler, NServiceBus.Persistence.CompletableSynchronizedStorageSession storageSession, NServiceBus.Pipeline.IIncomingLogicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingPublishContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingPublishContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingReplyContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingReplyContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingSendContext, NServiceBus.Pipeline.IOutgoingLogicalMessageContext> stageConnector, NServiceBus.Pipeline.OutgoingLogicalMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingSendContext sourceContext) { }
        public static NServiceBus.Pipeline.IOutgoingPhysicalMessageContext CreateOutgoingPhysicalMessageContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingLogicalMessageContext, NServiceBus.Pipeline.IOutgoingPhysicalMessageContext> stageConnector, byte[] messageBody, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingLogicalMessageContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.ForkConnector<NServiceBus.Pipeline.ITransportReceiveContext, NServiceBus.Pipeline.IRoutingContext> forkConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, string localAddress, NServiceBus.Pipeline.ITransportReceiveContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IForwardingContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy, NServiceBus.Pipeline.IForwardingContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IAuditContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, NServiceBus.Routing.RoutingStrategy routingStrategy, NServiceBus.Pipeline.IAuditContext sourceContext) { }
        public static NServiceBus.Pipeline.IRoutingContext CreateRoutingContext(this NServiceBus.Pipeline.StageConnector<NServiceBus.Pipeline.IOutgoingPhysicalMessageContext, NServiceBus.Pipeline.IRoutingContext> stageConnector, NServiceBus.Transport.OutgoingMessage outgoingMessage, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> routingStrategies, NServiceBus.Pipeline.IOutgoingPhysicalMessageContext sourceContext) { }
    }
    public abstract class ContainSagaData : NServiceBus.IContainSagaData
    {
        protected ContainSagaData() { }
        public virtual System.Guid Id { get; set; }
        public virtual string OriginalMessageId { get; set; }
        public virtual string Originator { get; set; }
    }
    public class static ContentTypes
    {
        public const string Json = "application/json";
        public const string Xml = "text/xml";
    }
    public class Conventions
    {
        public Conventions() { }
        public void AddSystemMessagesConventions(System.Func<System.Type, bool> definesMessageType) { }
        public bool IsCommandType(System.Type t) { }
        public bool IsDataBusProperty(System.Reflection.PropertyInfo property) { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public bool IsEncryptedProperty(System.Reflection.PropertyInfo property) { }
        public bool IsEventType(System.Type t) { }
        public bool IsInSystemConventionList(System.Type t) { }
        public bool IsMessageType(System.Type t) { }
    }
    public class ConventionsBuilder : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public ConventionsBuilder(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.Conventions Conventions { get; }
        public NServiceBus.ConventionsBuilder DefiningCommandsAs(System.Func<System.Type, bool> definesCommandType) { }
        public NServiceBus.ConventionsBuilder DefiningDataBusPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesDataBusProperty) { }
        [System.ObsoleteAttribute(@"Message property encryption is released as a dedicated 'NServiceBus.Encryption.MessageProperty' package. This convention configuration does not work in combination with the NServiceBus.Encryption.MessageProperty package. The member currently throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public NServiceBus.ConventionsBuilder DefiningEncryptedPropertiesAs(System.Func<System.Reflection.PropertyInfo, bool> definesEncryptedProperty) { }
        public NServiceBus.ConventionsBuilder DefiningEventsAs(System.Func<System.Type, bool> definesEventType) { }
        public NServiceBus.ConventionsBuilder DefiningMessagesAs(System.Func<System.Type, bool> definesMessageType) { }
    }
    public class ConversationId
    {
        public static NServiceBus.ConversationId Default { get; }
        public static NServiceBus.ConversationId Custom(string customValue) { }
    }
    public class ConversationIdStrategyContext
    {
        public ConversationIdStrategyContext(NServiceBus.Pipeline.OutgoingLogicalMessage message, System.Collections.Generic.IReadOnlyDictionary<string, string> headers) { }
        public System.Collections.Generic.IReadOnlyDictionary<string, string> Headers { get; }
        public NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    [System.ObsoleteAttribute("Setting a custom correlation ID is no longer supported. Will be removed in versio" +
        "n 8.0.0.", true)]
    public class static CorrelationContextExtensions
    {
        [System.ObsoleteAttribute("Using custom correlation IDs is no longer supported. The member currently throws " +
            "a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static string GetCorrelationId(this NServiceBus.SendOptions options) { }
        [System.ObsoleteAttribute("Using custom correlation IDs is no longer supported. The member currently throws " +
            "a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static string GetCorrelationId(this NServiceBus.ReplyOptions options) { }
        [System.ObsoleteAttribute("Setting a custom correlation ID is no longer supported. The member currently thro" +
            "ws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static void SetCorrelationId(this NServiceBus.SendOptions options, string correlationId) { }
        [System.ObsoleteAttribute("Setting a custom correlation ID is no longer supported. The member currently thro" +
            "ws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static void SetCorrelationId(this NServiceBus.ReplyOptions options, string correlationId) { }
    }
    public class CriticalError
    {
        public CriticalError(System.Func<NServiceBus.ICriticalErrorContext, System.Threading.Tasks.Task> onCriticalErrorAction) { }
        public virtual void Raise(string errorMessage, System.Exception exception) { }
    }
    public class CriticalErrorContext : NServiceBus.ICriticalErrorContext
    {
        public CriticalErrorContext(System.Func<System.Threading.Tasks.Task> stop, string error, System.Exception exception) { }
        public string Error { get; }
        public System.Exception Exception { get; }
        public System.Func<System.Threading.Tasks.Task> Stop { get; }
    }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be removed in version 8.0.0.", true)]
    public class static CriticalTimeMonitoringConfig
    {
        [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
            "s.PerformanceCounters. The member currently throws a NotImplementedException. Wi" +
            "ll be removed in version 8.0.0.", true)]
        public static void EnableCriticalTimePerformanceCounter(this NServiceBus.EndpointConfiguration config) { }
    }
    public class DataBusProperty<T> : NServiceBus.IDataBusProperty, System.Runtime.Serialization.ISerializable
        where T :  class
    {
        public DataBusProperty() { }
        public DataBusProperty(T value) { }
        protected DataBusProperty(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public bool HasValue { get; set; }
        public string Key { get; set; }
        public T Value { get; }
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public object GetValue() { }
        public void SetValue(object valueToSet) { }
    }
    public class static DateTimeExtensions
    {
        public static System.DateTime ToUtcDateTime(string wireFormattedString) { }
        public static string ToWireFormattedString(System.DateTime dateTime) { }
    }
    public class static DefaultRecoverabilityPolicy
    {
        public static NServiceBus.RecoverabilityAction Invoke(NServiceBus.RecoverabilityConfig config, NServiceBus.Transport.ErrorContext errorContext) { }
    }
    public class DelayedConfig
    {
        public DelayedConfig(int maxNumberOfRetries, System.TimeSpan timeIncrease) { }
        public int MaxNumberOfRetries { get; }
        public System.TimeSpan TimeIncrease { get; }
    }
    public class static DelayedDeliveryOptionExtensions
    {
        public static void DelayDeliveryWith(this NServiceBus.SendOptions options, System.TimeSpan delay) { }
        public static void DoNotDeliverBefore(this NServiceBus.SendOptions options, System.DateTimeOffset at) { }
        public static System.Nullable<System.DateTimeOffset> GetDeliveryDate(this NServiceBus.SendOptions options) { }
        public static System.Nullable<System.TimeSpan> GetDeliveryDelay(this NServiceBus.SendOptions options) { }
    }
    public class DelayedRetriesSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public NServiceBus.DelayedRetriesSettings NumberOfRetries(int numberOfRetries) { }
        public NServiceBus.DelayedRetriesSettings TimeIncrease(System.TimeSpan timeIncrease) { }
    }
    public sealed class DelayedRetry : NServiceBus.RecoverabilityAction
    {
        public System.TimeSpan Delay { get; }
    }
    public enum DependencyLifecycle
    {
        SingleInstance = 0,
        InstancePerUnitOfWork = 1,
        InstancePerCall = 2,
    }
    public class static DiagnosticSettingsExtensions
    {
        public static void AddStartupDiagnosticsSection(this NServiceBus.Settings.ReadOnlySettings settings, string sectionName, object section) { }
        public static void CustomDiagnosticsWriter(this NServiceBus.EndpointConfiguration config, System.Func<string, System.Threading.Tasks.Task> customDiagnosticsWriter) { }
        public static void SetDiagnosticsPath(this NServiceBus.EndpointConfiguration config, string path) { }
    }
    public sealed class Discard : NServiceBus.RecoverabilityAction
    {
        public string Reason { get; }
    }
    public class DistributionPolicy : NServiceBus.IDistributionPolicy
    {
        public DistributionPolicy() { }
        public void SetDistributionStrategy(NServiceBus.Routing.DistributionStrategy distributionStrategy) { }
    }
    public enum DistributionStrategyScope
    {
        Send = 0,
        Publish = 1,
    }
    public class static DurableMessagesConfig
    {
        public static void DisableDurableMessages(this NServiceBus.EndpointConfiguration config) { }
        public static bool DurableMessagesEnabled(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static void EnableDurableMessages(this NServiceBus.EndpointConfiguration config) { }
    }
    public class static DurableMessagesConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningExpressMessagesAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, bool> definesExpressMessageType) { }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be removed in version 8.0.0.", true)]
    public class EncryptedValue
    {
        public EncryptedValue() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public string Base64Iv { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public string EncryptedBase64Value { get; set; }
    }
    public class static Endpoint
    {
        public static System.Threading.Tasks.Task<NServiceBus.IStartableEndpoint> Create(NServiceBus.EndpointConfiguration configuration) { }
        public static System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start(NServiceBus.EndpointConfiguration configuration) { }
    }
    public class EndpointConfiguration : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public EndpointConfiguration(string endpointName) { }
        public NServiceBus.Notifications Notifications { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        public NServiceBus.ConventionsBuilder Conventions() { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public void CustomConfigurationSource(NServiceBus.Config.ConfigurationSource.IConfigurationSource configurationSource) { }
        [System.ObsoleteAttribute("Use the AssemblyScanner configuration API. Use `AssemblyScannerConfigurationExten" +
            "sions.AssemblyScanner` instead. The member currently throws a NotImplementedExce" +
            "ption. Will be removed in version 8.0.0.", true)]
        public void ExcludeAssemblies(params string[] assemblies) { }
        [System.ObsoleteAttribute("Use the AssemblyScanner configuration API. Use `AssemblyScannerConfigurationExten" +
            "sions.AssemblyScanner` instead. The member currently throws a NotImplementedExce" +
            "ption. Will be removed in version 8.0.0.", true)]
        public void ExcludeTypes(params System.Type[] types) { }
        public void RegisterComponents(System.Action<NServiceBus.ObjectBuilder.IConfigureComponents> registration) { }
        [System.ObsoleteAttribute("Use the AssemblyScanner configuration API. Use `AssemblyScannerConfigurationExten" +
            "sions.AssemblyScanner` instead. The member currently throws a NotImplementedExce" +
            "ption. Will be removed in version 8.0.0.", true)]
        public void ScanAssembliesInNestedDirectories() { }
        public void SendOnly() { }
        public void UseContainer<T>(System.Action<NServiceBus.Container.ContainerCustomizations> customizations = null)
            where T : NServiceBus.Container.ContainerDefinition, new () { }
        public void UseContainer(System.Type definitionType) { }
        public void UseContainer(NServiceBus.ObjectBuilder.Common.IContainer builder) { }
    }
    public class static EndpointConfigurationExtensions
    {
        public static void DisableFeature<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void DisableFeature(this NServiceBus.EndpointConfiguration config, System.Type featureType) { }
        public static void EnableFeature<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Features.Feature { }
        public static void EnableFeature(this NServiceBus.EndpointConfiguration config, System.Type featureType) { }
    }
    public class static EndpointWithExternallyManagedContainer
    {
        public static NServiceBus.IStartableEndpointWithExternallyManagedContainer Create(NServiceBus.EndpointConfiguration configuration, NServiceBus.ObjectBuilder.IConfigureComponents configureComponents) { }
    }
    public class static ErrorQueueSettings
    {
        public const string SettingsKey = "errorQueue";
        public static string ErrorQueueAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static bool TryGetExplicitlyConfiguredErrorQueueAddress(this NServiceBus.Settings.ReadOnlySettings settings, out string errorQueue) { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class ExpressAttribute : System.Attribute
    {
        public ExpressAttribute() { }
    }
    public class FailedConfig
    {
        [System.ObsoleteAttribute("Use `FailedConfig(string errorQueue, HashSet<Type> unrecoverableExceptionTypes)` " +
            "instead. The member currently throws a NotImplementedException. Will be removed " +
            "in version 8.0.0.", true)]
        public FailedConfig(string errorQueue) { }
        public FailedConfig(string errorQueue, System.Collections.Generic.HashSet<System.Type> unrecoverableExceptionTypes) { }
        public string ErrorQueue { get; }
        public System.Collections.Generic.HashSet<System.Type> UnrecoverableExceptionTypes { get; }
    }
    public class FileShareDataBus : NServiceBus.DataBus.DataBusDefinition
    {
        public FileShareDataBus() { }
        protected override System.Type ProvidedByFeature() { }
    }
    public class static HeaderOptionExtensions
    {
        public static System.Collections.Generic.IReadOnlyDictionary<string, string> GetHeaders(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void SetHeader(this NServiceBus.Extensibility.ExtendableOptions options, string key, string value) { }
    }
    public class static Headers
    {
        public const string ContentType = "NServiceBus.ContentType";
        public const string ControlMessageHeader = "NServiceBus.ControlMessage";
        public const string ConversationId = "NServiceBus.ConversationId";
        public const string CorrelationId = "NServiceBus.CorrelationId";
        public const string DelayedRetries = "NServiceBus.Retries";
        public const string DelayedRetriesTimestamp = "NServiceBus.Retries.Timestamp";
        public const string DestinationSites = "NServiceBus.DestinationSites";
        public const string EnclosedMessageTypes = "NServiceBus.EnclosedMessageTypes";
        public const string HasLicenseExpired = "$.diagnostics.license.expired";
        [System.ObsoleteAttribute("Not intended for public usage. Will be treated as an error from version 8.0.0. Wi" +
            "ll be removed in version 9.0.0.", false)]
        public const string HeaderName = "Header";
        public const string HostDisplayName = "$.diagnostics.hostdisplayname";
        public const string HostId = "$.diagnostics.hostid";
        public const string HttpFrom = "NServiceBus.From";
        public const string HttpTo = "NServiceBus.To";
        public const string ImmediateRetries = "NServiceBus.FLRetries";
        public const string IsDeferredMessage = "NServiceBus.IsDeferredMessage";
        public const string IsSagaTimeoutMessage = "NServiceBus.IsSagaTimeoutMessage";
        public const string MessageId = "NServiceBus.MessageId";
        public const string MessageIntent = "NServiceBus.MessageIntent";
        public const string NServiceBusVersion = "NServiceBus.Version";
        public const string NonDurableMessage = "NServiceBus.NonDurableMessage";
        public const string OriginatingAddress = "NServiceBus.OriginatingAddress";
        public const string OriginatingEndpoint = "NServiceBus.OriginatingEndpoint";
        public const string OriginatingHostId = "$.diagnostics.originating.hostid";
        public const string OriginatingMachine = "NServiceBus.OriginatingMachine";
        public const string OriginatingSagaId = "NServiceBus.OriginatingSagaId";
        public const string OriginatingSagaType = "NServiceBus.OriginatingSagaType";
        public const string OriginatingSite = "NServiceBus.OriginatingSite";
        public const string ProcessingEnded = "NServiceBus.ProcessingEnded";
        public const string ProcessingEndpoint = "NServiceBus.ProcessingEndpoint";
        public const string ProcessingMachine = "NServiceBus.ProcessingMachine";
        public const string ProcessingStarted = "NServiceBus.ProcessingStarted";
        public const string RelatedTo = "NServiceBus.RelatedTo";
        public const string ReplyToAddress = "NServiceBus.ReplyToAddress";
        public const string ReturnMessageErrorCodeHeader = "NServiceBus.ReturnMessage.ErrorCode";
        public const string RouteTo = "NServiceBus.Header.RouteTo";
        public const string SagaId = "NServiceBus.SagaId";
        public const string SagaType = "NServiceBus.SagaType";
        public const string SubscriberEndpoint = "NServiceBus.SubscriberEndpoint";
        public const string SubscriberTransportAddress = "NServiceBus.SubscriberAddress";
        public const string SubscriptionMessageType = "SubscriptionMessageType";
        public const string TimeSent = "NServiceBus.TimeSent";
        public const string TimeToBeReceived = "NServiceBus.TimeToBeReceived";
    }
    public class static HostInfoConfigurationExtensions
    {
        public static NServiceBus.HostInfoSettings UniquelyIdentifyRunningInstance(this NServiceBus.EndpointConfiguration config) { }
    }
    public class HostInfoSettings
    {
        public NServiceBus.HostInfoSettings UsingCustomDisplayName(string displayName) { }
        public NServiceBus.HostInfoSettings UsingCustomIdentifier(System.Guid id) { }
        public NServiceBus.HostInfoSettings UsingInstalledFilePath() { }
        public NServiceBus.HostInfoSettings UsingNames(string instanceName, string hostName) { }
    }
    public interface IAmStartedByMessages<T> : NServiceBus.IHandleMessages<T> { }
    public interface ICommand : NServiceBus.IMessage { }
    public interface IConfigureHowToFindSagaWithMessage
    {
        void ConfigureMapping<TSagaEntity, TMessage>(System.Linq.Expressions.Expression<System.Func<TSagaEntity, object>> sagaEntityProperty, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty)
            where TSagaEntity : NServiceBus.IContainSagaData
        ;
    }
    public interface IContainSagaData
    {
        System.Guid Id { get; set; }
        string OriginalMessageId { get; set; }
        string Originator { get; set; }
    }
    public interface ICriticalErrorContext
    {
        string Error { get; }
        System.Exception Exception { get; }
        System.Func<System.Threading.Tasks.Task> Stop { get; }
    }
    public interface IDataBusProperty
    {
        bool HasValue { get; set; }
        string Key { get; set; }
        object GetValue();
        void SetValue(object value);
    }
    public interface IDistributionPolicy
    {
        NServiceBus.Routing.DistributionStrategy GetDistributionStrategy(string endpointName, NServiceBus.DistributionStrategyScope scope);
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be removed in version 8.0.0.", true)]
    public interface IEncryptionService
    {
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be removed in version 8.0.0.", true)]
        string Decrypt(NServiceBus.EncryptedValue encryptedValue, NServiceBus.Pipeline.IIncomingLogicalMessageContext context);
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. Will be removed in version 8.0.0.", true)]
        NServiceBus.EncryptedValue Encrypt(string value, NServiceBus.Pipeline.IOutgoingLogicalMessageContext context);
    }
    public interface IEndpointInstance : NServiceBus.IMessageSession
    {
        System.Threading.Tasks.Task Stop();
    }
    public interface IEvent : NServiceBus.IMessage { }
    public interface IHandleMessages<T>
    {
        System.Threading.Tasks.Task Handle(T message, NServiceBus.IMessageHandlerContext context);
    }
    public interface IHandleTimeouts<T>
    {
        System.Threading.Tasks.Task Timeout(T state, NServiceBus.IMessageHandlerContext context);
    }
    public interface IMessage { }
    public interface IMessageCreator
    {
        T CreateInstance<T>();
        T CreateInstance<T>(System.Action<T> action);
        object CreateInstance(System.Type messageType);
    }
    public interface IMessageHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext
    {
        NServiceBus.Persistence.SynchronizedStorageSession SynchronizedStorageSession { get; }
        void DoNotContinueDispatchingCurrentMessageToHandlers();
        [System.ObsoleteAttribute("HandleCurrentMessageLater has been deprecated. Will be removed in version 8.0.0.", true)]
        System.Threading.Tasks.Task HandleCurrentMessageLater();
    }
    public interface IMessageProcessingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext
    {
        System.Collections.Generic.IReadOnlyDictionary<string, string> MessageHeaders { get; }
        string MessageId { get; }
        string ReplyToAddress { get; }
        System.Threading.Tasks.Task ForwardCurrentMessageTo(string destination);
        System.Threading.Tasks.Task Reply(object message, NServiceBus.ReplyOptions options);
        System.Threading.Tasks.Task Reply<T>(System.Action<T> messageConstructor, NServiceBus.ReplyOptions options);
    }
    public class static IMessageProcessingContextExtensions
    {
        public static System.Threading.Tasks.Task Reply(this NServiceBus.IMessageProcessingContext context, object message) { }
        public static System.Threading.Tasks.Task Reply<T>(this NServiceBus.IMessageProcessingContext context, System.Action<T> messageConstructor) { }
    }
    public interface IMessageSession
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.SubscribeOptions options);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.UnsubscribeOptions options);
    }
    public class static IMessageSessionExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IMessageSession session) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IMessageSession session, string destination, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IMessageSession session, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IMessageSession session, object message) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IMessageSession session, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Subscribe(this NServiceBus.IMessageSession session, System.Type messageType) { }
        public static System.Threading.Tasks.Task Subscribe<T>(this NServiceBus.IMessageSession session) { }
        public static System.Threading.Tasks.Task Unsubscribe(this NServiceBus.IMessageSession session, System.Type messageType) { }
        public static System.Threading.Tasks.Task Unsubscribe<T>(this NServiceBus.IMessageSession session) { }
    }
    public interface INeedInitialization
    {
        void Customize(NServiceBus.EndpointConfiguration configuration);
    }
    public interface IPipelineContext : NServiceBus.Extensibility.IExtendable
    {
        System.Threading.Tasks.Task Publish(object message, NServiceBus.PublishOptions options);
        System.Threading.Tasks.Task Publish<T>(System.Action<T> messageConstructor, NServiceBus.PublishOptions publishOptions);
        System.Threading.Tasks.Task Send(object message, NServiceBus.SendOptions options);
        System.Threading.Tasks.Task Send<T>(System.Action<T> messageConstructor, NServiceBus.SendOptions options);
    }
    public class static IPipelineContextExtensions
    {
        public static System.Threading.Tasks.Task Publish(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IPipelineContext context) { }
        public static System.Threading.Tasks.Task Publish<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task Send(this NServiceBus.IPipelineContext context, string destination, object message) { }
        public static System.Threading.Tasks.Task Send<T>(this NServiceBus.IPipelineContext context, string destination, System.Action<T> messageConstructor) { }
        public static System.Threading.Tasks.Task SendLocal(this NServiceBus.IPipelineContext context, object message) { }
        public static System.Threading.Tasks.Task SendLocal<T>(this NServiceBus.IPipelineContext context, System.Action<T> messageConstructor) { }
    }
    public interface IStartableEndpoint
    {
        System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start();
    }
    public interface IStartableEndpointWithExternallyManagedContainer
    {
        System.Lazy<NServiceBus.IMessageSession> MessageSession { get; }
        System.Threading.Tasks.Task<NServiceBus.IEndpointInstance> Start(NServiceBus.ObjectBuilder.IBuilder builder);
    }
    public interface IWantToRunBeforeConfigurationIsFinalized
    {
        void Run(NServiceBus.Settings.SettingsHolder settings);
    }
    public class ImmediateConfig
    {
        public ImmediateConfig(int maxNumberOfRetries) { }
        public int MaxNumberOfRetries { get; }
    }
    public class static ImmediateDispatchOptionExtensions
    {
        public static void RequireImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static bool RequiredImmediateDispatch(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public class ImmediateRetriesSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public void NumberOfRetries(int numberOfRetries) { }
    }
    public sealed class ImmediateRetry : NServiceBus.RecoverabilityAction { }
    public class static InMemoryGatewayPersistenceConfigurationExtensions
    {
        public static void GatewayDeduplicationCacheSize(this NServiceBus.PersistenceExtensions<NServiceBus.InMemoryPersistence> persistenceExtensions, int maxSize) { }
    }
    public class InMemoryPersistence : NServiceBus.Persistence.PersistenceDefinition { }
    public class static InstallConfigExtensions
    {
        [System.ObsoleteAttribute("Installers are now always disabled by default. The member currently throws a NotI" +
            "mplementedException. Will be removed in version 8.0.0.", true)]
        public static void DisableInstallers(this NServiceBus.EndpointConfiguration config) { }
        public static void EnableInstallers(this NServiceBus.EndpointConfiguration config, string username = null) { }
    }
    [System.ObsoleteAttribute("Json serialization is available as a dedicated \'NServiceBus.Newtonsoft.Json\' pack" +
        "age. Use `NServiceBus.NewtonsoftSerializer` instead. Will be removed in version " +
        "8.0.0.", true)]
    public class JsonSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public JsonSerializer() { }
        public override System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    [System.ObsoleteAttribute("Json serialization is available as a dedicated \'NServiceBus.Newtonsoft.Json\' pack" +
        "age. Use `NServiceBus.NewtonsoftSerializer` instead. Will be removed in version " +
        "8.0.0.", true)]
    public class static JsonSerializerConfigurationExtensions
    {
        [System.ObsoleteAttribute("Json serialization is available as a dedicated \'NServiceBus.Newtonsoft.Json\' pack" +
            "age. Use `NServiceBus.NewtonsoftSerializer` instead. The member currently throws" +
            " a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static void Encoding(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.JsonSerializer> config, System.Text.Encoding encoding) { }
    }
    public class LearningPersistence : NServiceBus.Persistence.PersistenceDefinition { }
    public class static LearningSagaPersisterConfigurationExtensions
    {
        public static void SagaStorageDirectory(this NServiceBus.PersistenceExtensions<NServiceBus.LearningPersistence> persistenceExtensions, string path) { }
    }
    public class LearningTransport : NServiceBus.Transport.TransportDefinition
    {
        public LearningTransport() { }
        public override string ExampleConnectionStringForErrorMessage { get; }
        public override bool RequiresConnectionString { get; }
        public override NServiceBus.Transport.TransportInfrastructure Initialize(NServiceBus.Settings.SettingsHolder settings, string connectionString) { }
    }
    public class static LearningTransportConfigurationExtensions
    {
        public static void NoPayloadSizeRestriction(this NServiceBus.TransportExtensions<NServiceBus.LearningTransport> transportExtensions) { }
        public static void StorageDirectory(this NServiceBus.TransportExtensions<NServiceBus.LearningTransport> transportExtensions, string path) { }
    }
    public class static LoadMessageHandlersExtensions
    {
        public static void ExecuteTheseHandlersFirst(this NServiceBus.EndpointConfiguration config, System.Collections.Generic.IEnumerable<System.Type> handlerTypes) { }
        public static void ExecuteTheseHandlersFirst(this NServiceBus.EndpointConfiguration config, params System.Type[] handlerTypes) { }
    }
    public struct LogicalAddress
    {
        public NServiceBus.Routing.EndpointInstance EndpointInstance { get; }
        public string Qualifier { get; }
        public NServiceBus.LogicalAddress CreateIndividualizedAddress(string discriminator) { }
        public static NServiceBus.LogicalAddress CreateLocalAddress(string queueName, System.Collections.Generic.IReadOnlyDictionary<string, string> properties) { }
        public NServiceBus.LogicalAddress CreateQualifiedAddress(string qualifier) { }
        public static NServiceBus.LogicalAddress CreateRemoteAddress(NServiceBus.Routing.EndpointInstance endpointInstance) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
        public static bool ==(NServiceBus.LogicalAddress left, NServiceBus.LogicalAddress right) { }
        public static bool !=(NServiceBus.LogicalAddress left, NServiceBus.LogicalAddress right) { }
    }
    public class static MessageCausationConfigurationExtensions
    {
        public static void CustomConversationIdStrategy(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Func<NServiceBus.ConversationIdStrategyContext, NServiceBus.ConversationId> customStrategy) { }
    }
    public class MessageDeserializationException : System.Runtime.Serialization.SerializationException
    {
        public MessageDeserializationException(string message) { }
        public MessageDeserializationException(string messageId, System.Exception innerException) { }
        protected MessageDeserializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
    public class static MessageDrivenSubscriptionsConfigExtensions
    {
        public static void DisablePublishing<T>(this NServiceBus.TransportExtensions<T> transportExtensions)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Type eventType, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Reflection.Assembly assembly, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void RegisterPublisher<T>(this NServiceBus.RoutingSettings<T> routingSettings, System.Reflection.Assembly assembly, string @namespace, string publisherEndpoint)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
        public static void SubscriptionAuthorizer<T>(this NServiceBus.TransportExtensions<T> transportExtensions, System.Func<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, bool> authorizer)
            where T : NServiceBus.Transport.TransportDefinition, NServiceBus.Routing.IMessageDrivenSubscriptionTransport { }
    }
    public class static MessageIdExtensions
    {
        public static string GetMessageId(this NServiceBus.Extensibility.ExtendableOptions options) { }
        public static void SetMessageId(this NServiceBus.Extensibility.ExtendableOptions options, string messageId) { }
    }
    public enum MessageIntentEnum
    {
        Send = 1,
        Publish = 2,
        Subscribe = 3,
        Unsubscribe = 4,
        Reply = 5,
    }
    public class static MessageProcessingOptimizationExtensions
    {
        public static void LimitMessageProcessingConcurrencyTo(this NServiceBus.EndpointConfiguration config, int maxConcurrency) { }
    }
    public sealed class MoveToError : NServiceBus.RecoverabilityAction
    {
        public string ErrorQueue { get; }
    }
    public class NonDurableDelivery : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public NonDurableDelivery() { }
    }
    public class Notifications
    {
        public Notifications() { }
        public NServiceBus.Faults.ErrorsNotifications Errors { get; }
    }
    public class static OutboxConfigExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings EnableOutbox(this NServiceBus.EndpointConfiguration config) { }
    }
    public class PendingTransportOperations
    {
        public PendingTransportOperations() { }
        public bool HasOperations { get; }
        public NServiceBus.Transport.TransportOperation[] Operations { get; }
        public void Add(NServiceBus.Transport.TransportOperation transportOperation) { }
        public void AddRange(NServiceBus.Transport.TransportOperation[] transportOperations) { }
    }
    public class static PersistenceConfig
    {
        public static NServiceBus.PersistenceExtensions<T> UsePersistence<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition { }
        public static NServiceBus.PersistenceExtensions<T, S> UsePersistence<T, S>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Persistence.PersistenceDefinition
            where S : NServiceBus.StorageType { }
        public static NServiceBus.PersistenceExtensions UsePersistence(this NServiceBus.EndpointConfiguration config, System.Type definitionType) { }
    }
    public class PersistenceExtensions : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public PersistenceExtensions(System.Type definitionType, NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
    }
    public class PersistenceExtensions<T> : NServiceBus.PersistenceExtensions
        where T : NServiceBus.Persistence.PersistenceDefinition
    {
        public PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        protected PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings, System.Type storageType) { }
    }
    public class PersistenceExtensions<T, S> : NServiceBus.PersistenceExtensions<T>
        where T : NServiceBus.Persistence.PersistenceDefinition
        where S : NServiceBus.StorageType
    {
        public PersistenceExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class PublishOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public PublishOptions() { }
    }
    public class ReceivePipelineCompleted
    {
        public ReceivePipelineCompleted(NServiceBus.Transport.IncomingMessage processedMessage, System.DateTime startedAt, System.DateTime completedAt) { }
        public System.DateTime CompletedAt { get; }
        public NServiceBus.Transport.IncomingMessage ProcessedMessage { get; }
        public System.DateTime StartedAt { get; }
    }
    public class static ReceivePipelineConfigExtensions
    {
        public static void OnReceivePipelineCompleted(this NServiceBus.Pipeline.PipelineSettings pipelineSettings, System.Func<NServiceBus.ReceivePipelineCompleted, System.Threading.Tasks.Task> subscription) { }
    }
    public class static ReceiveSettingsExtensions
    {
        public static void MakeInstanceUniquelyAddressable(this NServiceBus.EndpointConfiguration config, string discriminator) { }
        public static void OverrideLocalAddress(this NServiceBus.EndpointConfiguration config, string baseInputQueueName) { }
    }
    public abstract class RecoverabilityAction
    {
        protected RecoverabilityAction() { }
        public static NServiceBus.DelayedRetry DelayedRetry(System.TimeSpan timeSpan) { }
        public static NServiceBus.Discard Discard(string reason) { }
        public static NServiceBus.ImmediateRetry ImmediateRetry() { }
        public static NServiceBus.MoveToError MoveToError(string errorQueue) { }
    }
    public class RecoverabilityConfig
    {
        public RecoverabilityConfig(NServiceBus.ImmediateConfig immediateConfig, NServiceBus.DelayedConfig delayedConfig, NServiceBus.FailedConfig failedConfig) { }
        public NServiceBus.DelayedConfig Delayed { get; }
        public NServiceBus.FailedConfig Failed { get; }
        public NServiceBus.ImmediateConfig Immediate { get; }
    }
    public class static RecoverabilityEndpointConfigurationExtensions
    {
        public static NServiceBus.RecoverabilitySettings Recoverability(this NServiceBus.EndpointConfiguration configuration) { }
    }
    public class RecoverabilitySettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public NServiceBus.RecoverabilitySettings AddUnrecoverableException<T>()
            where T : System.Exception { }
        public NServiceBus.RecoverabilitySettings AddUnrecoverableException(System.Type exceptionType) { }
        public NServiceBus.RecoverabilitySettings CustomPolicy(System.Func<NServiceBus.RecoverabilityConfig, NServiceBus.Transport.ErrorContext, NServiceBus.RecoverabilityAction> custom) { }
        public NServiceBus.RecoverabilitySettings Delayed(System.Action<NServiceBus.DelayedRetriesSettings> customizations) { }
        [System.ObsoleteAttribute("The legacy retries satellite was needed to migrate from V5 to V6, so it has been " +
            "removed. The member currently throws a NotImplementedException. Will be removed " +
            "in version 8.0.0.", true)]
        public NServiceBus.RecoverabilitySettings DisableLegacyRetriesSatellite() { }
        public NServiceBus.RecoverabilitySettings Failed(System.Action<NServiceBus.RetryFailedSettings> customizations) { }
        public NServiceBus.RecoverabilitySettings Immediate(System.Action<NServiceBus.ImmediateRetriesSettings> customizations) { }
    }
    public class static RecoverabilitySettingsExtensions
    {
        public static void AddUnrecoverableException(this NServiceBus.Settings.SettingsHolder settings, System.Type exceptionType) { }
    }
    public class ReplyOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public ReplyOptions() { }
    }
    public class RetryFailedSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public NServiceBus.RetryFailedSettings HeaderCustomization(System.Action<System.Collections.Generic.Dictionary<string, string>> customization) { }
    }
    public class static RoutingFeatureSettingsExtensions
    {
        public static void OverridePublicReturnAddress(this NServiceBus.EndpointConfiguration configuration, string address) { }
    }
    public class static RoutingOptionExtensions
    {
        public static string GetDestination(this NServiceBus.ReplyOptions options) { }
        public static string GetDestination(this NServiceBus.SendOptions options) { }
        public static string GetReplyToRoute(this NServiceBus.ReplyOptions options) { }
        public static string GetReplyToRoute(this NServiceBus.SendOptions options) { }
        public static string GetRouteToSpecificInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToAnyInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToAnyInstance(this NServiceBus.ReplyOptions options) { }
        public static bool IsRoutingReplyToThisInstance(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingReplyToThisInstance(this NServiceBus.ReplyOptions options) { }
        public static bool IsRoutingToThisEndpoint(this NServiceBus.SendOptions options) { }
        public static bool IsRoutingToThisInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyTo(this NServiceBus.ReplyOptions options, string address) { }
        public static void RouteReplyTo(this NServiceBus.SendOptions options, string address) { }
        public static void RouteReplyToAnyInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyToAnyInstance(this NServiceBus.ReplyOptions options) { }
        public static void RouteReplyToThisInstance(this NServiceBus.SendOptions options) { }
        public static void RouteReplyToThisInstance(this NServiceBus.ReplyOptions options) { }
        public static void RouteToSpecificInstance(this NServiceBus.SendOptions options, string instanceId) { }
        public static void RouteToThisEndpoint(this NServiceBus.SendOptions options) { }
        public static void RouteToThisInstance(this NServiceBus.SendOptions options) { }
        public static void SetDestination(this NServiceBus.SendOptions options, string destination) { }
        public static void SetDestination(this NServiceBus.ReplyOptions options, string destination) { }
    }
    public class RoutingSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public RoutingSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public void DoNotEnforceBestPractices() { }
        public void RouteToEndpoint(System.Type messageType, string destination) { }
        public void RouteToEndpoint(System.Reflection.Assembly assembly, string destination) { }
        public void RouteToEndpoint(System.Reflection.Assembly assembly, string @namespace, string destination) { }
    }
    public class static RoutingSettingsExtensions
    {
        public static NServiceBus.RoutingSettings Routing(this NServiceBus.TransportExtensions config) { }
        public static NServiceBus.RoutingSettings<T> Routing<T>(this NServiceBus.TransportExtensions<T> config)
            where T : NServiceBus.Transport.TransportDefinition { }
    }
    public class RoutingSettings<T> : NServiceBus.RoutingSettings
        where T : NServiceBus.Transport.TransportDefinition
    {
        public RoutingSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be removed in version 8.0.0.", true)]
    public class static SLAMonitoringConfig
    {
        [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
            "s.PerformanceCounters. The member currently throws a NotImplementedException. Wi" +
            "ll be removed in version 8.0.0.", true)]
        public static void EnableSLAPerformanceCounter(this NServiceBus.EndpointConfiguration config, System.TimeSpan sla) { }
        [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
            "s.PerformanceCounters. The member currently throws a NotImplementedException. Wi" +
            "ll be removed in version 8.0.0.", true)]
        public static void EnableSLAPerformanceCounter(this NServiceBus.EndpointConfiguration config) { }
    }
    public abstract class Saga
    {
        protected Saga() { }
        public bool Completed { get; }
        public NServiceBus.IContainSagaData Entity { get; set; }
        protected abstract void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
        protected void MarkAsComplete() { }
        protected System.Threading.Tasks.Task ReplyToOriginator(NServiceBus.IMessageHandlerContext context, object message) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTime at)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.DateTime at, TTimeoutMessageType timeoutMessage) { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within)
            where TTimeoutMessageType : new() { }
        protected System.Threading.Tasks.Task RequestTimeout<TTimeoutMessageType>(NServiceBus.IMessageHandlerContext context, System.TimeSpan within, TTimeoutMessageType timeoutMessage) { }
    }
    public class SagaPropertyMapper<TSagaData>
        where TSagaData :  class, NServiceBus.IContainSagaData
    {
        public NServiceBus.ToSagaExpression<TSagaData, TMessage> ConfigureMapping<TMessage>(System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
    }
    public abstract class Saga<TSagaData> : NServiceBus.Saga
        where TSagaData :  class, NServiceBus.IContainSagaData, new ()
    {
        protected Saga() { }
        public TSagaData Data { get; set; }
        protected override void ConfigureHowToFindSaga(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration) { }
        protected abstract void ConfigureHowToFindSaga(NServiceBus.SagaPropertyMapper<TSagaData> mapper);
    }
    public class static ScheduleExtensions
    {
        public static System.Threading.Tasks.Task ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, System.Func<NServiceBus.IPipelineContext, System.Threading.Tasks.Task> task) { }
        public static System.Threading.Tasks.Task ScheduleEvery(this NServiceBus.IMessageSession session, System.TimeSpan timeSpan, string name, System.Func<NServiceBus.IPipelineContext, System.Threading.Tasks.Task> task) { }
    }
    public class ScheduledTask : NServiceBus.IMessage
    {
        public ScheduledTask() { }
        public System.TimeSpan Every { get; set; }
        public string Name { get; set; }
        public System.Guid TaskId { get; set; }
    }
    public class SendOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SendOptions() { }
    }
    public class static SerializationConfigExtensions
    {
        public static NServiceBus.Serialization.SerializationExtensions<T> AddDeserializer<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtensions<T> AddDeserializer<T>(this NServiceBus.EndpointConfiguration config, T serializationDefinition)
            where T : NServiceBus.Serialization.SerializationDefinition { }
        public static NServiceBus.Serialization.SerializationExtensions<T> UseSerialization<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.Serialization.SerializationDefinition, new () { }
        public static NServiceBus.Serialization.SerializationExtensions<T> UseSerialization<T>(this NServiceBus.EndpointConfiguration config, T serializationDefinition)
            where T : NServiceBus.Serialization.SerializationDefinition { }
    }
    public class static SerializationContextExtensions
    {
        public static bool ShouldSkipSerialization(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context) { }
        public static void SkipSerialization(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context) { }
    }
    public class static SettingsExtensions
    {
        public static string EndpointName(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static System.Collections.Generic.IList<System.Type> GetAvailableTypes(this NServiceBus.Settings.ReadOnlySettings settings) { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public static T GetConfigSection<T>(this NServiceBus.Settings.ReadOnlySettings settings)
            where T :  class, new () { }
        public static string InstanceSpecificQueue(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static string LocalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
        public static NServiceBus.LogicalAddress LogicalAddress(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
    public class StartupDiagnosticEntries
    {
        public StartupDiagnosticEntries() { }
        public void Add(string sectionName, object section) { }
        public class StartupDiagnosticEntry
        {
            public StartupDiagnosticEntry() { }
            public object Data { get; set; }
            public string Name { get; set; }
        }
    }
    public class static StaticHeadersConfigExtensions
    {
        public static void AddHeaderToAllOutgoingMessages(this NServiceBus.EndpointConfiguration config, string key, string value) { }
    }
    public abstract class StorageType
    {
        public override string ToString() { }
        public sealed class GatewayDeduplication : NServiceBus.StorageType { }
        public sealed class Outbox : NServiceBus.StorageType { }
        public sealed class Sagas : NServiceBus.StorageType { }
        public sealed class Subscriptions : NServiceBus.StorageType { }
        public sealed class Timeouts : NServiceBus.StorageType { }
    }
    public class SubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public SubscribeOptions() { }
    }
    public class SubscriptionMigrationModeSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public SubscriptionMigrationModeSettings(NServiceBus.Settings.SettingsHolder settings) { }
        public void RegisterPublisher(System.Type eventType, string publisherEndpoint) { }
        public void RegisterPublisher(System.Reflection.Assembly assembly, string publisherEndpoint) { }
        public void RegisterPublisher(System.Reflection.Assembly assembly, string @namespace, string publisherEndpoint) { }
        public void SubscriptionAuthorizer(System.Func<NServiceBus.Pipeline.IIncomingPhysicalMessageContext, bool> authorizer) { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.All)]
    public sealed class TimeToBeReceivedAttribute : System.Attribute
    {
        public TimeToBeReceivedAttribute(string timeSpan) { }
        public System.TimeSpan TimeToBeReceived { get; }
    }
    public class static TimeToBeReceivedConventionExtensions
    {
        public static NServiceBus.ConventionsBuilder DefiningTimeToBeReceivedAs(this NServiceBus.ConventionsBuilder builder, System.Func<System.Type, System.TimeSpan> retrieveTimeToBeReceived) { }
    }
    public class TimeoutManagerConfiguration
    {
        public TimeoutManagerConfiguration(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class static TimeoutManagerConfigurationExtensions
    {
        public static void LimitMessageProcessingConcurrencyTo(this NServiceBus.TimeoutManagerConfiguration timeoutManagerConfiguration, int maxConcurrency) { }
        public static NServiceBus.TimeoutManagerConfiguration TimeoutManager(this NServiceBus.EndpointConfiguration endpointConfiguration) { }
    }
    public class ToSagaExpression<TSagaData, TMessage>
        where TSagaData :  class, NServiceBus.IContainSagaData
    {
        public ToSagaExpression(NServiceBus.IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration, System.Linq.Expressions.Expression<System.Func<TMessage, object>> messageProperty) { }
        public void ToSaga(System.Linq.Expressions.Expression<System.Func<TSagaData, object>> sagaEntityProperty) { }
    }
    public class TransportExtensions : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions ConnectionString(System.Func<string> connectionString) { }
        [System.ObsoleteAttribute(@"The ability to used named connection strings has been removed. Instead, load the connection string in your code and pass the value to TransportExtensions.ConnectionString(connectionString). Use `TransportExtensions.ConnectionString(connectionString)` instead. The member currently throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public NServiceBus.TransportExtensions ConnectionStringName(string name) { }
        public NServiceBus.TransportExtensions Transactions(NServiceBus.TransportTransactionMode transportTransactionMode) { }
    }
    public class TransportExtensions<T> : NServiceBus.TransportExtensions
        where T : NServiceBus.Transport.TransportDefinition
    {
        public TransportExtensions(NServiceBus.Settings.SettingsHolder settings) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(string connectionString) { }
        public NServiceBus.TransportExtensions<T> ConnectionString(System.Func<string> connectionString) { }
        [System.ObsoleteAttribute("Loading named connection strings is no longer supported. Use `TransportExtensions" +
            "<T>.ConnectionString(connectionString)` instead. The member currently throws a N" +
            "otImplementedException. Will be removed in version 8.0.0.", true)]
        public NServiceBus.TransportExtensions<T> ConnectionStringName(string name) { }
        public NServiceBus.TransportExtensions<T> Transactions(NServiceBus.TransportTransactionMode transportTransactionMode) { }
    }
    public enum TransportTransactionMode
    {
        None = 0,
        ReceiveOnly = 1,
        SendsAtomicWithReceive = 2,
        TransactionScope = 3,
    }
    public class UnitOfWorkSettings
    {
        public NServiceBus.UnitOfWorkSettings WrapHandlersInATransactionScope(System.Nullable<System.TimeSpan> timeout = null, System.Nullable<System.Transactions.IsolationLevel> isolationLevel = null) { }
    }
    public class static UnitOfWorkSettingsExtensions
    {
        public static NServiceBus.UnitOfWorkSettings UnitOfWork(this NServiceBus.EndpointConfiguration config) { }
    }
    public class UnsubscribeOptions : NServiceBus.Extensibility.ExtendableOptions
    {
        public UnsubscribeOptions() { }
    }
    public class static UseDataBusExtensions
    {
        public static NServiceBus.DataBus.DataBusExtensions<T> UseDataBus<T>(this NServiceBus.EndpointConfiguration config)
            where T : NServiceBus.DataBus.DataBusDefinition, new () { }
        public static NServiceBus.DataBus.DataBusExtensions UseDataBus(this NServiceBus.EndpointConfiguration config, System.Type dataBusType) { }
    }
    public class static UseTransportExtensions
    {
        public static NServiceBus.TransportExtensions<T> UseTransport<T>(this NServiceBus.EndpointConfiguration endpointConfiguration)
            where T : NServiceBus.Transport.TransportDefinition, new () { }
        public static NServiceBus.TransportExtensions UseTransport(this NServiceBus.EndpointConfiguration endpointConfiguration, System.Type transportDefinitionType) { }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Use `NServiceBus.Encryption.MessageProperty.EncryptedStr" +
        "ing` instead. Will be removed in version 8.0.0.", true)]
    public class WireEncryptedString
    {
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public WireEncryptedString() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public WireEncryptedString(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public NServiceBus.EncryptedValue EncryptedValue { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public string Value { get; set; }
    }
    public class static XmlSerializationExtensions
    {
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> DontWrapRawXml(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config) { }
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> Namespace(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config, string namespaceToUse) { }
        public static NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> SanitizeInput(this NServiceBus.Serialization.SerializationExtensions<NServiceBus.XmlSerializer> config) { }
    }
    public class XmlSerializer : NServiceBus.Serialization.SerializationDefinition
    {
        public XmlSerializer() { }
        public override System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings) { }
    }
}
namespace NServiceBus.AutomaticSubscriptions.Config
{
    public class AutoSubscribeSettings
    {
        public NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings DisableFor<T>() { }
        public NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings DisableFor(System.Type eventType) { }
        public void DoNotAutoSubscribeSagas() { }
    }
}
namespace NServiceBus.Config
{
    [System.ObsoleteAttribute("Auditing can not be configured using a configuration file. Will be removed in ver" +
        "sion 8.0.0.", true)]
    public class AuditConfig
    {
        public AuditConfig() { }
        [System.ObsoleteAttribute("Auditing can not be configured using a configuration file. Use `EndpointConfigura" +
            "tion.AuditProcessedMessagesTo` instead. The member currently throws a NotImpleme" +
            "ntedException. Will be removed in version 8.0.0.", true)]
        public System.TimeSpan OverrideTimeToBeReceived { get; set; }
        [System.ObsoleteAttribute("Auditing can not be configured using a configuration file. Use `EndpointConfigura" +
            "tion.AuditProcessedMessagesTo` instead. The member currently throws a NotImpleme" +
            "ntedException. Will be removed in version 8.0.0.", true)]
        public string QueueName { get; set; }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be removed in version 8.0.0.", true)]
    public enum KeyFormat
    {
        Ascii = 0,
        Base64 = 1,
    }
    [System.ObsoleteAttribute("Logging can not be configured using a configuration file. Use `LogManager.Use<Def" +
        "aultFactory>()` instead. Will be removed in version 8.0.0.", true)]
    public class Logging
    {
        public Logging() { }
        [System.ObsoleteAttribute("Logging can not be configured using a configuration file. Use `LogManager.Use<Def" +
            "aultFactory>().Level(LogLevel)` instead. The member currently throws a NotImplem" +
            "entedException. Will be removed in version 8.0.0.", true)]
        public string Threshold { get; set; }
    }
    [System.ObsoleteAttribute("Use code-based configuration instead. Will be removed in version 8.0.0.", true)]
    public class MessageEndpointMapping : System.IComparable<NServiceBus.Config.MessageEndpointMapping>
    {
        public MessageEndpointMapping() { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public string AssemblyName { get; set; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public string Endpoint { get; set; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public string Messages { get; set; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public string Namespace { get; set; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public string TypeFullName { get; set; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public int CompareTo(NServiceBus.Config.MessageEndpointMapping other) { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public void Configure(System.Action<System.Type, string> mapTypeToEndpoint) { }
    }
    [System.ObsoleteAttribute("Use code-based configuration instead. Will be removed in version 8.0.0.", true)]
    public class MessageEndpointMappingCollection
    {
        public MessageEndpointMappingCollection() { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public string AddElementName { get; set; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public string ClearElementName { get; set; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public int Count { get; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public NServiceBus.Config.MessageEndpointMapping this[int index] { get; set; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public NServiceBus.Config.MessageEndpointMapping this[string Name] { get; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public string RemoveElementName { get; }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public void Add(NServiceBus.Config.MessageEndpointMapping mapping) { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public void Clear() { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public int IndexOf(NServiceBus.Config.MessageEndpointMapping mapping) { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public bool IsReadOnly() { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public void Remove(NServiceBus.Config.MessageEndpointMapping mapping) { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public void Remove(string name) { }
        [System.ObsoleteAttribute("Use code-based configuration instead. The member currently throws a NotImplemente" +
            "dException. Will be removed in version 8.0.0.", true)]
        public void RemoveAt(int index) { }
    }
    [System.ObsoleteAttribute("Message forwarding for failed messages can not be configured using a configuratio" +
        "n file. Use `EndpointConfiguration.SendFailedMessagesTo` instead. Will be remove" +
        "d in version 8.0.0.", true)]
    public class MessageForwardingInCaseOfFaultConfig
    {
        public MessageForwardingInCaseOfFaultConfig() { }
        [System.ObsoleteAttribute("Message forwarding for failed messages can not be configured using a configuratio" +
            "n file. Use `EndpointConfiguration.SendFailedMessagesTo` instead. The member cur" +
            "rently throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public string ErrorQueue { get; set; }
    }
    [System.ObsoleteAttribute("MSMQ subscription storage can not be configured using a configuration file. Use `" +
        "EndpointConfiguration.UsePersistence<MsmqPersistence>()` instead. Will be remove" +
        "d in version 8.0.0.", true)]
    public class MsmqSubscriptionStorageConfig
    {
        public MsmqSubscriptionStorageConfig() { }
        [System.ObsoleteAttribute("MSMQ subscription storage can not be configured using a configuration file. Use `" +
            "EndpointConfiguration.UsePersistence<MsmqPersistence>().SubscriptionQueue` inste" +
            "ad. The member currently throws a NotImplementedException. Will be removed in ve" +
            "rsion 8.0.0.", true)]
        public string Queue { get; set; }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be removed in version 8.0.0.", true)]
    public class RijndaelEncryptionServiceConfig
    {
        public RijndaelEncryptionServiceConfig() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public NServiceBus.Config.RijndaelExpiredKeyCollection ExpiredKeys { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public string Key { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public NServiceBus.Config.KeyFormat KeyFormat { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public string KeyIdentifier { get; set; }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be removed in version 8.0.0.", true)]
    public class RijndaelExpiredKey
    {
        public RijndaelExpiredKey() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public string Key { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public NServiceBus.Config.KeyFormat KeyFormat { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public string KeyIdentifier { get; set; }
    }
    [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
        "ssageProperty\' package. Will be removed in version 8.0.0.", true)]
    public class RijndaelExpiredKeyCollection
    {
        public RijndaelExpiredKeyCollection() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public NServiceBus.Config.RijndaelExpiredKey this[int index] { get; set; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public NServiceBus.Config.RijndaelExpiredKey this[string key] { get; }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public void Add(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public void Clear() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public int IndexOf(NServiceBus.Config.RijndaelExpiredKey encryptionKey) { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public bool IsReadOnly() { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public void Remove(NServiceBus.Config.RijndaelExpiredKey mapping) { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public void Remove(string name) { }
        [System.ObsoleteAttribute("Message property encryption is released as a dedicated \'NServiceBus.Encryption.Me" +
            "ssageProperty\' package. The member currently throws a NotImplementedException. W" +
            "ill be removed in version 8.0.0.", true)]
        public void RemoveAt(int index) { }
    }
    [System.ObsoleteAttribute("The UnicastBus can not be configured using a configuration file. Will be removed " +
        "in version 8.0.0.", true)]
    public class UnicastBusConfig
    {
        public UnicastBusConfig() { }
        [System.ObsoleteAttribute("UnicastBus message mapping can not be configured using a configuration file. Use " +
            "`EndpointConfiguration.UseTransport<T>.Routing()` instead. The member currently " +
            "throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public NServiceBus.Config.MessageEndpointMappingCollection MessageEndpointMappings { get; set; }
        [System.ObsoleteAttribute("UnicastBus time to be received for forwarded messages can not be configured using" +
            " a configuration file. The member currently throws a NotImplementedException. Wi" +
            "ll be removed in version 8.0.0.", true)]
        public System.TimeSpan TimeToBeReceivedOnForwardedMessages { get; set; }
        [System.ObsoleteAttribute("UnicastBus timeout manager can not be configured using a configuration file. Use " +
            "`EndpointConfiguration.UseExternalTimeoutManager` instead. The member currently " +
            "throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public string TimeoutManagerAddress { get; set; }
    }
}
namespace NServiceBus.Config.ConfigurationSource
{
    [System.ObsoleteAttribute("Use code-based configuration instead of IConfigurationSource. Will be removed in " +
        "version 8.0.0.", true)]
    public interface IConfigurationSource
    {
        [System.ObsoleteAttribute("Use code-based configuration instead of IConfigurationSource. Will be removed in " +
            "version 8.0.0.", true)]
        T GetConfiguration<T>()
            where T :  class, new ();
    }
    [System.ObsoleteAttribute("Use code-based configuration instead of IProvideConfiguration. Will be removed in" +
        " version 8.0.0.", true)]
    public interface IProvideConfiguration<T>
    {
        [System.ObsoleteAttribute("Use code-based configuration instead of IProvideConfiguration. Will be removed in" +
            " version 8.0.0.", true)]
        T GetConfiguration();
    }
}
namespace NServiceBus.Configuration.AdvancedExtensibility
{
    public class static AdvancedExtensibilityExtensions
    {
        public static NServiceBus.Settings.SettingsHolder GetSettings(this NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings config) { }
    }
    public abstract class ExposeSettings
    {
        protected ExposeSettings(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.ConsistencyGuarantees
{
    public class static TransactionModeSettingsExtensions
    {
        public static NServiceBus.TransportTransactionMode GetRequiredTransactionModeForReceives(this NServiceBus.Settings.ReadOnlySettings settings) { }
    }
}
namespace NServiceBus.Container
{
    public class ContainerCustomizations
    {
        public NServiceBus.Settings.SettingsHolder Settings { get; }
    }
    public abstract class ContainerDefinition
    {
        protected ContainerDefinition() { }
        public abstract NServiceBus.ObjectBuilder.Common.IContainer CreateContainer(NServiceBus.Settings.ReadOnlySettings settings);
    }
}
namespace NServiceBus.DataBus
{
    public abstract class DataBusDefinition
    {
        protected DataBusDefinition() { }
        protected abstract System.Type ProvidedByFeature();
    }
    public class DataBusExtensions : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public DataBusExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public class DataBusExtensions<T> : NServiceBus.DataBus.DataBusExtensions
        where T : NServiceBus.DataBus.DataBusDefinition
    {
        public DataBusExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
    public interface IDataBus
    {
        System.Threading.Tasks.Task<System.IO.Stream> Get(string key);
        System.Threading.Tasks.Task<string> Put(System.IO.Stream stream, System.TimeSpan timeToBeReceived);
        System.Threading.Tasks.Task Start();
    }
    public interface IDataBusSerializer
    {
        object Deserialize(System.IO.Stream stream);
        void Serialize(object databusProperty, System.IO.Stream stream);
    }
}
namespace NServiceBus.DelayedDelivery
{
    public class DelayDeliveryWith : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DelayDeliveryWith(System.TimeSpan delay) { }
        public System.TimeSpan Delay { get; }
    }
    public abstract class DelayedDeliveryConstraint : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        protected DelayedDeliveryConstraint() { }
    }
    public class DoNotDeliverBefore : NServiceBus.DelayedDelivery.DelayedDeliveryConstraint
    {
        public DoNotDeliverBefore(System.DateTime at) { }
        public System.DateTime At { get; }
    }
    public class static ExternalTimeoutManagerConfigurationExtensions
    {
        public static void UseExternalTimeoutManager(this NServiceBus.EndpointConfiguration endpointConfiguration, string externalTimeoutManagerAddress) { }
    }
}
namespace NServiceBus.DeliveryConstraints
{
    public abstract class DeliveryConstraint
    {
        protected DeliveryConstraint() { }
    }
    public class static DeliveryConstraintContextExtensions
    {
        public static void AddDeliveryConstraint(this NServiceBus.Extensibility.ContextBag context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> GetDeliveryConstraints(this NServiceBus.Extensibility.ContextBag context) { }
        [System.ObsoleteAttribute("Use `DeliveryConstraintContextExtensions.RemoveDeliveryConstraint` instead. The m" +
            "ember currently throws a NotImplementedException. Will be removed in version 8.0" +
            ".0.", true)]
        public static void RemoveDeliveryConstaint(this NServiceBus.Extensibility.ContextBag context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static void RemoveDeliveryConstraint(this NServiceBus.Extensibility.ContextBag context, NServiceBus.DeliveryConstraints.DeliveryConstraint constraint) { }
        public static bool TryGetDeliveryConstraint<T>(this NServiceBus.Extensibility.ContextBag context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
        public static bool TryRemoveDeliveryConstraint<T>(this NServiceBus.Extensibility.ContextBag context, out T constraint)
            where T : NServiceBus.DeliveryConstraints.DeliveryConstraint { }
    }
}
namespace NServiceBus.Extensibility
{
    public class ContextBag : NServiceBus.Extensibility.ReadOnlyContextBag
    {
        public ContextBag(NServiceBus.Extensibility.ContextBag parentBag = null) { }
        public T Get<T>() { }
        public T Get<T>(string key) { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public void Remove<T>() { }
        public void Remove(string key) { }
        public void Set<T>(T t) { }
        public void Set<T>(string key, T t) { }
        public bool TryGet<T>(out T result) { }
        public bool TryGet<T>(string key, out T result) { }
    }
    public abstract class ExtendableOptions
    {
        protected ExtendableOptions() { }
    }
    public class static ExtendableOptionsExtensions
    {
        public static NServiceBus.Extensibility.ContextBag GetExtensions(this NServiceBus.Extensibility.ExtendableOptions options) { }
    }
    public interface IExtendable
    {
        NServiceBus.Extensibility.ContextBag Extensions { get; }
    }
    public interface ReadOnlyContextBag
    {
        T Get<T>();
        T Get<T>(string key);
        bool TryGet<T>(out T result);
        bool TryGet<T>(string key, out T result);
    }
}
namespace NServiceBus.Faults
{
    public class DelayedRetryMessage
    {
        public DelayedRetryMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        [System.ObsoleteAttribute("Use `DelayedRetryMessage(string messageId, Dictionary<string, string> headers, by" +
            "te[] body, Exception exception, int retryAttempt)` instead. Will be removed in v" +
            "ersion 8.0.0.", true)]
        public DelayedRetryMessage(System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public int RetryAttempt { get; }
    }
    public class ErrorsNotifications
    {
        public ErrorsNotifications() { }
        public event System.EventHandler<NServiceBus.Faults.DelayedRetryMessage> MessageHasBeenSentToDelayedRetries;
        public event System.EventHandler<NServiceBus.Faults.ImmediateRetryMessage> MessageHasFailedAnImmediateRetryAttempt;
        public event System.EventHandler<NServiceBus.Faults.FailedMessage> MessageSentToErrorQueue;
    }
    public class FailedMessage
    {
        public FailedMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, string errorQueue) { }
        public byte[] Body { get; }
        public string ErrorQueue { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static FaultsHeaderKeys
    {
        public const string FailedQ = "NServiceBus.FailedQ";
    }
    public class ImmediateRetryMessage
    {
        public ImmediateRetryMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, System.Exception exception, int retryAttempt) { }
        public byte[] Body { get; }
        public System.Exception Exception { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public int RetryAttempt { get; }
    }
}
namespace NServiceBus.Features
{
    public class Audit : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class AutoSubscribe : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be removed in version 8.0.0.", true)]
    public class CriticalTimeMonitoring
    {
        public CriticalTimeMonitoring() { }
    }
    public class DataBus : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public abstract class Feature
    {
        protected Feature() { }
        public bool IsActive { get; }
        public bool IsEnabledByDefault { get; }
        public string Name { get; }
        public string Version { get; }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> settings) { }
        protected void DependsOn<T>()
            where T : NServiceBus.Features.Feature { }
        protected void DependsOn(string featureTypeName) { }
        protected void DependsOnAtLeastOne(params System.Type[] features) { }
        protected void DependsOnAtLeastOne(params string[] featureNames) { }
        protected void DependsOnOptionally(string featureName) { }
        protected void DependsOnOptionally(System.Type featureType) { }
        protected void DependsOnOptionally<T>()
            where T : NServiceBus.Features.Feature { }
        protected void EnableByDefault() { }
        protected void Prerequisite(System.Func<NServiceBus.Features.FeatureConfigurationContext, bool> condition, string description) { }
        protected abstract void Setup(NServiceBus.Features.FeatureConfigurationContext context);
        public override string ToString() { }
    }
    public class FeatureConfigurationContext
    {
        public NServiceBus.ObjectBuilder.IConfigureComponents Container { get; }
        public NServiceBus.Pipeline.PipelineSettings Pipeline { get; }
        public NServiceBus.Settings.ReadOnlySettings Settings { get; }
        public void AddSatelliteReceiver(string name, string transportAddress, NServiceBus.Transport.PushRuntimeSettings runtimeSettings, System.Func<NServiceBus.RecoverabilityConfig, NServiceBus.Transport.ErrorContext, NServiceBus.RecoverabilityAction> recoverabilityPolicy, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Transport.MessageContext, System.Threading.Tasks.Task> onMessage) { }
        [System.ObsoleteAttribute(@"The satellite's transaction mode needs to match the endpoint's transaction mode. As such the 'requiredTransportTransactionMode' parameter is redundant and should be removed. Use `AddSatelliteReceiver(string name, string transportAddress, PushRuntimeSettings runtimeSettings, Func<RecoverabilityConfig, ErrorContext, RecoverabilityAction> recoverabilityPolicy, Func<IBuilder, MessageContext, Task> onMessage)` instead. The member currently throws a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public void AddSatelliteReceiver(string name, string transportAddress, NServiceBus.TransportTransactionMode requiredTransportTransactionMode, NServiceBus.Transport.PushRuntimeSettings runtimeSettings, System.Func<NServiceBus.RecoverabilityConfig, NServiceBus.Transport.ErrorContext, NServiceBus.RecoverabilityAction> recoverabilityPolicy, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Transport.MessageContext, System.Threading.Tasks.Task> onMessage) { }
        public void RegisterStartupTask<TTask>(TTask startupTask)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
        public void RegisterStartupTask<TTask>(System.Func<NServiceBus.ObjectBuilder.IBuilder, TTask> startupTaskFactory)
            where TTask : NServiceBus.Features.FeatureStartupTask { }
    }
    public abstract class FeatureStartupTask
    {
        protected FeatureStartupTask() { }
        protected abstract System.Threading.Tasks.Task OnStart(NServiceBus.IMessageSession session);
        protected abstract System.Threading.Tasks.Task OnStop(NServiceBus.IMessageSession session);
    }
    public enum FeatureState
    {
        Disabled = 0,
        Enabled = 1,
        Active = 2,
        Deactivated = 3,
    }
    public class ForwardReceivedMessages : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryGatewayPersistence : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryOutboxPersistence : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySagaPersistence : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemorySubscriptionPersistence : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class InMemoryTimeoutPersistence : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute(@"It's not recommended to disable the MessageDrivenSubscriptions feature and this option will be removed in future versions. Use 'transportSettings.DisablePublishing()' to avoid the need for a subscription storage if this endpoint does not publish events. Use `TransportExtensions<T>.DisablePublishing()` instead. Will be removed in version 8.0.0.", true)]
    public class MessageDrivenSubscriptions : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Outbox : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be removed in version 8.0.0.", true)]
    public class ReceiveStatisticsPerformanceCounters
    {
        public ReceiveStatisticsPerformanceCounters() { }
    }
    [System.ObsoleteAttribute("Performance counters have been released as a separate package: NServiceBus.Metric" +
        "s.PerformanceCounters. Will be removed in version 8.0.0.", true)]
    public class SLAMonitoring
    {
        public SLAMonitoring() { }
    }
    public class Sagas : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class Scheduler : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
    public class static SettingsExtensions
    {
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault<T>(this NServiceBus.Settings.SettingsHolder settings)
            where T : NServiceBus.Features.Feature { }
        public static NServiceBus.Settings.SettingsHolder EnableFeatureByDefault(this NServiceBus.Settings.SettingsHolder settings, System.Type featureType) { }
        public static bool IsFeatureActive(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
        public static bool IsFeatureEnabled(this NServiceBus.Settings.ReadOnlySettings settings, System.Type featureType) { }
    }
    public class TimeoutManager : NServiceBus.Features.Feature
    {
        protected override void Setup(NServiceBus.Features.FeatureConfigurationContext context) { }
    }
}
namespace NServiceBus.Gateway.Deduplication
{
    public interface IDeduplicateMessages
    {
        System.Threading.Tasks.Task<bool> DeduplicateMessage(string clientId, System.DateTime timeReceived, NServiceBus.Extensibility.ContextBag context);
    }
}
namespace NServiceBus.Hosting.Helpers
{
    public class AssemblyScanner
    {
        public AssemblyScanner() { }
        public AssemblyScanner(string baseDirectoryToScan) { }
        public bool ScanAppDomainAssemblies { get; set; }
        public bool ThrowExceptions { get; set; }
        public NServiceBus.Hosting.Helpers.AssemblyScannerResults GetScannableAssemblies() { }
    }
    public class AssemblyScannerResults
    {
        public AssemblyScannerResults() { }
        public System.Collections.Generic.List<System.Reflection.Assembly> Assemblies { get; }
        public bool ErrorsThrownDuringScanning { get; }
        public System.Collections.Generic.List<NServiceBus.Hosting.Helpers.SkippedFile> SkippedFiles { get; }
        public System.Collections.Generic.List<System.Type> Types { get; }
    }
    public class SkippedFile
    {
        public string FilePath { get; }
        public string SkipReason { get; }
    }
}
namespace NServiceBus.Hosting
{
    public class HostInformation
    {
        public HostInformation(System.Guid hostId, string displayName) { }
        public HostInformation(System.Guid hostId, string displayName, System.Collections.Generic.Dictionary<string, string> properties) { }
        public string DisplayName { get; }
        public System.Guid HostId { get; }
        public System.Collections.Generic.Dictionary<string, string> Properties { get; }
    }
}
namespace NServiceBus.InMemory.Outbox
{
    public class static InMemoryOutboxSettingsExtensions
    {
        public static NServiceBus.Outbox.OutboxSettings TimeToKeepDeduplicationData(this NServiceBus.Outbox.OutboxSettings settings, System.TimeSpan time) { }
    }
}
namespace NServiceBus.Installation
{
    public interface INeedToInstallSomething
    {
        System.Threading.Tasks.Task Install(string identity);
    }
}
namespace NServiceBus.Logging
{
    public class DefaultFactory : NServiceBus.Logging.LoggingFactoryDefinition
    {
        public DefaultFactory() { }
        public void Directory(string directory) { }
        protected override NServiceBus.Logging.ILoggerFactory GetLoggingFactory() { }
        public void Level(NServiceBus.Logging.LogLevel level) { }
    }
    public interface ILog
    {
        bool IsDebugEnabled { get; }
        bool IsErrorEnabled { get; }
        bool IsFatalEnabled { get; }
        bool IsInfoEnabled { get; }
        bool IsWarnEnabled { get; }
        void Debug(string message);
        void Debug(string message, System.Exception exception);
        void DebugFormat(string format, params object[] args);
        void Error(string message);
        void Error(string message, System.Exception exception);
        void ErrorFormat(string format, params object[] args);
        void Fatal(string message);
        void Fatal(string message, System.Exception exception);
        void FatalFormat(string format, params object[] args);
        void Info(string message);
        void Info(string message, System.Exception exception);
        void InfoFormat(string format, params object[] args);
        void Warn(string message);
        void Warn(string message, System.Exception exception);
        void WarnFormat(string format, params object[] args);
    }
    public interface ILoggerFactory
    {
        NServiceBus.Logging.ILog GetLogger(System.Type type);
        NServiceBus.Logging.ILog GetLogger(string name);
    }
    public enum LogLevel
    {
        Debug = 0,
        Info = 1,
        Warn = 2,
        Error = 3,
        Fatal = 4,
    }
    public class static LogManager
    {
        public static NServiceBus.Logging.ILog GetLogger<T>() { }
        public static NServiceBus.Logging.ILog GetLogger(System.Type type) { }
        public static NServiceBus.Logging.ILog GetLogger(string name) { }
        public static T Use<T>()
            where T : NServiceBus.Logging.LoggingFactoryDefinition, new () { }
        public static void UseFactory(NServiceBus.Logging.ILoggerFactory loggerFactory) { }
    }
    public abstract class LoggingFactoryDefinition
    {
        protected LoggingFactoryDefinition() { }
        protected abstract NServiceBus.Logging.ILoggerFactory GetLoggingFactory();
    }
}
namespace NServiceBus.MessageInterfaces
{
    public interface IMessageMapper : NServiceBus.IMessageCreator
    {
        System.Type GetMappedTypeFor(System.Type t);
        System.Type GetMappedTypeFor(string typeName);
        void Initialize(System.Collections.Generic.IEnumerable<System.Type> types);
    }
}
namespace NServiceBus.MessageInterfaces.MessageMapper.Reflection
{
    public class MessageMapper : NServiceBus.IMessageCreator, NServiceBus.MessageInterfaces.IMessageMapper
    {
        public MessageMapper() { }
        public T CreateInstance<T>(System.Action<T> action) { }
        public T CreateInstance<T>() { }
        public object CreateInstance(System.Type t) { }
        public System.Type GetMappedTypeFor(System.Type t) { }
        public System.Type GetMappedTypeFor(string typeName) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> types) { }
    }
}
namespace NServiceBus.MessageMutator
{
    public interface IMutateIncomingMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingMessageContext context);
    }
    public interface IMutateIncomingTransportMessages
    {
        System.Threading.Tasks.Task MutateIncoming(NServiceBus.MessageMutator.MutateIncomingTransportMessageContext context);
    }
    public interface IMutateOutgoingMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingMessageContext context);
    }
    public interface IMutateOutgoingTransportMessages
    {
        System.Threading.Tasks.Task MutateOutgoing(NServiceBus.MessageMutator.MutateOutgoingTransportMessageContext context);
    }
    public class MutateIncomingMessageContext
    {
        public MutateIncomingMessageContext(object message, System.Collections.Generic.Dictionary<string, string> headers) { }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public object Message { get; set; }
    }
    public class MutateIncomingTransportMessageContext
    {
        public MutateIncomingTransportMessageContext(byte[] body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public byte[] Body { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
    }
    public class MutateOutgoingMessageContext
    {
        public MutateOutgoingMessageContext(object outgoingMessage, System.Collections.Generic.Dictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public System.Collections.Generic.Dictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; set; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
    public class MutateOutgoingTransportMessageContext
    {
        public MutateOutgoingTransportMessageContext(byte[] outgoingBody, object outgoingMessage, System.Collections.Generic.Dictionary<string, string> outgoingHeaders, object incomingMessage, System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public byte[] OutgoingBody { get; set; }
        public System.Collections.Generic.Dictionary<string, string> OutgoingHeaders { get; }
        public object OutgoingMessage { get; }
        public bool TryGetIncomingHeaders(out System.Collections.Generic.IReadOnlyDictionary<string, string> incomingHeaders) { }
        public bool TryGetIncomingMessage(out object incomingMessage) { }
    }
    public class static MutatorRegistrationExtensions
    {
        public static void RegisterMessageMutator(this NServiceBus.EndpointConfiguration endpointConfiguration, object messageMutator) { }
    }
}
namespace NServiceBus.ObjectBuilder.Common
{
    public interface IContainer : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        NServiceBus.ObjectBuilder.Common.IContainer BuildChildContainer();
        void Configure(System.Type component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void Configure<T>(System.Func<T> component, NServiceBus.DependencyLifecycle dependencyLifecycle);
        bool HasComponent(System.Type componentType);
        void RegisterSingleton(System.Type lookupType, object instance);
        void Release(object instance);
    }
}
namespace NServiceBus.ObjectBuilder
{
    public interface IBuilder : System.IDisposable
    {
        object Build(System.Type typeToBuild);
        T Build<T>();
        System.Collections.Generic.IEnumerable<T> BuildAll<T>();
        System.Collections.Generic.IEnumerable<object> BuildAll(System.Type typeToBuild);
        void BuildAndDispatch(System.Type typeToBuild, System.Action<object> action);
        NServiceBus.ObjectBuilder.IBuilder CreateChildBuilder();
        void Release(object instance);
    }
    public interface IConfigureComponents
    {
        void ConfigureComponent(System.Type concreteComponent, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(System.Func<T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        void ConfigureComponent<T>(System.Func<NServiceBus.ObjectBuilder.IBuilder, T> componentFactory, NServiceBus.DependencyLifecycle dependencyLifecycle);
        bool HasComponent<T>();
        bool HasComponent(System.Type componentType);
        void RegisterSingleton(System.Type lookupType, object instance);
        void RegisterSingleton<T>(T instance);
    }
}
namespace NServiceBus.Outbox
{
    public interface IOutboxStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxTransaction> BeginTransaction(NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Outbox.OutboxMessage> Get(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task SetAsDispatched(string messageId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Store(NServiceBus.Outbox.OutboxMessage message, NServiceBus.Outbox.OutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context);
    }
    public class OutboxMessage
    {
        public OutboxMessage(string messageId, NServiceBus.Outbox.TransportOperation[] operations) { }
        public string MessageId { get; }
        public NServiceBus.Outbox.TransportOperation[] TransportOperations { get; }
    }
    public class OutboxSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings { }
    public interface OutboxTransaction : System.IDisposable
    {
        System.Threading.Tasks.Task Commit();
    }
    public class TransportOperation
    {
        public TransportOperation(string messageId, System.Collections.Generic.Dictionary<string, string> options, byte[] body, System.Collections.Generic.Dictionary<string, string> headers) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public System.Collections.Generic.Dictionary<string, string> Options { get; }
    }
}
namespace NServiceBus.Performance.TimeToBeReceived
{
    public class DiscardIfNotReceivedBefore : NServiceBus.DeliveryConstraints.DeliveryConstraint
    {
        public DiscardIfNotReceivedBefore(System.TimeSpan maxTime) { }
        public System.TimeSpan MaxTime { get; }
    }
}
namespace NServiceBus.Persistence
{
    public interface CompletableSynchronizedStorageSession : NServiceBus.Persistence.SynchronizedStorageSession, System.IDisposable
    {
        System.Threading.Tasks.Task CompleteAsync();
    }
    public interface ISynchronizedStorage
    {
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> OpenSession(NServiceBus.Extensibility.ContextBag contextBag);
    }
    public interface ISynchronizedStorageAdapter
    {
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> TryAdapt(NServiceBus.Outbox.OutboxTransaction transaction, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Persistence.CompletableSynchronizedStorageSession> TryAdapt(NServiceBus.Transport.TransportTransaction transportTransaction, NServiceBus.Extensibility.ContextBag context);
    }
    public abstract class PersistenceDefinition
    {
        protected PersistenceDefinition() { }
        protected void Defaults(System.Action<NServiceBus.Settings.SettingsHolder> action) { }
        public bool HasSupportFor<T>()
            where T : NServiceBus.StorageType { }
        public bool HasSupportFor(System.Type storageType) { }
        protected void Supports<T>(System.Action<NServiceBus.Settings.SettingsHolder> action)
            where T : NServiceBus.StorageType { }
    }
    public interface SynchronizedStorageSession { }
}
namespace NServiceBus.Pipeline
{
    public abstract class Behavior<TContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TContext, TContext>
        where TContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected Behavior() { }
        public System.Threading.Tasks.Task Invoke(TContext context, System.Func<TContext, System.Threading.Tasks.Task> next) { }
        public abstract System.Threading.Tasks.Task Invoke(TContext context, System.Func<System.Threading.Tasks.Task> next);
    }
    public abstract class ForkConnector<TFromContext, TForkContext> : NServiceBus.Pipeline.Behavior<TFromContext>, NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TFromContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TForkContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected ForkConnector() { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<System.Threading.Tasks.Task> next, System.Func<TForkContext, System.Threading.Tasks.Task> fork);
        public virtual System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<System.Threading.Tasks.Task> next) { }
    }
    public interface IAuditContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        string AuditAddress { get; }
        NServiceBus.Transport.OutgoingMessage Message { get; }
        void AddAuditData(string key, string value);
    }
    public interface IBatchDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Transport.TransportOperation> Operations { get; }
    }
    public interface IBehavior { }
    public interface IBehaviorContext : NServiceBus.Extensibility.IExtendable
    {
        NServiceBus.ObjectBuilder.IBuilder Builder { get; }
    }
    public interface IBehavior<in TInContext, out TOutContext> : NServiceBus.Pipeline.IBehavior
        where in TInContext : NServiceBus.Pipeline.IBehaviorContext
        where out TOutContext : NServiceBus.Pipeline.IBehaviorContext
    {
        System.Threading.Tasks.Task Invoke(TInContext context, System.Func<TOutContext, System.Threading.Tasks.Task> next);
    }
    public interface IDispatchContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.IEnumerable<NServiceBus.Transport.TransportOperation> Operations { get; }
    }
    public interface IForwardingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        string Address { get; }
        NServiceBus.Transport.OutgoingMessage Message { get; }
    }
    public interface IIncomingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext { }
    public interface IIncomingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        NServiceBus.Pipeline.LogicalMessage Message { get; }
        bool MessageHandled { get; set; }
        void UpdateMessageInstance(object newInstance);
    }
    public interface IIncomingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        NServiceBus.Transport.IncomingMessage Message { get; }
        void UpdateMessage(byte[] body);
    }
    public interface IInvokeHandlerContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IMessageHandlerContext, NServiceBus.IMessageProcessingContext, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IIncomingContext
    {
        [System.ObsoleteAttribute("HandleCurrentMessageLater has been deprecated. Will be removed in version 8.0.0.", true)]
        bool HandleCurrentMessageLaterWasCalled { get; }
        bool HandlerInvocationAborted { get; }
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        object MessageBeingHandled { get; }
        NServiceBus.Pipeline.MessageHandler MessageHandler { get; }
        NServiceBus.Unicast.Messages.MessageMetadata MessageMetadata { get; }
    }
    public interface IOutgoingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Collections.Generic.Dictionary<string, string> Headers { get; }
        string MessageId { get; }
    }
    public interface IOutgoingLogicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessage(object newInstance);
    }
    public interface IOutgoingPhysicalMessageContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        byte[] Body { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; }
        void UpdateMessage(byte[] body);
    }
    public interface IOutgoingPublishContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IOutgoingReplyContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IOutgoingSendContext : NServiceBus.Extensibility.IExtendable, NServiceBus.IPipelineContext, NServiceBus.Pipeline.IBehaviorContext, NServiceBus.Pipeline.IOutgoingContext
    {
        NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
    }
    public interface IRoutingContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transport.OutgoingMessage Message { get; }
        System.Collections.Generic.IReadOnlyCollection<NServiceBus.Routing.RoutingStrategy> RoutingStrategies { get; set; }
    }
    public interface ISubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Type EventType { get; }
    }
    public interface ITransportReceiveContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        NServiceBus.Transport.IncomingMessage Message { get; }
        void AbortReceiveOperation();
    }
    public interface IUnsubscribeContext : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
    {
        System.Type EventType { get; }
    }
    public class LogicalMessage
    {
        public LogicalMessage(NServiceBus.Unicast.Messages.MessageMetadata metadata, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Unicast.Messages.MessageMetadata Metadata { get; }
    }
    public class LogicalMessageFactory
    {
        public LogicalMessageFactory(NServiceBus.Unicast.Messages.MessageMetadataRegistry messageMetadataRegistry, NServiceBus.MessageInterfaces.IMessageMapper messageMapper) { }
        public NServiceBus.Pipeline.LogicalMessage Create(object message) { }
        public NServiceBus.Pipeline.LogicalMessage Create(System.Type messageType, object message) { }
    }
    public class MessageHandler
    {
        public MessageHandler(System.Func<object, object, NServiceBus.IMessageHandlerContext, System.Threading.Tasks.Task> invocation, System.Type handlerType) { }
        public System.Type HandlerType { get; }
        public object Instance { get; set; }
        public System.Threading.Tasks.Task Invoke(object message, NServiceBus.IMessageHandlerContext handlerContext) { }
    }
    public class OutgoingLogicalMessage
    {
        public OutgoingLogicalMessage(System.Type messageType, object message) { }
        public object Instance { get; }
        public System.Type MessageType { get; }
    }
    public class PipelineSettings : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
    {
        public void Register(System.Type behavior, string description) { }
        public void Register(string stepId, System.Type behavior, string description) { }
        public void Register<T>(System.Func<NServiceBus.ObjectBuilder.IBuilder, T> factoryMethod, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(string stepId, System.Func<NServiceBus.ObjectBuilder.IBuilder, T> factoryMethod, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(T behavior, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<T>(string stepId, T behavior, string description)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Register<TRegisterStep>()
            where TRegisterStep : NServiceBus.Pipeline.RegisterStep, new () { }
        public void Register(NServiceBus.Pipeline.RegisterStep registration) { }
        public void Remove(string stepId) { }
        public void Replace(string stepId, System.Type newBehavior, string description = null) { }
        public void Replace<T>(string stepId, T newBehavior, string description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
        public void Replace<T>(string stepId, System.Func<NServiceBus.ObjectBuilder.IBuilder, T> factoryMethod, string description = null)
            where T : NServiceBus.Pipeline.IBehavior { }
    }
    public abstract class PipelineTerminator<T> : NServiceBus.Pipeline.StageConnector<T, NServiceBus.Pipeline.PipelineTerminator<T>.ITerminatingContext>
        where T : NServiceBus.Pipeline.IBehaviorContext
    {
        protected PipelineTerminator() { }
        public virtual System.Threading.Tasks.Task Invoke(T context, System.Func<NServiceBus.Pipeline.PipelineTerminator<T>.ITerminatingContext, System.Threading.Tasks.Task> next) { }
        protected abstract System.Threading.Tasks.Task Terminate(T context);
        public interface ITerminatingContext<T> : NServiceBus.Extensibility.IExtendable, NServiceBus.Pipeline.IBehaviorContext
            where T : NServiceBus.Pipeline.IBehaviorContext { }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{StepId}({BehaviorType.FullName}) - {Description}")]
    public abstract class RegisterStep
    {
        protected RegisterStep(string stepId, System.Type behavior, string description, System.Func<NServiceBus.ObjectBuilder.IBuilder, NServiceBus.Pipeline.IBehavior> factoryMethod = null) { }
        public System.Type BehaviorType { get; }
        public string Description { get; }
        public string StepId { get; }
        public void InsertAfter(string id) { }
        public void InsertAfterIfExists(string id) { }
        public void InsertBefore(string id) { }
        public void InsertBeforeIfExists(string id) { }
    }
    public abstract class StageConnector<TFromContext, TToContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TToContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TToContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected StageConnector() { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> stage);
    }
    public abstract class StageForkConnector<TFromContext, TToContext, TForkContext> : NServiceBus.Pipeline.IBehavior, NServiceBus.Pipeline.IBehavior<TFromContext, TToContext>
        where TFromContext : NServiceBus.Pipeline.IBehaviorContext
        where TToContext : NServiceBus.Pipeline.IBehaviorContext
        where TForkContext : NServiceBus.Pipeline.IBehaviorContext
    {
        protected StageForkConnector() { }
        public System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> next) { }
        public abstract System.Threading.Tasks.Task Invoke(TFromContext context, System.Func<TToContext, System.Threading.Tasks.Task> stage, System.Func<TForkContext, System.Threading.Tasks.Task> fork);
    }
    public class static TransportMessageContextExtensions
    {
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingReplyContext context, out NServiceBus.Transport.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingLogicalMessageContext context, out NServiceBus.Transport.IncomingMessage message) { }
        public static bool TryGetIncomingPhysicalMessage(this NServiceBus.Pipeline.IOutgoingPhysicalMessageContext context, out NServiceBus.Transport.IncomingMessage message) { }
    }
}
namespace NServiceBus.Routing
{
    public abstract class AddressTag
    {
        protected AddressTag() { }
    }
    public class DistributionContext : NServiceBus.Extensibility.IExtendable
    {
        public DistributionContext(string[] receiverAddresses, NServiceBus.Pipeline.OutgoingLogicalMessage message, string messageId, System.Collections.Generic.Dictionary<string, string> headers, System.Func<NServiceBus.Routing.EndpointInstance, string> addressTranslation, NServiceBus.Extensibility.ContextBag extensions) { }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public NServiceBus.Pipeline.OutgoingLogicalMessage Message { get; }
        public string MessageId { get; }
        public string[] ReceiverAddresses { get; }
        public string ToTransportAddress(NServiceBus.Routing.EndpointInstance endpointInstance) { }
    }
    public abstract class DistributionStrategy
    {
        protected DistributionStrategy(string endpoint, NServiceBus.DistributionStrategyScope scope) { }
        public string Endpoint { get; }
        public NServiceBus.DistributionStrategyScope Scope { get; }
        public abstract string SelectDestination(NServiceBus.Routing.DistributionContext context);
    }
    public sealed class EndpointInstance
    {
        public EndpointInstance(string endpoint, string discriminator = null, System.Collections.Generic.IReadOnlyDictionary<string, string> properties = null) { }
        public string Discriminator { get; }
        public string Endpoint { get; }
        public System.Collections.Generic.IReadOnlyDictionary<string, string> Properties { get; }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public NServiceBus.Routing.EndpointInstance SetProperty(string key, string value) { }
        public override string ToString() { }
        public static bool ==(NServiceBus.Routing.EndpointInstance left, NServiceBus.Routing.EndpointInstance right) { }
        public static bool !=(NServiceBus.Routing.EndpointInstance left, NServiceBus.Routing.EndpointInstance right) { }
    }
    public class EndpointInstances
    {
        public EndpointInstances() { }
        public void AddOrReplaceInstances(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.EndpointInstance> endpointInstances) { }
        public System.Collections.Generic.IEnumerable<NServiceBus.Routing.EndpointInstance> FindInstances(string endpoint) { }
    }
    public interface IMessageDrivenSubscriptionTransport { }
    public class MulticastAddressTag : NServiceBus.Routing.AddressTag
    {
        public MulticastAddressTag(System.Type messageType) { }
        public System.Type MessageType { get; }
    }
    public class MulticastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public MulticastRoutingStrategy(System.Type messageType) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public class RouteTableEntry
    {
        public RouteTableEntry(System.Type messageType, NServiceBus.Routing.UnicastRoute route) { }
        public System.Type MessageType { get; }
        public NServiceBus.Routing.UnicastRoute Route { get; }
    }
    public abstract class RoutingStrategy
    {
        protected RoutingStrategy() { }
        public abstract NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers);
    }
    public class SingleInstanceRoundRobinDistributionStrategy : NServiceBus.Routing.DistributionStrategy
    {
        public SingleInstanceRoundRobinDistributionStrategy(string endpoint, NServiceBus.DistributionStrategyScope scope) { }
        public override string SelectDestination(NServiceBus.Routing.DistributionContext context) { }
    }
    public class UnicastAddressTag : NServiceBus.Routing.AddressTag
    {
        public UnicastAddressTag(string destination) { }
        public string Destination { get; }
    }
    public class UnicastRoute
    {
        public string Endpoint { get; }
        public NServiceBus.Routing.EndpointInstance Instance { get; }
        public string PhysicalAddress { get; }
        public static NServiceBus.Routing.UnicastRoute CreateFromEndpointInstance(NServiceBus.Routing.EndpointInstance instance) { }
        public static NServiceBus.Routing.UnicastRoute CreateFromEndpointName(string endpoint) { }
        public static NServiceBus.Routing.UnicastRoute CreateFromPhysicalAddress(string physicalAddress) { }
        public override string ToString() { }
    }
    public class UnicastRoutingStrategy : NServiceBus.Routing.RoutingStrategy
    {
        public UnicastRoutingStrategy(string destination) { }
        public override NServiceBus.Routing.AddressTag Apply(System.Collections.Generic.Dictionary<string, string> headers) { }
    }
    public class UnicastRoutingTable
    {
        public UnicastRoutingTable() { }
        public void AddOrReplaceRoutes(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.RouteTableEntry> entries) { }
    }
}
namespace NServiceBus.Routing.Legacy
{
    [System.ObsoleteAttribute("The distributor is no longer supported. Will be removed in version 8.0.0.", true)]
    public class static ConfigureMSMQDistributor
    {
        [System.ObsoleteAttribute("The distributor is no longer supported. The member currently throws a NotImplemen" +
            "tedException. Will be removed in version 8.0.0.", true)]
        public static void EnlistWithLegacyMSMQDistributor(this NServiceBus.EndpointConfiguration config, string masterNodeAddress, string masterNodeControlAddress, int capacity) { }
    }
}
namespace NServiceBus.Routing.MessageDrivenSubscriptions
{
    public class PublisherAddress
    {
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromEndpointInstances(params NServiceBus.Routing.EndpointInstance[] instances) { }
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromEndpointName(string endpoint) { }
        public static NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress CreateFromPhysicalAddresses(params string[] addresses) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
    }
    public class PublisherTableEntry
    {
        public PublisherTableEntry(System.Type eventType, NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress address) { }
        public NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress Address { get; }
        public System.Type EventType { get; }
    }
    public class Publishers
    {
        public Publishers() { }
        public void AddOrReplacePublishers(string sourceKey, System.Collections.Generic.IList<NServiceBus.Routing.MessageDrivenSubscriptions.PublisherTableEntry> entries) { }
    }
}
namespace NServiceBus.Sagas
{
    public class ActiveSagaInstance
    {
        public ActiveSagaInstance(NServiceBus.Saga saga, NServiceBus.Sagas.SagaMetadata metadata, System.Func<System.DateTime> currentUtcDateTimeProvider) { }
        public System.DateTime Created { get; }
        public NServiceBus.Saga Instance { get; }
        public bool IsNew { get; }
        public System.DateTime Modified { get; }
        public bool NotFound { get; }
        public string SagaId { get; }
        public void AttachNewEntity(NServiceBus.IContainSagaData sagaEntity) { }
    }
    public abstract class IFindSagas<T>
        where T : NServiceBus.IContainSagaData
    {
        protected IFindSagas() { }
        public interface Using<T, M> : NServiceBus.Sagas.IFinder
            where T : NServiceBus.IContainSagaData
        {
            System.Threading.Tasks.Task<T> FindBy(M message, NServiceBus.Persistence.SynchronizedStorageSession storageSession, NServiceBus.Extensibility.ReadOnlyContextBag context);
        }
    }
    public interface IFinder { }
    public interface IHandleSagaNotFound
    {
        System.Threading.Tasks.Task Handle(object message, NServiceBus.IMessageProcessingContext context);
    }
    public interface ISagaIdGenerator
    {
        System.Guid Generate(NServiceBus.Sagas.SagaIdGeneratorContext context);
    }
    public interface ISagaPersister
    {
        System.Threading.Tasks.Task Complete(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(System.Guid sagaId, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context)
            where TSagaData :  class, NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task<TSagaData> Get<TSagaData>(string propertyName, object propertyValue, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context)
            where TSagaData :  class, NServiceBus.IContainSagaData;
        System.Threading.Tasks.Task Save(NServiceBus.IContainSagaData sagaData, NServiceBus.Sagas.SagaCorrelationProperty correlationProperty, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Update(NServiceBus.IContainSagaData sagaData, NServiceBus.Persistence.SynchronizedStorageSession session, NServiceBus.Extensibility.ContextBag context);
    }
    public class SagaCorrelationProperty
    {
        public SagaCorrelationProperty(string name, object value) { }
        public string Name { get; }
        public static NServiceBus.Sagas.SagaCorrelationProperty None { get; }
        public object Value { get; }
    }
    public class SagaFinderDefinition
    {
        public System.Type MessageType { get; }
        public string MessageTypeName { get; }
        public System.Collections.Generic.Dictionary<string, object> Properties { get; }
        public System.Type Type { get; }
    }
    public class SagaIdGeneratorContext : NServiceBus.Extensibility.IExtendable
    {
        public SagaIdGeneratorContext(NServiceBus.Sagas.SagaCorrelationProperty correlationProperty, NServiceBus.Sagas.SagaMetadata sagaMetadata, NServiceBus.Extensibility.ContextBag extensions) { }
        public NServiceBus.Sagas.SagaCorrelationProperty CorrelationProperty { get; }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public NServiceBus.Sagas.SagaMetadata SagaMetadata { get; }
    }
    public class SagaMessage
    {
        public bool IsAllowedToStartSaga { get; }
        public System.Type MessageType { get; }
        public string MessageTypeName { get; }
    }
    public class SagaMetadata
    {
        public SagaMetadata(string name, System.Type sagaType, string entityName, System.Type sagaEntityType, NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata correlationProperty, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> messages, System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> finders) { }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaMessage> AssociatedMessages { get; }
        public string EntityName { get; }
        public System.Collections.Generic.IReadOnlyCollection<NServiceBus.Sagas.SagaFinderDefinition> Finders { get; }
        public string Name { get; }
        public System.Type SagaEntityType { get; }
        public System.Type SagaType { get; }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType) { }
        public static NServiceBus.Sagas.SagaMetadata Create(System.Type sagaType, System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
        public bool IsMessageAllowedToStartTheSaga(string messageType) { }
        public bool TryGetCorrelationProperty(out NServiceBus.Sagas.SagaMetadata.CorrelationPropertyMetadata property) { }
        public bool TryGetFinder(string messageType, out NServiceBus.Sagas.SagaFinderDefinition finderDefinition) { }
        public class CorrelationPropertyMetadata
        {
            public CorrelationPropertyMetadata(string name, System.Type type) { }
            public string Name { get; }
            public System.Type Type { get; }
        }
    }
    public class SagaMetadataCollection : System.Collections.Generic.IEnumerable<NServiceBus.Sagas.SagaMetadata>, System.Collections.IEnumerable
    {
        public SagaMetadataCollection() { }
        public NServiceBus.Sagas.SagaMetadata Find(System.Type sagaType) { }
        public NServiceBus.Sagas.SagaMetadata FindByEntity(System.Type entityType) { }
        public System.Collections.Generic.IEnumerator<NServiceBus.Sagas.SagaMetadata> GetEnumerator() { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes) { }
        public void Initialize(System.Collections.Generic.IEnumerable<System.Type> availableTypes, NServiceBus.Conventions conventions) { }
    }
}
namespace NServiceBus.Serialization
{
    public interface IMessageSerializer
    {
        string ContentType { get; }
        object[] Deserialize(System.IO.Stream stream, System.Collections.Generic.IList<System.Type> messageTypes = null);
        void Serialize(object message, System.IO.Stream stream);
    }
    public abstract class SerializationDefinition
    {
        protected SerializationDefinition() { }
        public abstract System.Func<NServiceBus.MessageInterfaces.IMessageMapper, NServiceBus.Serialization.IMessageSerializer> Configure(NServiceBus.Settings.ReadOnlySettings settings);
    }
    public class SerializationExtensions<T> : NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings
        where T : NServiceBus.Serialization.SerializationDefinition
    {
        public SerializationExtensions(NServiceBus.Settings.SettingsHolder settings) { }
    }
}
namespace NServiceBus.Settings
{
    public interface ReadOnlySettings
    {
        T Get<T>();
        T Get<T>(string key);
        object Get(string key);
        T GetOrDefault<T>();
        T GetOrDefault<T>(string key);
        bool HasExplicitValue(string key);
        bool HasExplicitValue<T>();
        bool HasSetting(string key);
        bool HasSetting<T>();
        bool TryGet<T>(out T val);
        bool TryGet<T>(string key, out T val);
    }
    public class SettingsHolder : NServiceBus.Settings.ReadOnlySettings
    {
        public SettingsHolder() { }
        public void Clear() { }
        public T Get<T>(string key) { }
        public T Get<T>() { }
        public object Get(string key) { }
        public T GetOrCreate<T>()
            where T :  class, new () { }
        public T GetOrDefault<T>() { }
        public T GetOrDefault<T>(string key) { }
        public bool HasExplicitValue(string key) { }
        public bool HasExplicitValue<T>() { }
        public bool HasSetting(string key) { }
        public bool HasSetting<T>() { }
        public void Set(string key, object value) { }
        [System.ObsoleteAttribute("Use `Set<T>(T value)` instead. Will be treated as an error from version 8.0.0. Wi" +
            "ll be removed in version 9.0.0.", false)]
        public void Set<T>(object value) { }
        public void Set<T>(T value) { }
        public void Set<T>(System.Action value) { }
        [System.ObsoleteAttribute("Use `SetDefault<T>(T value)` instead. Will be treated as an error from version 8." +
            "0.0. Will be removed in version 9.0.0.", false)]
        public void SetDefault<T>(object value) { }
        public void SetDefault<T>(T value) { }
        public void SetDefault<T>(System.Action value) { }
        public void SetDefault(string key, object value) { }
        public bool TryGet<T>(out T val) { }
        public bool TryGet<T>(string key, out T val) { }
    }
}
namespace NServiceBus.Support
{
    public class static RuntimeEnvironment
    {
        public static string MachineName { get; }
        public static System.Func<string> MachineNameAction { get; set; }
    }
}
namespace NServiceBus.Timeout.Core
{
    public interface IPersistTimeouts
    {
        System.Threading.Tasks.Task Add(NServiceBus.Timeout.Core.TimeoutData timeout, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutData> Peek(string timeoutId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task RemoveTimeoutBy(System.Guid sagaId, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task<bool> TryRemove(string timeoutId, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IQueryTimeouts
    {
        System.Threading.Tasks.Task<NServiceBus.Timeout.Core.TimeoutsChunk> GetNextChunk(System.DateTime startSlice);
    }
    public class TimeoutData
    {
        public TimeoutData() { }
        public string Destination { get; set; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
        public string Id { get; set; }
        public string OwningTimeoutManager { get; set; }
        public System.Guid SagaId { get; set; }
        public byte[] State { get; set; }
        public System.DateTime Time { get; set; }
        public override string ToString() { }
    }
    public class TimeoutsChunk
    {
        public TimeoutsChunk(Timeout[] dueTimeouts, System.DateTime nextTimeToQuery) { }
        public Timeout[] DueTimeouts { get; }
        public System.DateTime NextTimeToQuery { get; }
        public struct Timeout
        {
            public Timeout(string id, System.DateTime dueTime) { }
            public System.DateTime DueTime { get; }
            public string Id { get; }
        }
    }
}
namespace NServiceBus.Transport
{
    public enum DispatchConsistency
    {
        Default = 1,
        Isolated = 2,
    }
    public class ErrorContext
    {
        public ErrorContext(System.Exception exception, System.Collections.Generic.Dictionary<string, string> headers, string transportMessageId, byte[] body, NServiceBus.Transport.TransportTransaction transportTransaction, int immediateProcessingFailures) { }
        public int DelayedDeliveriesPerformed { get; }
        public System.Exception Exception { get; }
        public int ImmediateProcessingFailures { get; }
        public NServiceBus.Transport.IncomingMessage Message { get; }
        public NServiceBus.Transport.TransportTransaction TransportTransaction { get; }
    }
    public enum ErrorHandleResult
    {
        Handled = 0,
        RetryRequired = 1,
    }
    public interface ICancelDeferredMessages
    {
        System.Threading.Tasks.Task CancelDeferredMessages(string messageKey, NServiceBus.Pipeline.IBehaviorContext context);
    }
    public interface ICreateQueues
    {
        System.Threading.Tasks.Task CreateQueueIfNecessary(NServiceBus.Transport.QueueBindings queueBindings, string identity);
    }
    public interface IDispatchMessages
    {
        System.Threading.Tasks.Task Dispatch(NServiceBus.Transport.TransportOperations outgoingMessages, NServiceBus.Transport.TransportTransaction transaction, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IManageSubscriptions
    {
        System.Threading.Tasks.Task Subscribe(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(System.Type eventType, NServiceBus.Extensibility.ContextBag context);
    }
    public interface IOutgoingTransportOperation
    {
        System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        NServiceBus.Transport.OutgoingMessage Message { get; }
        NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
    public interface IPushMessages
    {
        System.Threading.Tasks.Task Init(System.Func<NServiceBus.Transport.MessageContext, System.Threading.Tasks.Task> onMessage, System.Func<NServiceBus.Transport.ErrorContext, System.Threading.Tasks.Task<NServiceBus.Transport.ErrorHandleResult>> onError, NServiceBus.CriticalError criticalError, NServiceBus.Transport.PushSettings settings);
        void Start(NServiceBus.Transport.PushRuntimeSettings limitations);
        System.Threading.Tasks.Task Stop();
    }
    public class IncomingMessage
    {
        public IncomingMessage(string nativeMessageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class static IncomingMessageExtensions
    {
        public static NServiceBus.MessageIntentEnum GetMessageIntent(this NServiceBus.Transport.IncomingMessage message) { }
        [System.ObsoleteAttribute("Use `IncomingMessageExtensions.GetMessageIntent` instead. The member currently th" +
            "rows a NotImplementedException. Will be removed in version 8.0.0.", true)]
        public static NServiceBus.MessageIntentEnum GetMesssageIntent(this NServiceBus.Transport.IncomingMessage message) { }
        public static string GetReplyToAddress(this NServiceBus.Transport.IncomingMessage message) { }
    }
    public class static LogicalAddressExtensions
    {
        public static string GetTransportAddress(this NServiceBus.Settings.ReadOnlySettings settings, NServiceBus.LogicalAddress logicalAddress) { }
    }
    public class MessageContext : NServiceBus.Extensibility.IExtendable
    {
        public MessageContext(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body, NServiceBus.Transport.TransportTransaction transportTransaction, System.Threading.CancellationTokenSource receiveCancellationTokenSource, NServiceBus.Extensibility.ContextBag context) { }
        public byte[] Body { get; }
        public NServiceBus.Extensibility.ContextBag Extensions { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
        public System.Threading.CancellationTokenSource ReceiveCancellationTokenSource { get; }
        public NServiceBus.Transport.TransportTransaction TransportTransaction { get; }
    }
    public class MulticastTransportOperation : NServiceBus.Transport.IOutgoingTransportOperation
    {
        public MulticastTransportOperation(NServiceBus.Transport.OutgoingMessage message, System.Type messageType, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public System.Type MessageType { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
    public class OutboundRoutingPolicy
    {
        public OutboundRoutingPolicy(NServiceBus.Transport.OutboundRoutingType sends, NServiceBus.Transport.OutboundRoutingType publishes, NServiceBus.Transport.OutboundRoutingType replies) { }
        public NServiceBus.Transport.OutboundRoutingType Publishes { get; }
        public NServiceBus.Transport.OutboundRoutingType Replies { get; }
        public NServiceBus.Transport.OutboundRoutingType Sends { get; }
    }
    public enum OutboundRoutingType
    {
        Unicast = 0,
        Multicast = 1,
    }
    public class OutgoingMessage
    {
        public OutgoingMessage(string messageId, System.Collections.Generic.Dictionary<string, string> headers, byte[] body) { }
        public byte[] Body { get; }
        public System.Collections.Generic.Dictionary<string, string> Headers { get; }
        public string MessageId { get; }
    }
    public class PushRuntimeSettings
    {
        public PushRuntimeSettings() { }
        public PushRuntimeSettings(int maxConcurrency) { }
        public static NServiceBus.Transport.PushRuntimeSettings Default { get; }
        public int MaxConcurrency { get; }
    }
    public class PushSettings
    {
        public PushSettings(string inputQueue, string errorQueue, bool purgeOnStartup, NServiceBus.TransportTransactionMode requiredTransactionMode) { }
        public string ErrorQueue { get; }
        public string InputQueue { get; }
        public bool PurgeOnStartup { get; }
        public NServiceBus.TransportTransactionMode RequiredTransactionMode { get; }
    }
    public class QueueBindings
    {
        public QueueBindings() { }
        public System.Collections.Generic.IReadOnlyCollection<string> ReceivingAddresses { get; }
        public System.Collections.Generic.IReadOnlyCollection<string> SendingAddresses { get; }
        public void BindReceiving(string address) { }
        public void BindSending(string transportAddress) { }
    }
    public class StartupCheckResult
    {
        public static readonly NServiceBus.Transport.StartupCheckResult Success;
        public string ErrorMessage { get; }
        public bool Succeeded { get; }
        public static NServiceBus.Transport.StartupCheckResult Failed(string errorMessage) { }
    }
    public abstract class TransportDefinition
    {
        protected TransportDefinition() { }
        public abstract string ExampleConnectionStringForErrorMessage { get; }
        public virtual bool RequiresConnectionString { get; }
        public abstract NServiceBus.Transport.TransportInfrastructure Initialize(NServiceBus.Settings.SettingsHolder settings, string connectionString);
    }
    public abstract class TransportInfrastructure
    {
        protected TransportInfrastructure() { }
        public abstract System.Collections.Generic.IEnumerable<System.Type> DeliveryConstraints { get; }
        public abstract NServiceBus.Transport.OutboundRoutingPolicy OutboundRoutingPolicy { get; }
        [System.ObsoleteAttribute("The outbox consent is no longer required. It is safe to ignore this property. The" +
            " member currently throws a NotImplementedException. Will be removed in version 8" +
            ".0.0.", true)]
        public bool RequireOutboxConsent { get; set; }
        public abstract NServiceBus.TransportTransactionMode TransactionMode { get; }
        public abstract NServiceBus.Routing.EndpointInstance BindToLocalEndpoint(NServiceBus.Routing.EndpointInstance instance);
        public abstract NServiceBus.Transport.TransportReceiveInfrastructure ConfigureReceiveInfrastructure();
        public abstract NServiceBus.Transport.TransportSendInfrastructure ConfigureSendInfrastructure();
        public abstract NServiceBus.Transport.TransportSubscriptionInfrastructure ConfigureSubscriptionInfrastructure();
        public virtual string MakeCanonicalForm(string transportAddress) { }
        public virtual System.Threading.Tasks.Task Start() { }
        public virtual System.Threading.Tasks.Task Stop() { }
        public abstract string ToTransportAddress(NServiceBus.LogicalAddress logicalAddress);
    }
    public class TransportOperation
    {
        public TransportOperation(NServiceBus.Transport.OutgoingMessage message, NServiceBus.Routing.AddressTag addressTag, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public NServiceBus.Routing.AddressTag AddressTag { get; }
        public System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; set; }
    }
    public class TransportOperations
    {
        public TransportOperations(params NServiceBus.Transport.TransportOperation[] transportOperations) { }
        public System.Collections.Generic.List<NServiceBus.Transport.MulticastTransportOperation> MulticastTransportOperations { get; }
        public System.Collections.Generic.List<NServiceBus.Transport.UnicastTransportOperation> UnicastTransportOperations { get; }
    }
    public class TransportReceiveInfrastructure
    {
        public TransportReceiveInfrastructure(System.Func<NServiceBus.Transport.IPushMessages> messagePumpFactory, System.Func<NServiceBus.Transport.ICreateQueues> queueCreatorFactory, System.Func<System.Threading.Tasks.Task<NServiceBus.Transport.StartupCheckResult>> preStartupCheck) { }
        public System.Func<NServiceBus.Transport.IPushMessages> MessagePumpFactory { get; }
        public System.Func<NServiceBus.Transport.ICreateQueues> QueueCreatorFactory { get; }
    }
    public class TransportSendInfrastructure
    {
        public TransportSendInfrastructure(System.Func<NServiceBus.Transport.IDispatchMessages> dispatcherFactory, System.Func<System.Threading.Tasks.Task<NServiceBus.Transport.StartupCheckResult>> preStartupCheck) { }
        public System.Func<NServiceBus.Transport.IDispatchMessages> DispatcherFactory { get; }
    }
    public class TransportSubscriptionInfrastructure
    {
        public TransportSubscriptionInfrastructure(System.Func<NServiceBus.Transport.IManageSubscriptions> subscriptionManagerFactory) { }
    }
    public sealed class TransportTransaction : NServiceBus.Extensibility.ContextBag
    {
        public TransportTransaction() { }
    }
    public class UnicastTransportOperation : NServiceBus.Transport.IOutgoingTransportOperation
    {
        public UnicastTransportOperation(NServiceBus.Transport.OutgoingMessage message, string destination, NServiceBus.Transport.DispatchConsistency requiredDispatchConsistency = 1, System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> deliveryConstraints = null) { }
        public System.Collections.Generic.List<NServiceBus.DeliveryConstraints.DeliveryConstraint> DeliveryConstraints { get; }
        public string Destination { get; }
        public NServiceBus.Transport.OutgoingMessage Message { get; }
        public NServiceBus.Transport.DispatchConsistency RequiredDispatchConsistency { get; }
    }
}
namespace NServiceBus.Unicast
{
    public class static BuilderExtensions
    {
        public static void ForEach<T>(this NServiceBus.ObjectBuilder.IBuilder builder, System.Action<T> action) { }
    }
    public class MessageEventArgs : System.EventArgs
    {
        public MessageEventArgs(object msg) { }
        public object Message { get; }
    }
    public class MessageHandlerRegistry
    {
        public MessageHandlerRegistry() { }
        public void Clear() { }
        public System.Collections.Generic.List<NServiceBus.Pipeline.MessageHandler> GetHandlersFor(System.Type messageType) { }
        public System.Collections.Generic.IEnumerable<System.Type> GetMessageTypes() { }
        public void RegisterHandler(System.Type handlerType) { }
    }
    public class MessagesEventArgs : System.EventArgs
    {
        public MessagesEventArgs(object[] messages) { }
        public object[] Messages { get; }
    }
}
namespace NServiceBus.Unicast.Messages
{
    public class MessageMetadata
    {
        public MessageMetadata(System.Type messageType) { }
        public MessageMetadata(System.Type messageType, System.Type[] messageHierarchy) { }
        public System.Type[] MessageHierarchy { get; }
        public System.Type MessageType { get; }
    }
    public class MessageMetadataRegistry
    {
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(System.Type messageType) { }
        public NServiceBus.Unicast.Messages.MessageMetadata GetMessageMetadata(string messageTypeIdentifier) { }
    }
}
namespace NServiceBus.Unicast.Queuing
{
    public class QueueNotFoundException : System.Exception
    {
        public QueueNotFoundException() { }
        public QueueNotFoundException(string queue, string message, System.Exception inner) { }
        protected QueueNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public string Queue { get; set; }
        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
    }
}
namespace NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions
{
    public interface IInitializableSubscriptionStorage : NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.ISubscriptionStorage
    {
        void Init();
    }
    public interface ISubscriptionStorage
    {
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber>> GetSubscriberAddressesForMessage(System.Collections.Generic.IEnumerable<NServiceBus.Unicast.Subscriptions.MessageType> messageTypes, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Subscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, NServiceBus.Unicast.Subscriptions.MessageType messageType, NServiceBus.Extensibility.ContextBag context);
        System.Threading.Tasks.Task Unsubscribe(NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber subscriber, NServiceBus.Unicast.Subscriptions.MessageType messageType, NServiceBus.Extensibility.ContextBag context);
    }
    public class Subscriber
    {
        public Subscriber(string transportAddress, string endpoint) { }
        public string Endpoint { get; }
        public string TransportAddress { get; }
    }
}
namespace NServiceBus.Unicast.Subscriptions
{
    public class MessageType
    {
        public MessageType(System.Type type) { }
        public MessageType(string messageTypeString) { }
        public MessageType(string typeName, string versionString) { }
        public MessageType(string typeName, System.Version version) { }
        public string TypeName { get; }
        public System.Version Version { get; }
        public bool Equals(NServiceBus.Unicast.Subscriptions.MessageType other) { }
        public override bool Equals(object obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
        public static bool ==(NServiceBus.Unicast.Subscriptions.MessageType left, NServiceBus.Unicast.Subscriptions.MessageType right) { }
        public static bool !=(NServiceBus.Unicast.Subscriptions.MessageType left, NServiceBus.Unicast.Subscriptions.MessageType right) { }
    }
}
namespace NServiceBus.Unicast.Transport
{
    public class static ControlMessageFactory
    {
        public static NServiceBus.Transport.OutgoingMessage Create(NServiceBus.MessageIntentEnum intent) { }
    }
}
namespace NServiceBus.UnitOfWork
{
    public interface IManageUnitsOfWork
    {
        System.Threading.Tasks.Task Begin();
        System.Threading.Tasks.Task End(System.Exception ex = null);
    }
}