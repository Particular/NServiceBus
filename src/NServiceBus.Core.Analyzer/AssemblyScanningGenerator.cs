#nullable enable
namespace NServiceBus.Core.Analyzer;

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;

[Generator]
public sealed class AssemblyScanningGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var markerAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName(MarkerAttributeName,
                predicate: static (_, _) => true,
                transform: static (syntaxContext, token) =>
                {
                    var attributeInfo = syntaxContext.Attributes.First();
                    if (attributeInfo.ConstructorArguments[0].Value is bool includeOptionalRegistrations)
                    {
                        return new PutItHere(includeOptionalRegistrations);
                    }

                    return default;
                })
            .Where(x => x != default);

        var registrationTypes = context.CompilationProvider.SelectMany((compilation, cancellationToken) =>
        {
            var attributeType = compilation.GetTypeByMetadataName(MarkerAttributeName);
            if (attributeType is null)
            {
                return [];
            }

            return GetAutoGeneratedRegistrationTypes(compilation.GlobalNamespace, attributeType, cancellationToken);
        });

        var collectedMarkerAttribute = markerAttribute.Collect();
        var collectedRegistrationTypes = registrationTypes.Collect();

        var allTypes = collectedRegistrationTypes.Combine(collectedMarkerAttribute)
            .Select((tuple, ct) =>
            {
                var (regClasses, flags) = tuple;

                var firstFlag = flags.FirstOrDefault();
                if (firstFlag == default)
                {
                    return default;
                }

                return RegistrationMethodsByConvention.Concat(regClasses)
                    .Where(x => x.AutoRegister || (firstFlag.IncludeNonAutoRegister ?? false))
                    .Distinct()
                    .ToImmutableArray();

                return default;
            });

        context.RegisterSourceOutput(allTypes, GenerateRegistrationCode);
    }

    static readonly ImmutableArray<AutoGeneratedMethod> RegistrationMethodsByConvention =
    [
        new("NServiceBus.Generated.RequiredTypeRegistration", true),
        new("NServiceBus.Generated.OptionalTypeRegistration", false)
    ];

    static IEnumerable<AutoGeneratedMethod> GetAutoGeneratedRegistrationTypes(INamespaceSymbol ns, INamedTypeSymbol attributeType, CancellationToken cancellationToken)
    {
        // Walk all types in this namespace and its children looking for [NServiceBusExtensionPoint]
        foreach (var type in ns.GetTypeMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            var markerAttribute = type.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));

            if (markerAttribute is not null && markerAttribute.ConstructorArguments[1].Value is bool autoRegister)
            {
                yield return new AutoGeneratedMethod(type.ToDisplayString(), autoRegister);
            }

            // Recursively search nested types
            foreach (var nested in GetNestedTypesWithAttribute(type, attributeType, cancellationToken))
            {
                yield return nested;
            }
        }

        // Recursively search child namespaces
        foreach (var childNamespace in ns.GetNamespaceMembers())
        {
            foreach (var markerType in GetAutoGeneratedRegistrationTypes(childNamespace, attributeType, cancellationToken))
            {
                yield return markerType;
            }
        }
    }

    static IEnumerable<AutoGeneratedMethod> GetNestedTypesWithAttribute(INamedTypeSymbol type, INamedTypeSymbol attributeType, CancellationToken cancellationToken)
    {
        foreach (var nested in type.GetTypeMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            var markerAttribute = nested.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));

            if (markerAttribute is not null && markerAttribute.ConstructorArguments[1].Value is bool autoRegister)
            {
                yield return new AutoGeneratedMethod(nested.ToDisplayString(), autoRegister);
            }

            // Recursively search deeper nested types
            foreach (var deeperNested in GetNestedTypesWithAttribute(nested, attributeType, cancellationToken))
            {
                yield return deeperNested;
            }
        }
    }

    static void GenerateRegistrationCode(SourceProductionContext sourceProductionContext, ImmutableArray<AutoGeneratedMethod> matches)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      // <auto-generated/>
                      #nullable enable
                      namespace NServiceBus
                      {
                          public static class SourceGeneratedAssemblyScanningExtensions
                          {
                              public static void UseSourceGeneratedAssemblyScanning(NServiceBus.EndpointConfiguration endpointConfiguration)
                              {
                      """);

        foreach (var match in matches)
        {
            sb.AppendLine($"            {match.ClassName}.RegisterTypes(endpointConfiguration);");
        }

        sb.AppendLine("""
                              }
                          }
                      }
                      """);

        sourceProductionContext.AddSource("ScanningResult.g.cs", sb.ToString());
    }


    public record struct PutItHere(bool? IncludeNonAutoRegister);

    public record struct AutoGeneratedMethod(string ClassName, bool AutoRegister);

    const string MarkerAttributeName = "NServiceBus.Extensibility.SourceGeneratedAssemblyScanningAttribute";
}