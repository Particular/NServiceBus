#nullable enable
namespace NServiceBus.Core.Analyzer;

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;

[Generator]
public sealed class AssemblyScanningGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var markerAttribute = context.SyntaxProvider
            .ForAttributeWithMetadataName(MarkerAttributeName,
                predicate: static (_, _) => true,
                transform: static (syntaxContext, token) =>
                {
                    var attributeInfo = syntaxContext.Attributes.First();
                    if (attributeInfo.ConstructorArguments[0].Value is bool includeOptionalRegistrations)
                    {
                        return new PutItHere(includeOptionalRegistrations);
                    }

                    return default;
                })
            .Where(x => x != default);

        var registrationTypes = context.CompilationProvider.SelectMany((compilation, cancellationToken) =>
        {
            var attributeType = compilation.GetTypeByMetadataName(MarkerAttributeName);
            if (attributeType is null)
            {
                return [];
            }

            return GetAutoGeneratedRegistrationTypes(compilation.GlobalNamespace, attributeType, cancellationToken);
        });

        var collectedMarkerAttribute = markerAttribute.Collect();
        var collectedRegistrationTypes = registrationTypes.Collect();

        var allTypes = collectedRegistrationTypes.Combine(collectedMarkerAttribute)
            .Select((tuple, ct) =>
            {
                var (regClasses, flags) = tuple;

                var firstFlag = flags.FirstOrDefault();
                if (firstFlag == default)
                {
                    return default;
                }

                return RegistrationMethodsByConvention.Concat(regClasses)
                    .Where(x => x.AutoRegister || (firstFlag.IncludeNonAutoRegister ?? false))
                    .Distinct()
                    .ToImmutableArray();
            });

        // Note: We no longer generate GeneratedRegistrationExtensions here
        // The KnownTypesGenerator now handles generating both the registration classes
        // and the extension methods, since it has visibility into the endpoint partitions
        // context.RegisterSourceOutput(allTypes, GenerateRegistrationCode);
    }

    static readonly ImmutableArray<AutoGeneratedMethod> RegistrationMethodsByConvention =
    [
        new("NServiceBus.Generated.RequiredTypeRegistration", true)
        // Note: We don't include OptionalTypeRegistration here by default for backward compatibility
        // OptionalTypeRegistration is only used when calling UseGeneratedRegistrations() without endpoint suffix
    ];

    static IEnumerable<AutoGeneratedMethod> GetAutoGeneratedRegistrationTypes(INamespaceSymbol ns, INamedTypeSymbol attributeType, CancellationToken cancellationToken)
    {
        // Walk all types in this namespace and its children looking for [NServiceBusExtensionPoint]
        foreach (var type in ns.GetTypeMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            var markerAttribute = type.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));

            if (markerAttribute is not null && markerAttribute.ConstructorArguments[1].Value is bool autoRegister)
            {
                yield return new AutoGeneratedMethod(type.ToDisplayString(), autoRegister);
            }

            // Recursively search nested types
            foreach (var nested in GetNestedTypesWithAttribute(type, attributeType, cancellationToken))
            {
                yield return nested;
            }
        }

        // Recursively search child namespaces
        foreach (var childNamespace in ns.GetNamespaceMembers())
        {
            foreach (var markerType in GetAutoGeneratedRegistrationTypes(childNamespace, attributeType, cancellationToken))
            {
                yield return markerType;
            }
        }
    }

    static IEnumerable<AutoGeneratedMethod> GetNestedTypesWithAttribute(INamedTypeSymbol type, INamedTypeSymbol attributeType, CancellationToken cancellationToken)
    {
        foreach (var nested in type.GetTypeMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            var markerAttribute = nested.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));

            if (markerAttribute is not null && markerAttribute.ConstructorArguments[1].Value is bool autoRegister)
            {
                yield return new AutoGeneratedMethod(nested.ToDisplayString(), autoRegister);
            }

            // Recursively search deeper nested types
            foreach (var deeperNested in GetNestedTypesWithAttribute(nested, attributeType, cancellationToken))
            {
                yield return deeperNested;
            }
        }
    }

    // Note: This method is currently unused because KnownTypesGenerator now handles
    // generating the extension methods. This code is kept for reference in case we need
    // to restore the dual-generator approach in the future.
    //
    // static void GenerateRegistrationCode(SourceProductionContext sourceProductionContext, ImmutableArray<AutoGeneratedMethod> matches)
    // {
    //     ... implementation commented out ...
    // }


    public record struct PutItHere(bool? IncludeNonAutoRegister);

    public record struct AutoGeneratedMethod(string ClassName, bool AutoRegister);

    const string MarkerAttributeName = "NServiceBus.Extensibility.SourceGeneratedAssemblyScanningAttribute";
}