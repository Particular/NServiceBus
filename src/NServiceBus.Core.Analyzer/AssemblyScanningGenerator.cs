#nullable enable
namespace NServiceBus.Core.Analyzer;

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;

[Generator]
public sealed class AssemblyScanningGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var locations = context.SyntaxProvider
            .CreateSyntaxProvider(SyntaxLooksLikeUseSourceGenerationMethod, TransformToInterceptor)
            .Where(candidate => candidate is not null);

        var registrationTypes = context.CompilationProvider.SelectMany((compilation, cancellationToken) =>
        {
            var attributeType = compilation.GetTypeByMetadataName(MarkerAttributeName);
            if (attributeType is null)
            {
                return [];
            }

            return GetAutoGeneratedRegistrationTypes(compilation.GlobalNamespace, attributeType, cancellationToken);
        });

        var collectedRegistrationTypes = registrationTypes.Collect();
        var collectedInterceptorLocations = locations.Collect();

        var allTypesAsInterceptor = collectedRegistrationTypes.Combine(collectedInterceptorLocations)
            .Select((tuple, ct) =>
            {
                var (regClasses, interceptorLocations) = tuple;

                if (!interceptorLocations.Any())
                {
                    return default;
                }

                var methods = RegistrationMethodsByConvention.Concat(regClasses)
                    .Distinct()
                    .ToImmutableArray();

                return new InterceptorsAndRegistrationClasses(methods, interceptorLocations);
            });

        context.RegisterSourceOutput(allTypesAsInterceptor, GenerateInterceptorCode);
    }

    record struct InterceptorsAndRegistrationClasses(ImmutableArray<AutoGeneratedMethod> Methods, ImmutableArray<CandidateInvocation?> Locations);

    static bool SyntaxLooksLikeUseSourceGenerationMethod(SyntaxNode node, CancellationToken cancellationToken) =>
        // Needs to be a "method call" with the correct name
        node is InvocationExpressionSyntax { Expression: MemberAccessExpressionSyntax { Name.Identifier.ValueText: UseSourceGenMethodName } };

    const string UseSourceGenExtensionClassName = "SourceGenerationAssemblyScanningExtensions";
    const string UseSourceGenMethodName = "TurnOffAssemblyScanningAndUseSourceGenerationInstead";
    static CandidateInvocation? TransformToInterceptor(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        // Must be due to the predicate, do we need to play it safe here?
        if (context.Node is not InvocationExpressionSyntax { Expression: MemberAccessExpressionSyntax } invocation)
        {
            return null;
        }

        // Get the semantic model
        if (context.SemanticModel.GetOperation(invocation, cancellationToken) is not IInvocationOperation operation)
        {
            return null;
        }

        // Make sure the method we're looking at is ours and not some (extremely unlikely) copycat
        if (operation.TargetMethod is not { Name: UseSourceGenMethodName, ContainingType: { Name: UseSourceGenExtensionClassName, ContainingNamespace: { Name: "NServiceBus", ContainingNamespace.IsGlobalNamespace: true } } })
        {
            return null;
        }

        // We want to intercept this, so get the interceptable location and make sure it's non-null which would mean it's not interceptable for some reason
        if (context.SemanticModel.GetInterceptableLocation(invocation, cancellationToken) is not { } location)
        {
            return null;
        }

        return new CandidateInvocation(location);
    }

    record struct CandidateInvocation(InterceptableLocation Location);


    static readonly ImmutableArray<AutoGeneratedMethod> RegistrationMethodsByConvention =
    [
        new("NServiceBus.Generated.RequiredTypeRegistration", true),
        new("NServiceBus.Generated.OptionalTypeRegistration", false)
    ];

    static IEnumerable<AutoGeneratedMethod> GetAutoGeneratedRegistrationTypes(INamespaceSymbol ns, INamedTypeSymbol attributeType, CancellationToken cancellationToken)
    {
        // Walk all types in this namespace and its children looking for [NServiceBusExtensionPoint]
        foreach (var type in ns.GetTypeMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            var markerAttribute = type.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));

            if (markerAttribute is not null && markerAttribute.ConstructorArguments[1].Value is bool autoRegister)
            {
                yield return new AutoGeneratedMethod(type.ToDisplayString(), autoRegister);
            }

            // Recursively search nested types
            foreach (var nested in GetNestedTypesWithAttribute(type, attributeType, cancellationToken))
            {
                yield return nested;
            }
        }

        // Recursively search child namespaces
        foreach (var childNamespace in ns.GetNamespaceMembers())
        {
            foreach (var markerType in GetAutoGeneratedRegistrationTypes(childNamespace, attributeType, cancellationToken))
            {
                yield return markerType;
            }
        }
    }

    static IEnumerable<AutoGeneratedMethod> GetNestedTypesWithAttribute(INamedTypeSymbol type, INamedTypeSymbol attributeType, CancellationToken cancellationToken)
    {
        foreach (var nested in type.GetTypeMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            var markerAttribute = nested.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));

            if (markerAttribute is not null && markerAttribute.ConstructorArguments[1].Value is bool autoRegister)
            {
                yield return new AutoGeneratedMethod(nested.ToDisplayString(), autoRegister);
            }

            // Recursively search deeper nested types
            foreach (var deeperNested in GetNestedTypesWithAttribute(nested, attributeType, cancellationToken))
            {
                yield return deeperNested;
            }
        }
    }

    static void GenerateInterceptorCode(SourceProductionContext sourceProductionContext, InterceptorsAndRegistrationClasses data)
    {
        var (methods, locations) = data;

        var sb = new StringBuilder();
        sb.AppendLine("""
                      // <auto-generated/>
                      #nullable enable
                      
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.Diagnostics.Conditional("DEBUG")]
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          sealed file class InterceptsLocationAttribute : global::System.Attribute
                          {
                              public InterceptsLocationAttribute(int version, string data)
                              {
                                  _ = version;
                                  _ = data;
                              }
                          }
                      }
                      
                      namespace NServiceBus
                      {
                          static file class SourceGeneratedAssemblyScanningInterceptors
                          {
                      """);

        foreach (var location in locations)
        {
            if (location.HasValue)
            {
                sb.AppendLine($"""        [global::System.Runtime.CompilerServices.InterceptsLocation({location.Value.Location.Version}, "{location.Value.Location.Data}")] // {location.Value.Location.GetDisplayLocation()}""");
            }
        }

        sb.AppendLine("""
                              public static void UseSourceGeneratedAssemblyScanning(NServiceBus.EndpointConfiguration endpointConfiguration)
                              {
                      """);

        foreach (var method in methods)
        {
            sb.AppendLine($"            {method.ClassName}.RegisterTypes(endpointConfiguration);");
        }

        sb.AppendLine("""
                              }
                          }
                      }
                      """);

        sourceProductionContext.AddSource("Interception.g.cs", sb.ToString());
    }

    public record struct AutoGeneratedMethod(string ClassName, bool AutoRegister);

    const string MarkerAttributeName = "NServiceBus.Extensibility.SourceGeneratedAssemblyScanningAttribute";
}