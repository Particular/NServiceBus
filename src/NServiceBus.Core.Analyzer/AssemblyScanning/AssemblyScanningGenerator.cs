#nullable enable
namespace NServiceBus.Core.SourceGen;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;

[Generator]
public sealed class AssemblyScanningGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodsToIntercept = context.SyntaxProvider
            .CreateSyntaxProvider(SyntaxLooksLikeUseSourceGenerationMethod, TransformToInterceptor)
            .Where(candidate => candidate is not null);

        var decoratedRegistrationTypesFromCompilation = context.CompilationProvider.SelectMany((compilation, cancellationToken) =>
        {
            var attributeType = compilation.GetTypeByMetadataName(MarkerAttributeName);
            if (attributeType is null)
            {
                throw new InvalidOperationException($"Can not resolve {MarkerAttributeName} which should exist in NServiceBus.Core.");
            }

            return GetAutoGeneratedRegistrationTypes(compilation.GlobalNamespace, attributeType, cancellationToken);
        });

        var collectedRegistrationTypes = decoratedRegistrationTypesFromCompilation.Collect();
        var collectedInterceptorLocations = methodsToIntercept.Collect();

        var currentAssemblyRegistrationTypeByConvention = context.CompilationProvider
            .Select((compilation, _) => CompilationAssemblyDetails.FromAssembly(compilation.Assembly))
            .Select((assemblyInfo, _) => assemblyInfo.ToGenerationClassName())
            .Select((className, _) => new GeneratedRegistrationClass($"NServiceBus.Generated.{className}"));

        var allTypesAsInterceptor = collectedRegistrationTypes
            .Combine(collectedInterceptorLocations)
            .Combine(currentAssemblyRegistrationTypeByConvention)
            .Select((tuple, ct) =>
            {
                var ((regClasses, interceptorLocations), currentAssemblyClassName) = tuple;

                if (!interceptorLocations.Any())
                {
                    // Don't need to generate any code without any method to intercept
                    return default;
                }

                // Combine the registration methods that we know by convention will be created by KnownTypesGenerator
                // in the current project with the registration classes discovered elsewhere in the compilation
                var methods = regClasses.Concat([currentAssemblyClassName])
                    .Distinct()
                    .ToImmutableArray();

                return new InterceptorsAndRegistrationClasses(methods, interceptorLocations);
            });

        context.RegisterSourceOutput(allTypesAsInterceptor, GenerateInterceptorCode);
    }

    static bool SyntaxLooksLikeUseSourceGenerationMethod(SyntaxNode node, CancellationToken cancellationToken) =>
        // Needs to be a "method call" with the correct name
        node is InvocationExpressionSyntax { Expression: MemberAccessExpressionSyntax { Name.Identifier.ValueText: UseSourceGenMethodName or RegisterHandlersMethodName } };

    static InterceptDetails? TransformToInterceptor(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        // Must be due to the predicate, do we need to play it safe here?
        if (context.Node is not InvocationExpressionSyntax { Expression: MemberAccessExpressionSyntax } invocation)
        {
            return null;
        }

        // Get the semantic model
        if (context.SemanticModel.GetOperation(invocation, cancellationToken) is not IInvocationOperation operation)
        {
            return null;
        }

        // Make sure the method we're looking at is ours and not some (extremely unlikely) copycat
        if (operation.TargetMethod is not { Name: UseSourceGenMethodName or RegisterHandlersMethodName, ContainingType: { Name: UseSourceGenExtensionClassName, ContainingNamespace: { Name: "NServiceBus", ContainingNamespace.IsGlobalNamespace: true } } })
        {
            return null;
        }

        // We want to intercept this, so get the interceptable location and make sure it's non-null which would mean it's not interceptable for some reason
        if (context.SemanticModel.GetInterceptableLocation(invocation, cancellationToken) is not { } location)
        {
            return null;
        }

        return new InterceptDetails(operation.TargetMethod.Name, location);
    }

    static IEnumerable<GeneratedRegistrationClass> GetAutoGeneratedRegistrationTypes(INamespaceSymbol ns, INamedTypeSymbol attributeType, CancellationToken cancellationToken)
    {
        // Walk all types in this namespace and its children looking for [NServiceBusExtensionPoint]
        foreach (var type in ns.GetTypeMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            var markerAttribute = type.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));

            if (markerAttribute is not null)
            {
                yield return new GeneratedRegistrationClass(type.ToDisplayString());
            }

            // Recursively search nested types
            foreach (var nested in GetNestedTypesWithAttribute(type, attributeType, cancellationToken))
            {
                yield return nested;
            }
        }

        // Recursively search child namespaces
        foreach (var childNamespace in ns.GetNamespaceMembers())
        {
            foreach (var markerType in GetAutoGeneratedRegistrationTypes(childNamespace, attributeType, cancellationToken))
            {
                yield return markerType;
            }
        }
    }

    static IEnumerable<GeneratedRegistrationClass> GetNestedTypesWithAttribute(INamedTypeSymbol type, INamedTypeSymbol attributeType, CancellationToken cancellationToken)
    {
        foreach (var nested in type.GetTypeMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            var markerAttribute = nested.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));

            if (markerAttribute is not null)
            {
                yield return new GeneratedRegistrationClass(nested.ToDisplayString());
            }

            // Recursively search deeper nested types
            foreach (var deeperNested in GetNestedTypesWithAttribute(nested, attributeType, cancellationToken))
            {
                yield return deeperNested;
            }
        }
    }

    static void GenerateInterceptorCode(SourceProductionContext sourceProductionContext, InterceptorsAndRegistrationClasses data)
    {
        if (data == default)
        {
            return;
        }

        var (regClasses, interceptLocations) = data;

        var locationsByMethodName = interceptLocations.ToLookup(location => location!.Value.MethodName);

        var sb = new StringBuilder();
        sb.AppendLine("""
                      // <auto-generated/>
                      #nullable enable
                      
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.Diagnostics.Conditional("DEBUG")]
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          sealed file class InterceptsLocationAttribute : global::System.Attribute
                          {
                              public InterceptsLocationAttribute(int version, string data)
                              {
                                  _ = version;
                                  _ = data;
                              }
                          }
                      }
                      
                      namespace NServiceBus
                      {
                          static file class SourceGeneratedAssemblyScanningInterceptors
                          {
                      """);

        var useSourceGenMethods = locationsByMethodName[UseSourceGenMethodName].OfType<InterceptDetails>().ToImmutableArray();
        var registerHandlersMethods = locationsByMethodName[RegisterHandlersMethodName].OfType<InterceptDetails>().ToImmutableArray();

        if (useSourceGenMethods.Any())
        {
            foreach (var location in useSourceGenMethods)
            {
                sb.AppendLine($"""        [global::System.Runtime.CompilerServices.InterceptsLocation({location.Location.Version}, "{location.Location.Data}")] // {location.Location.GetDisplayLocation()}""");
            }

            sb.AppendLine($$"""
                                    public static void {{UseSourceGenMethodName}}(NServiceBus.EndpointConfiguration endpointConfiguration)
                                    {
                            """);

            foreach (var method in regClasses)
            {
                sb.AppendLine($"            {method.FullClassName}.RegisterRequiredTypes(endpointConfiguration);");
            }

            sb.AppendLine("        }");
        }

        if (registerHandlersMethods.Any())
        {
            foreach (var location in registerHandlersMethods)
            {
                sb.AppendLine($"""        [global::System.Runtime.CompilerServices.InterceptsLocation({location.Location.Version}, "{location.Location.Data}")] // {location.Location.GetDisplayLocation()}""");
            }

            sb.AppendLine($$"""
                                  public static void {{RegisterHandlersMethodName}}(NServiceBus.SourceGenerationTypeDiscoveryOptions options)
                                  {
                          """);

            foreach (var method in regClasses)
            {
                sb.AppendLine($"            {method.FullClassName}.RegisterOptionalTypes(options.Configuration);");
            }

            sb.AppendLine("        }");
        }

        sb.AppendLine("""
                          }
                      }
                      """);

        sourceProductionContext.AddSource("Interception.g.cs", sb.ToString());
    }

    record struct GeneratedRegistrationClass(string FullClassName);
    record struct InterceptDetails(string MethodName, InterceptableLocation Location);
    record struct InterceptorsAndRegistrationClasses(ImmutableArray<GeneratedRegistrationClass> Methods, ImmutableArray<InterceptDetails?> Locations);

    const string MarkerAttributeName = "NServiceBus.Extensibility.AutoGeneratedTypeRegistrationsAttribute";
    const string UseSourceGenExtensionClassName = "SourceGenerationAssemblyScanningExtensions";
    const string UseSourceGenMethodName = "UseSourceGeneratedTypeDiscovery";
    const string RegisterHandlersMethodName = "RegisterHandlersAndSagas";

}