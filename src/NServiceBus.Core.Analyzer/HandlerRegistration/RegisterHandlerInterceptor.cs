namespace NServiceBus.Core.Analyzer.HandlerRegistration;

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;

[Generator]
public class RegisterHandlerInterceptor : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var locations = context.SyntaxProvider
            .CreateSyntaxProvider(SyntaxLooksLikeRegisterHandlerMethod, TransformToInterceptor)
            .WithTrackingName("AfterSyntax")
            .Where(candidate => candidate is not null)
            //.WithTrackingName("InterceptLocations")
            ;

        var collected = locations.Collect()
            .WithTrackingName("Collected");

        context.RegisterSourceOutput(collected, GenerateInterceptorCode);
    }

    static bool SyntaxLooksLikeRegisterHandlerMethod(SyntaxNode node, CancellationToken cancellationToken) =>
        node is InvocationExpressionSyntax { Expression: MemberAccessExpressionSyntax { Name.Identifier.ValueText: RegisterHandlerMethodName } };

    static InterceptDetails? TransformToInterceptor(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        // Must be due to the predicate, do we need to play it safe here?
        if (context.Node is not InvocationExpressionSyntax { Expression: MemberAccessExpressionSyntax } invocation)
        {
            return null;
        }

        // Get the semantic model
        if (context.SemanticModel.GetOperation(invocation, cancellationToken) is not IInvocationOperation operation)
        {
            return null;
        }

        // Make sure the method we're looking at is ours and not some (extremely unlikely) copycat
        if (!IsRegisterHandlerMethod(operation.TargetMethod))
        {
            return null;
        }

        if (operation.TargetMethod.TypeArguments[0] is not INamedTypeSymbol handlerType)
        {
            return null;
        }

        var messageTypes = handlerType.AllInterfaces
            .Where(IsHandlerInterface)
            .Select(type => type.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
            .ToImmutableArray();

        if (context.SemanticModel.GetInterceptableLocation(invocation, cancellationToken) is not { } location)
        {
            return null;
        }

        var methodName = $"RegisterHandler_{handlerType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat).Replace('.', '_')}_{location.Data.Replace('/', '_')}";
        var handlerFullyQualifiedName = handlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return new InterceptDetails(SafeInterceptionLocation.From(location), methodName, handlerFullyQualifiedName, messageTypes);
    }

    static bool IsRegisterHandlerMethod(IMethodSymbol method) => method is
    {
        Name: RegisterHandlerMethodName,
        IsGenericMethod: true,
        TypeArguments: { Length: 1 },
        ContainingType:
        {
            Name: RegisterHandlerClassName,
            ContainingNamespace:
            {
                Name: "NServiceBus",
                ContainingNamespace.IsGlobalNamespace: true
            }
        }
    };

    static bool IsHandlerInterface(INamedTypeSymbol type) => type is
    {
        Name: "IHandleMessages" or "IHandleTimeouts",
        IsGenericType: true,
        ContainingNamespace:
        {
            Name: "NServiceBus",
            ContainingNamespace: { IsGlobalNamespace: true }
        }
    };

    static void GenerateInterceptorCode(SourceProductionContext context, ImmutableArray<InterceptDetails?> intercepts)
    {
        if (intercepts.Length == 0)
        {
            return;
        }

        var sb = new StringBuilder();
        sb.AppendLine("""
                      // <auto-generated/>
                      #nullable enable

                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.Diagnostics.Conditional("DEBUG")]
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          sealed file class InterceptsLocationAttribute : global::System.Attribute
                          {
                              public InterceptsLocationAttribute(int version, string data)
                              {
                                  _ = version;
                                  _ = data;
                              }
                          }
                      }

                      namespace NServiceBus
                      {
                          static file class InterceptionsOfRegisterHandlerMethod
                          {
                      """);

        foreach (var location in intercepts.OfType<InterceptDetails>())
        {
            sb.AppendLine($"""        [global::System.Runtime.CompilerServices.InterceptsLocation({location.Location.Version}, "{location.Location.Data}")] // {location.Location.DisplayLocation}""");
            sb.AppendLine($$"""
                                    public static void {{location.MethodName}}(NServiceBus.EndpointConfiguration endpointConfiguration)
                                    {
                                        System.ArgumentNullException.ThrowIfNull(endpointConfiguration);
                                        var registry = NServiceBus.Configuration.AdvancedExtensibility.AdvancedExtensibilityExtensions.GetSettings(endpointConfiguration)
                                            .GetOrCreate<NServiceBus.Unicast.MessageHandlerRegistry>();
                            """);
            foreach (var messageType in location.MessageTypes)
            {
                sb.AppendLine($"            registry.RegisterHandlerForMessage<{location.HandlerType}, {messageType}>();");
            }
            sb.AppendLine("        }");
        }

        sb.AppendLine("""
                          }
                      }
                      """);

        context.AddSource("InterceptionsOfRegisterHandlerMethod.g.cs", sb.ToString());
    }

    record struct InterceptDetails(SafeInterceptionLocation Location, string MethodName, string HandlerType, ImmutableArray<string> MessageTypes);

    const string RegisterHandlerClassName = "MessageHandlerRegistrationExtensions";
    const string RegisterHandlerMethodName = "RegisterHandler";

    record struct SafeInterceptionLocation(int Version, string Data, string DisplayLocation)
    {
        public static SafeInterceptionLocation From(InterceptableLocation location) =>
            new(location.Version, location.Data, location.GetDisplayLocation());
    }
}