<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.Windsor</name>
    </assembly>
    <members>
        <member name="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator">
            <summary>
            Attempts to dynamically load a UserControl by invoking Page.LoadControl.  
            There are two uses of this class.  
            <para>
            1) Add a component to the Kernel and add a VirtualPath attribute specifying 
            the relative path of the .ascx file for the associated UserControl. (easy)
            </para>
            <example>
              <code>
                &lt;component id="BasketView" 
                  service="Castle.ShoppingCart.IBasketView, Castle.ShoppingCart"
                  type="Castle.ShoppingCart.BasketView, Castle.ShoppingCart" 
                  lifestyle="transient"
                  virtualPath="~/Views/BasketView.ascx"
                /&gt;
              </code>
            </example>
            <para>
            2) Precompile a UserControl and add the pre-compiled class to the Kernel. (hard)  
            Has not been tested with proxies.
            </para>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator">
            <summary>
            Standard implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
            Handles the selection of the best constructor, fills the
            writable properties the component exposes, run the commission 
            and decommission lifecycles, etc.
            </summary>
            <remarks>
            Custom implementors can just override the <c>CreateInstance</c> method.
            Please note however that the activator is responsible for the proxy creation
            when needed.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator">
            <summary>
            Abstract implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
            The implementors must only override the InternalCreate and 
            InternalDestroy methods in order to perform their creation and
            destruction logic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentActivator">
            <summary>
            Implements the instance creation logic. The default
            implementation should rely on an ordinary call to 
            Activator.CreateInstance(). 
            </summary>
            <remarks>
            This interface is provided in order to allow custom components
            to be created using a different logic, such as using a specific factory
            or builder.
            <para>
            The constructor for implementation has the following signature:
            </para>
            <code>
            ComponentModel model, IKernel kernel, 
            ComponentInstanceDelegate onCreation, 
            ComponentInstanceDelegate onDestruction
            </code>
            <para>
            The Activator should raise the events onCreation and onDestruction
            in order to correctly implement the contract. Usually the best
            way of creating a custom activator is by extending the existing ones.
            </para>
            <seealso cref="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator"/>
            <seealso cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Create(Castle.MicroKernel.Context.CreationContext)">
            <summary>
            Should return a new component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Destroy(System.Object)">
            <summary>
            Should perform all necessary work to dispose the instance
            and/or any resource related to it.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Constructs an AbstractComponentActivator
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator"/> class.
            </summary>
            <param name="model"></param>
            <param name="kernel"></param>
            <param name="onCreation"></param>
            <param name="onDestruction"></param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The on creation.</param>
            <param name="onDestruction">The on destruction.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.CreateInstance(Castle.MicroKernel.Context.CreationContext,System.Object[],System.Type[])">
            <summary>
            Creates the instance.
            </summary>
            <param name="context">The context.</param>
            <param name="arguments">The arguments.</param>
            <param name="signature">The signature.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleManager">
            <summary>
            Implements a Lifestyle Manager for Web Apps that
            create at most one object per web request.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager">
            <summary>
            Summary description for AbstractLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ILifestyleManager">
            <summary>
            The <c>ILifestyleManager</c> implements 
            a strategy for a given lifestyle, like singleton, per-thread
            and transient.
            </summary>
            <remarks>
            The responsibility of <c>ILifestyleManager</c>
            is only the management of lifestyle. It should rely on
            <see cref="T:Castle.MicroKernel.IComponentActivator"/> to obtain a new component instance
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Initializes the <c>ILifestyleManager</c> with the 
            <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            </summary>
            <param name="componentActivator"></param>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Resolve(Castle.MicroKernel.Context.CreationContext)">
            <summary>
            Implementors should return the component instance based 
            on the lifestyle semantic.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Release(System.Object)">
            <summary>
            Implementors should release the component instance based
            on the lifestyle semantic, for example, singleton components
            should not be released on a call for release, instead they should
            release them when disposed is invoked.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="T:Castle.Core.CastleComponentAttribute">
            <summary>
            This attribute is useful only when you want to register all components
            on an assembly as a batch process. 
            By doing so, the batch register will look 
            for this attribute to distinguish components from other classes.
            </summary>
        </member>
        <member name="T:Castle.Core.LifestyleAttribute">
            <summary>
            Base for Attributes that want to express lifestyle
            chosen by the component.
            </summary>
        </member>
        <member name="M:Castle.Core.LifestyleAttribute.#ctor(Castle.Core.LifestyleType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifestyleAttribute"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="P:Castle.Core.LifestyleAttribute.Lifestyle">
            <summary>
            Gets or sets the lifestyle.
            </summary>
            <value>The lifestyle.</value>
        </member>
        <member name="T:Castle.Core.ComponentActivatorAttribute">
            <summary>
            Associates a custom component with a component
            </summary>
        </member>
        <member name="M:Castle.Core.ComponentActivatorAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentActivatorAttribute"/> class.
            </summary>
            <param name="componentActivatorType">Type of the component activator.</param>
        </member>
        <member name="P:Castle.Core.ComponentActivatorAttribute.ComponentActivatorType">
            <summary>
            Gets the type of the component activator.
            </summary>
            <value>The type of the component activator.</value>
        </member>
        <member name="T:Castle.Core.ComponentProxyBehaviorAttribute">
            <summary>
            Specifies the proxying behavior for a component.
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseMarshalByRefProxy">
            <summary>
            Gets or sets a value indicating whether the generated 
            interface proxy should inherit from <see cref="T:System.MarshalByRefObject"/>.
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseSingleInterfaceProxy">
            <summary>
            Determines if the component requires a single interface proxy.
            </summary>
            <value><c>true</c> if the component requires a single interface proxy.</value>
        </member>
        <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.AdditionalInterfaces">
            <summary>
             Gets or sets the additional interfaces used during proxy generation.
            </summary>
        </member>
        <member name="T:Castle.Core.DoNotWireAttribute">
            <summary>
            Marks as property to be skipped and not be wired
            by the IoC container
            </summary>
        </member>
        <member name="T:Castle.Core.ILifecycleConcern">
            <summary>
            Represents a concern that will be applied to a component instance
            during commission or decommission phase. 
            </summary>
        </member>
        <member name="M:Castle.Core.ILifecycleConcern.Apply(Castle.Core.ComponentModel,System.Object)">
            <summary>
            Implementors should act on the instance in response to 
            a decommission or commission phase. 
            </summary>
            <param name="model">The model.</param>
            <param name="component">The component.</param>
        </member>
        <member name="T:Castle.Core.IInitializable">
            <summary>
            Lifecycle interface. If implemented by a component,
            the method Initialized will be invoked by the container
            before making the component available to the external world.
            </summary>
        </member>
        <member name="M:Castle.Core.IInitializable.Initialize">
            <summary>
            Implementors should perform any initialization logic.
            </summary>
        </member>
        <member name="T:Castle.Core.InterceptorAttribute">
            <summary>
              Used to declare that a component wants interceptors acting on it.
            </summary>
        </member>
        <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.String)">
            <summary>
              Constructs the InterceptorAttribute pointing to
              a key to a interceptor
            </summary>
            <param name = "componentKey"></param>
        </member>
        <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.Type)">
            <summary>
              Constructs the InterceptorAttribute pointing to
              a service
            </summary>
            <param name = "interceptorType"></param>
        </member>
        <member name="T:Castle.Core.Internal.LateBoundComponent">
            <summary>
            Marker class used to denote components that have late bound type
            That is the actual type is not known exactly at the time when <see cref="T:Castle.Core.ComponentModel"/>
            is created. Those are for example components instantiated via abstract factory.
            </summary>
        </member>
        <member name="M:Castle.Core.Internal.ReflectionUtil.GetCompatibleArrayItemType(System.Type)">
            <summary>
            If the extended type is a Foo[] or IEnumerable{Foo} which is assignable from Foo[] this method will return typeof(Foo)
            otherwise <c>null</c>.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.SingletonAttribute">
            <summary>
            Indicates that the target components wants a
            singleton lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.SingletonAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.SingletonAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.TransientAttribute">
            <summary>
            Indicates that the target components wants a
            transient lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.TransientAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.TransientAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.PerThreadAttribute">
            <summary>
            Indicates that the target components wants a
            per thread lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.PerThreadAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.PerWebRequestAttribute">
            <summary>
            Indicates that the target components wants a
            per web request lifestyle.
            </summary>
        </member>
        <member name="T:Castle.Core.PooledAttribute">
            <summary>
            Indicates that the target components wants a
            pooled lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.PooledAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute"/> class
            using the default initial pool size (5) and the max pool size (15).
            </summary>
        </member>
        <member name="M:Castle.Core.PooledAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute"/> class.
            </summary>
            <param name="initialPoolSize">Initial size of the pool.</param>
            <param name="maxPoolSize">Max pool size.</param>
        </member>
        <member name="P:Castle.Core.PooledAttribute.InitialPoolSize">
            <summary>
            Gets the initial size of the pool.
            </summary>
            <value>The initial size of the pool.</value>
        </member>
        <member name="P:Castle.Core.PooledAttribute.MaxPoolSize">
            <summary>
            Gets the maximum pool size.
            </summary>
            <value>The size of the max pool.</value>
        </member>
        <member name="T:Castle.Core.CustomLifestyleAttribute">
            <summary>
            Indicates that the target components wants a
            custom lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.CustomLifestyleAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CustomLifestyleAttribute"/> class.
            </summary>
            <param name="lifestyleHandlerType">The lifestyle handler.</param>
        </member>
        <member name="P:Castle.Core.CustomLifestyleAttribute.LifestyleHandlerType">
            <summary>
            Gets the type of the lifestyle handler.
            </summary>
            <value>The type of the lifestyle handler.</value>
        </member>
        <member name="T:Castle.Core.LifestyleType">
            <summary>
            Enumeration used to mark the component's lifestyle.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Undefined">
            <summary>
            No lifestyle specified.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Singleton">
            <summary>
            Singleton components are instantiated once, and shared
            between all clients.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Thread">
            <summary>
            Thread components have a unique instance per thread.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Transient">
            <summary>
            Transient components are created on demand.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Pooled">
            <summary>
            Optimization of transient components that keeps
            instance in a pool instead of always creating them.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.PerWebRequest">
            <summary>
            PerWebRequest components are created once per Http Request
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Custom">
            <summary>
            Any other logic to create/release components.
            </summary>
        </member>
        <member name="T:Castle.Facilities.EventWiring.EventSubscribers">
            <summary>
            Collects information about subscribers for given event
            </summary>
        </member>
        <member name="T:Castle.Facilities.EventWiring.NaiveMethodNameExtractor">
            <summary>
            Extracts MethodInfo of metho invoked in delegate. Based on ILReader class from http://www.gocosmos.org project
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction">
            <summary>
            Implementors must inspect the component for 
            a given information or parameter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Usually the implementation will look in the configuration property 
            of the model or the service interface, or the implementation looking for
            something.
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector.SelectComponent(System.Reflection.MethodInfo,System.Type,System.Object[])">
            <summary>
            Selects one or both of component name and type, for given method 
            called on given typed factory type.
            When component should be requested by type only,
            componentName should be null.
            When component should be requested by name only,
            componentType should be null.
            </summary>
            <param name="method"></param>
            <param name="type"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.BuildFactoryComponent(System.Reflection.MethodInfo,System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Builds <see cref="T:Castle.Facilities.TypedFactory.TypedFactoryComponent"/> for given call.
              By default if <paramref name="componentType"/> is a collection
              returns <see cref="T:Castle.Facilities.TypedFactory.TypedFactoryComponentCollection"/> for the collection's item type,
              otherwise standard <see cref="T:Castle.Facilities.TypedFactory.TypedFactoryComponent"/>.
            </summary>
            <param name="method"></param>
            <param name="componentName"></param>
            <param name="componentType"></param>
            <param name="additionalArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetArguments(System.Reflection.MethodInfo,System.Object[])">
            <summary>
              Selects arguments to be passed to resolution pipeline.
              By default passes all given <paramref name = "arguments" /> 
              keyed by names of their corresponding <paramref name = "method" /> parameters.
            </summary>
            <param name = "method"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetComponentName(System.Reflection.MethodInfo,System.Object[])">
            <summary>
              Selects name of the component to resolve.
              If <paramref name = "method" /> Name is GetFoo returns "Foo", otherwise <c>null</c>.
            </summary>
            <param name = "method"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetComponentType(System.Reflection.MethodInfo,System.Object[])">
            <summary>
              Selects type of the component to resolve. Uses <paramref name = "method" /> return type.
            </summary>
            <param name = "method"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.ILazyComponentLoader">
            <summary>
            Provides lazy registration capabilities to the container.
            </summary>
            <remarks>
            When a component is requested from a container and it was not registered, 
            container loads up all registered implementers of this interface and asks 
            them in turn whether they can provide that component, until it finds one that will.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.ILazyComponentLoader.Load(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            Used by container to allow the loader to register component for given <paramref name="key"/> and <paramref name="service"/> to the container at the time when it is requested
            </summary>
            <param name="key">Key of the requested component or null</param>
            <param name="service">Type of requested service or null</param>
            <param name="arguments">User supplied arguments or null</param>
            <returns>Registration that registers component for given key and/or service or null.</returns>
            <remarks>
            While either key or service can be null reference it is guaranteed that at least one of them will not be null.
            When implementer opts in to provide the requested component (by returning not-null registration) it is required
            to register component for requested key/service combination (when one of the elements is null, it should be ignored as well).
            When implementer does not want to register the requested component it must return null.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.ComponentActivatorException">
            <summary>
            Summary description for ComponentActivatorException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Burden">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Arguments">
            <summary>
            Represents collection of arguments used when resolving a component.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.NoResolvableConstructorFoundException">
            <summary>
            Exception thrown when component has no resolvable constructor that can be used to create an instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Context.FallbackArgumentsStore">
            <summary>
            Default arguments store used to store items where no specialized store exists
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Context.DependencyTrackingScope.DependencyModelExtended">
            <summary>
            Extends <see cref="T:Castle.Core.DependencyModel"/> adding <see cref="T:System.Reflection.MemberInfo"/> and <see cref="T:Castle.Core.ComponentModel"/>
            information. The MemberInfo is only useful to provide detailed information 
            on exceptions. 
            The ComponentModel is required so we can get resolve an object that takes as a parameter itself, but
            with difference model. (See IoC 51 for the details)
            </summary>
        </member>
        <member name="T:Castle.Core.DependencyModel">
            <summary>
              Represents a dependency (other component or a 
              fixed value available through external configuration).
            </summary>
        </member>
        <member name="M:Castle.Core.DependencyModel.#ctor(Castle.Core.DependencyType,System.String,System.Type,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.DependencyModel"/> class.
            </summary>
            <param name="dependencyType">The type.</param>
            <param name="dependencyKey">The dependency key.</param>
            <param name="targetType">Type of the target.</param>
            <param name="isOptional">if set to <c>true</c> [is optional].</param>
        </member>
        <member name="M:Castle.Core.DependencyModel.ToString">
            <summary>
              Returns a <see cref = "T:System.String" /> that represents the current <see cref = "T:System.Object" />.
            </summary>
            <returns>
              A <see cref = "T:System.String" /> that represents the current <see cref = "T:System.Object" />.
            </returns>
        </member>
        <member name="P:Castle.Core.DependencyModel.DependencyKey">
            <summary>
              Gets or sets the dependency key.
            </summary>
            <value>The dependency key.</value>
        </member>
        <member name="P:Castle.Core.DependencyModel.DependencyType">
            <summary>
              Gets or sets the type of the dependency.
            </summary>
            <value>The type of the dependency.</value>
        </member>
        <member name="P:Castle.Core.DependencyModel.IsOptional">
            <summary>
              Gets or sets whether this dependency is optional.
            </summary>
            <value>
              <c>true</c> if this dependency is optional; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.DependencyModel.TargetItemType">
            <summary>
              Gets the service type of the dependency.
              This is the same type as <see cref="P:Castle.Core.DependencyModel.TargetType"/> or if <see cref="P:Castle.Core.DependencyModel.TargetType"/> is by ref,
              then it's the element type of the reference. (in other words if dependency 
              is <c>out IFoo foo</c> this will be <c>IFoo</c>, while <see cref="P:Castle.Core.DependencyModel.TargetType"/> will be <c>&amp;IFoo</c>);
            </summary>
        </member>
        <member name="P:Castle.Core.DependencyModel.TargetType">
            <summary>
              Gets the type of the target.
            </summary>
            <value>The type of the target.</value>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandler">
            <summary>
            Summary description for DefaultHandler.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.AbstractHandler">
            <summary>
              Implements the basis of
              <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandler">
            <summary>
            Contract for the IHandler, which manages an
            component state and coordinates its creation 
            and destruction (dispatching to activators, lifestyle managers)
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ISubDependencyResolver">
            <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.Resolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Should return an instance of a service or property values as
            specified by the dependency model instance. 
            It is also the responsibility of <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            to throw an exception in the case a non-optional dependency 
            could not be resolved.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver - normally the IHandler implementation</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns>The dependency resolved value or null</returns>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.CanResolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Returns true if the resolver is able to satisfy this dependency.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver - normally the IHandler implementation</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns><c>true</c> if the dependency can be satisfied</returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the handler with a reference to the
            kernel.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Resolve(Castle.MicroKernel.Context.CreationContext)">
            <summary>
            Implementors should return a valid instance 
            for the component the handler is responsible.
            It should throw an exception in the case the component
            can't be created for some reason
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.TryResolve(Castle.MicroKernel.Context.CreationContext)">
            <summary>
            Implementors should return a valid instance 
            for the component the handler is responsible.
            It should return null in the case the component
            can't be created for some reason
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Release(System.Object)">
            <summary>
            Implementors should dispose the component instance
            </summary>
            <param name="instance"></param>
            <returns>true if destroyed.</returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.AddCustomDependencyValue(System.Object,System.Object)">
            <summary>
            Dictionary of String/object used to 
            associate data with a component dependency.
            For example, if you component SmtpServer depends on 
            host and port, you can add those to this
            dictionary and the handler will be able to use them.
            </summary>
            <remarks>
            TODO: Document this
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.RemoveCustomDependencyValue(System.Object)">
            <summary>
            TODO: Document this
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.HasCustomParameter(System.Object)">
            <summary>
            TODO: Document this
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.IsBeingResolvedInContext(Castle.MicroKernel.Context.CreationContext)">
            <summary>
            Tests whether the handler is already being resolved in given context.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.CurrentState">
            <summary>
            Gets the state of the handler
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.ComponentModel">
            <summary>
            Gets the model of the component being 
            managed by this handler.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.Service">
            <summary>
            The service that this handler handles
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IHandler.OnHandlerStateChanged">
            <summary>
            Allow to track state changes of a handler that is modified directly.
            This can happen if the client calls AddCustomDependencyValue or 
            RemoveCustomDependencyValue
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.IExposeDependencyInfo">
            <summary>
            Might be implemented by a handler 
            so it can expose access to dependency information 
            which is used to construct meaningful error messages
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.IExposeDependencyInfo.ObtainDependencyDetails(System.Collections.IList)">
            <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            <param name="dependenciesChecked">list of the dependencies that was already checked, used to avoid cycles.</param>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.lifestyleManager">
            <summary>
              Lifestyle manager instance
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.customParameters">
            <summary>
              Custom dependencies values associated with the handler
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.dependenciesByKey">
            <summary>
              Dictionary of key (string) to
              <see cref="T:Castle.Core.DependencyModel"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.dependenciesByService">
            <summary>
              Dictionary of Type to a list of
              <see cref="T:Castle.Core.DependencyModel"/>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
              Constructs and initializes the handler
            </summary>
            <param name = "model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ReleaseCore(System.Object)">
            <summary>
              Should be implemented by derived classes: 
              disposes the component instance (or recycle it)
            </summary>
            <param name = "instance"></param>
            <returns>true if destroyed.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ResolveCore(Castle.MicroKernel.Context.CreationContext,System.Boolean,System.Boolean)">
            <summary>
              Should be implemented by derived classes: 
              returns an instance of the component this handler
              is responsible for
            </summary>
            <param name = "context"></param>
            <param name = "requiresDecommission"></param>
            <param name = "instanceRequired">When <c>false</c>, handler can not create valid instance and return <c>null</c> instead.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ObtainDependencyDetails(System.Collections.IList)">
            <summary>
              Returns human readable list of dependencies 
              this handler is waiting for.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Init(Castle.MicroKernel.IKernel)">
            <summary>
              Saves the kernel instance, subscribes to
              <see cref="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel"/>
              event,
              creates the lifestyle manager instance and computes
              the handler state.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Release(System.Object)">
            <summary>
              disposes the component instance (or recycle it).
            </summary>
            <param name = "instance"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Returns an instance of the component this handler
              is responsible for
            </summary>
            <param name = "context"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)">
            <summary>
              Invoked by
              <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied(Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator)"/>
              in order to check if a dependency can be satisfied.
              If not, the handler is set to a 'waiting dependency' state.
            </summary>
            <remarks>
              This method registers the dependencies within the correct collection 
              or dictionary and changes the handler state to
              <see cref="F:Castle.MicroKernel.HandlerState.WaitingDependency"/>
            </remarks>
            <param name="dependency"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.CreateLifestyleManager(Castle.MicroKernel.IComponentActivator)">
            <summary>
              Creates an implementation of
              <see cref="T:Castle.MicroKernel.ILifestyleManager"/>
              based
              on
              <see cref="T:Castle.Core.LifestyleType"/>
              and invokes
              <see cref="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)"/>
              to initialize the newly created manager.
            </summary>
            <param name="activator"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.DependencySatisfied(System.Boolean@)">
            <summary>
              Invoked by the kernel
              when one of registered dependencies were satisfied by 
              new components registered.
            </summary>
            <remarks>
              Handler for the event
              <see cref="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered"/>
            </remarks>
            <param name="stateChanged"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied(Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator)">
            <summary>
              Checks if the handler is able to, at very least, satisfy
              the dependencies for the constructor with less parameters
            </summary>
            <remarks>
              For each non*optional dependency, the implementation will invoke
              <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.OnAddedAsChildKernel(System.Object,System.EventArgs)">
            <summary>
              Invoked when the container receives a parent container reference.
            </summary>
            <remarks>
              This method implementation checks whether the parent container
              is able to supply the dependencies for this handler.
            </remarks>
            <param name = "sender"></param>
            <param name = "e"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.Context.CreationContext,System.Boolean)">
            <summary>
              Returns an instance of the component this handler
              is responsible for
            </summary>
            <param name = "context"></param>
            <param name = "instanceRequired">when <c>false</c>, handler can not create valid instance and return <c>null</c> instead </param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.HandlerStateChanged(System.Object,System.EventArgs)">
            <summary>
              Handler for the event
              <see cref="E:Castle.MicroKernel.Handlers.AbstractHandler.OnHandlerStateChanged"/>
            </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.ComponentModel">
            <summary>
              Gets the component model.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.CurrentState">
            <summary>
              Gets the handler state.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.DefaultHandler"/> class.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.ResolveCore(Castle.MicroKernel.Context.CreationContext,System.Boolean,System.Boolean)">
            <summary>
            Returns an instance of the component this handler
            is responsible for
            </summary>
            <param name="context"></param>
            <param name="requiresDecommission"></param>
            <param name="instanceRequired"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.ReleaseCore(System.Object)">
            <summary>
            disposes the component instance (or recycle it)
            </summary>
            <param name="instance"></param>
            <returns>true if destroyed</returns>
        </member>
        <member name="T:Castle.MicroKernel.Context.CreationContext">
            <summary>
              Used during a component request, passed along to the whole process.
              This allow some data to be passed along the process, which is used 
              to detected cycled dependency graphs and now it's also being used
              to provide arguments to components.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Context.CreationContext.dependencies">
            <summary>
              Holds the scoped dependencies being resolved. 
              If a dependency appears twice on the same scope, we'd have a cycle.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Context.CreationContext.handlerStack">
            <summary>
              The list of handlers that are used to resolve
              the component.
              We track that in order to try to avoid attempts to resolve a service
              with itself.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor(System.Type,Castle.MicroKernel.Context.CreationContext,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext"/> class.
            </summary>
            <param name="typeToExtractGenericArguments">The type to extract generic arguments.</param>
            <param name="parentContext">The parent context.</param>
            <param name="propagateInlineDependencies">When set to <c>true</c> will clone <paramref name="parentContext"/> <see cref="P:Castle.MicroKernel.Context.CreationContext.AdditionalParameters"/>.</param>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.IReleasePolicy,System.Type,System.Collections.IDictionary,Castle.MicroKernel.SubSystems.Conversion.ITypeConverter,Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext"/> class.
            </summary>
            <param name="handler">The handler.</param>
            <param name="releasePolicy">The release policy.</param>
            <param name="typeToExtractGenericArguments">The type to extract generic arguments.</param>
            <param name="additionalArguments">The additional arguments.</param>
            <param name="conversionManager">The conversion manager.</param>
            <param name="parent">Parent context</param>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.IsInResolutionContext(Castle.MicroKernel.IHandler)">
            <summary>
              Method used by handlers to test whether they are being resolved in the context.
            </summary>
            <param name="handler"></param>
            <returns></returns>
            <remarks>
              This method is provided as part of double dispatch mechanism for use by handlers.
              Outside of handlers, call <see cref="M:Castle.MicroKernel.IHandler.IsBeingResolvedInContext(Castle.MicroKernel.Context.CreationContext)"/> instead.
            </remarks>
        </member>
        <member name="P:Castle.MicroKernel.Context.CreationContext.Empty">
            <summary>
              Creates a new, empty <see cref="T:Castle.MicroKernel.Context.CreationContext"/> instance.
            </summary>
            <remarks>
              A new CreationContext should be created every time, as the contexts keeps some state related to dependency resolution.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.DefaultKernel">
            <summary>
              Default implementation of <see cref="T:Castle.MicroKernel.IKernel"/>. 
              This implementation is complete and also support a kernel 
              hierarchy (sub containers).
            </summary>
            <summary>
              Default implementation of <see cref="T:Castle.MicroKernel.IKernel"/>. 
              This implementation is complete and also support a kernel 
              hierarchy (sub containers).
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IKernel">
            <summary>
            The <c>IKernel</c> interface exposes all the functionality
            the MicroKernel implements.
            </summary>
            <remarks>
            It allows you to register components and
            request them by the key or the service they implemented.
            It also allow you to register facilities and subsystem, thus 
            augmenting the functionality exposed by the kernel alone to fits 
            your needs.
            <seealso cref="T:Castle.MicroKernel.IFacility"/>
            <seealso cref="T:Castle.MicroKernel.ISubSystem"/>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.IKernelEvents">
            <summary>
            Summary description for IKernelEvents.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentRegistered">
            <summary>
            Event fired when a new component is registered 
            on the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentUnregistered">
            <summary>
            Event fired when a component is removed from the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated">
            <summary>
            Event fired after the ComponentModel is created.
            Allows customizations that may affect the handler.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel">
            <summary>
            Event fired when the kernel was added as child of
            another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.RemovedAsChildKernel">
            <summary>
            Event fired when the kernel was removed from being a child
            of another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentCreated">
            <summary>
            Event fired before the component is created.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed">
            <summary>
            Event fired when a component instance destroyed.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered">
            <summary>
            Event fired when a new handler is registered 
            (it might be in a valid or waiting dependency state)
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.HandlersChanged">
            <summary>
            Event fired when a new handler is registered 
            (it might be in a valid or waiting dependency state)
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.DependencyResolving">
            <summary>
            Event fired when a dependency is being resolved,
            it allows the dependency to be changed,
            but the client ComponentModel must not be changed.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
            Registers the components provided by the <see cref="T:Castle.MicroKernel.Registration.IRegistration"/>s
            with the <see cref="T:Castle.MicroKernel.IKernel"/>.
            <para/>
            Create a new registration using <see cref="T:Castle.MicroKernel.Registration.Component"/>.For() or <see cref="T:Castle.MicroKernel.Registration.AllTypes"/>.
            </summary>
            <example>
            <code>
            kernel.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;());
            </code>
            </example>
            <param name="registrations">The component registrations.</param>
            <returns>The kernel.</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveComponent(System.String)">
            <summary>
            Returns true if the specified component was 
            found and could be removed (i.e. no other component depends on it)
            </summary>
            <param name="key">The component's key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.String)">
            <summary>
            Returns true if the specified key was registered
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.Type)">
            <summary>
            Returns true if the specified service was registered
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.Type,System.Collections.IDictionary)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="service"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.Type,System.Object)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="service"></param>
            <param name="dependenciesAsAnonymousType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.String,System.Collections.IDictionary)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="key"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.String,System.Object)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="key"></param>
            <param name="dependenciesAsAnonymousType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ReleaseComponent(System.Object)">
            <summary>
            Releases a component instance. This allows
            the kernel to execute the proper decommission 
            lifecycles on the component instance.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.String)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
            for the specified component key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
            for the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetAssignableHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
            Adds a <see cref="T:Castle.MicroKernel.IFacility"/> to the kernel.
            </summary>
            <param name="key"></param>
            <param name="facility"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String)">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String,System.Action{``0})">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String,System.Func{``0,System.Object})">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.Action{``0})">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.Func{``0,System.Object})">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetFacilities">
            <summary>
            Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddSubSystem(System.String,Castle.MicroKernel.ISubSystem)">
            <summary>
            Adds (or replaces) an <see cref="T:Castle.MicroKernel.ISubSystem"/>
            </summary>
            <param name="key"></param>
            <param name="subsystem"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetSubSystem(System.String)">
            <summary>
            Returns an implementation of <see cref="T:Castle.MicroKernel.ISubSystem"/>
            for the specified key. 
            <seealso cref="T:Castle.MicroKernel.SubSystemConstants"/>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
            Support for kernel hierarchy
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
            Remove child kernel
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddHandlerSelector(Castle.MicroKernel.IHandlerSelector)">
            <summary>
            Register a new component resolver that can take part in the decision
            making about which handler to resolve
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type)">
            <summary>
            Returns the component instance by the service type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Collections.IDictionary)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
            <param name="arguments">Arguments to resolve the services</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Object)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
            <param name="key"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Object)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="service">Service to resolve</param>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Object)">
            <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
            <param name="key">Key to resolve</param>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.Object)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1">
            <summary>
            Returns the component instance by the component key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.String)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key">Component's key</param>
            <typeparam name="T">Service type</typeparam>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
            Returns a component instance by the key
            </summary>
            <typeparam name="T">Service type</typeparam>
            <param name="key">Component's key</param>
            <param name="arguments"></param>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1(System.Object)">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ComponentModelBuilder">
            <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.HandlerFactory">
            <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ConfigurationStore">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ReleasePolicy">
            <summary>
            Gets or sets the implementation for <see cref="T:Castle.MicroKernel.IReleasePolicy"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Resolver">
            <summary>
            Returns the implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ProxyFactory">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            allowing different strategies for proxy creation.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Parent">
            <summary>
            Returns the parent kernel
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.GraphNodes">
            <summary>
            Graph of components and interactions.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.String)">
            <summary>
            Returns the component instance by the key
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.Type)">
            <summary>
            Returns the component instance by the service type
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IKernelInternal">
            <summary>
            Extended contract of kernel, used internally.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernelInternal.CreateComponentActivator(Castle.Core.ComponentModel)">
            <summary>
            Constructs an implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            for the given <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernelInternal.RaiseHandlerRegistered(Castle.MicroKernel.IHandler)">
            <summary>
            Raise the handler registered event, required so
            dependant handlers will be notified about their dependant moving
            to valid state.
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernelInternal.RegisterHandlerForwarding(System.Type,System.String)">
            <summary>
            Registers the <paramref name="forwardedType"/> to be forwarded 
            to the component registered with <paramref name="name"/>.
            </summary>
            <param name="forwardedType">The service type that gets forwarded.</param>
            <param name="name">The name of the component to forward to.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernelInternal.AddCustomComponent(Castle.Core.ComponentModel)">
            <summary>
            Adds a custom made <see cref="T:Castle.Core.ComponentModel"/>.
            Used by facilities.
            </summary>
            <param name="model"></param>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.childKernels">
            <summary>
              List of sub containers.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.facilities">
            <summary>
              List of <see cref="T:Castle.MicroKernel.IFacility"/> registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.handlerFactory">
            <summary>
              The implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.resolver">
            <summary>
              The dependency resolver.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.subsystems">
            <summary>
              Map of subsystems registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.parentKernel">
            <summary>
              The parent kernel, if exists.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.proxyFactory">
            <summary>
              Holds the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.releasePolicy">
            <summary>
              Implements a policy to control component's
              disposal that the user forgot.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor">
            <summary>
              Constructs a DefaultKernel with no component
              proxy support.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IDependencyResolver,Castle.MicroKernel.IProxyFactory)">
            <summary>
              Constructs a DefaultKernel with the specified
              implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/> and <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
            <param name="resolver"></param>
            <param name="proxyFactory"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IProxyFactory)">
            <summary>
              Constructs a DefaultKernel with the specified
              implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Dispose">
            <summary>
              Starts the process of component disposal.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetAssignableHandlers(System.Type)">
            <summary>
              Return handlers for components that 
              implements the specified service. 
              The check is made using IsAssignableFrom
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetFacilities">
            <summary>
              Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetHandlers(System.Type)">
            <summary>
              Return handlers for components that 
              implements the specified service.
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
              Registers the components described by the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/>s
              with the <see cref="T:Castle.MicroKernel.IKernel"/>.
              <param name="registrations">The component registrations.</param>
              <returns>The kernel.</returns>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RegisterCustomDependencies(System.Type,System.Collections.IDictionary)">
            <summary>
              Associates objects with a component handler,
              allowing it to use the specified dictionary
              when resolving dependencies
            </summary>
            <param name = "service"></param>
            <param name = "dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RegisterCustomDependencies(System.Type,System.Object)">
            <summary>
              Associates objects with a component handler,
              allowing it to use the specified dictionary
              when resolving dependencies
            </summary>
            <param name = "service"></param>
            <param name = "dependenciesAsAnonymousType"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RegisterCustomDependencies(System.String,System.Collections.IDictionary)">
            <summary>
              Associates objects with a component handler,
              allowing it to use the specified dictionary
              when resolving dependencies
            </summary>
            <param name = "key"></param>
            <param name = "dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RegisterCustomDependencies(System.String,System.Object)">
            <summary>
              Associates objects with a component handler,
              allowing it to use the specified dictionary
              when resolving dependencies
            </summary>
            <param name = "key"></param>
            <param name = "dependenciesAsAnonymousType"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ReleaseComponent(System.Object)">
            <summary>
              Releases a component instance. This allows
              the kernel to execute the proper decommission
              lifecycles on the component instance.
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RemoveComponent(System.String)">
            <summary>
              Returns true if the specified component was
              found and could be removed (i.e. no other component depends on it)
            </summary>
            <param name = "key">The component's key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetService(System.Type)">
            <summary>
              Gets the service object of the specified type.
            </summary>
            <returns>
              A service object of type serviceType.
            </returns>
            <param name = "serviceType">An object that specifies the type of service object to get. </param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetService``1">
            <summary>
              Gets the service object of the specified type.
            </summary>
            <returns>
              A service object of type serviceType.
            </returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.Object)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name="argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1">
            <summary>
              Returns the component instance by the component key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.String)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name="key">Component's key</param>
            <typeparam name="T">Service type</typeparam>
            <returns>
              The Component instance
            </returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <typeparam name="T">Service type</typeparam>
            <param name="key">Component's key</param>
            <param name="arguments"></param>
            <returns>
              The Component instance
            </returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type)">
            <summary>
              Returns the component instance by the service type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Object)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name="service"></param>
            <param name="argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
            <param name="key"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Object)">
            <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
            <param name="key"></param>
            <param name="argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name="service">The service type</param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name="service">The service type</param>
            <param name="arguments">
              Arguments to resolve the services
            </param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type,System.Object)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name="service">The service type</param>
            <param name="argumentsAsAnonymousType">
              Arguments to resolve the services
            </param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1(System.Object)">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.DefaultKernel.GraphNodes">
            <summary>
              Graph of components and interactions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.CircularDependencyException">
            <summary>
            Exception throw when a circular dependency is detected
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.CircularDependencyException"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.CircularDependencyException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.CircularDependencyException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.CircularDependencyException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <see langword="null"/> or <see cref="P:System.Exception.HResult"/> is zero (0).</exception>
        </member>
        <member name="T:Castle.MicroKernel.ComponentNotFoundException">
            <summary>
            Exception threw when a request for a component
            cannot be satisfied because the component does not
            exist in the container
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.String,System.String)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="name">The name.</param>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type,System.String)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="service">The service.</param>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="service">The service.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentRegistrationException">
            <summary>
            Exception threw when there is a problem
            registering a component
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.KernelException">
            <summary>
            Exception threw by Kernel operations that failed
            for some reason.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.AbstractFacility">
            <summary>
              Base class for facilities.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IFacility">
            <summary>
            Unit of extension. A facility should use 
            the extension points offered by the kernel
            to augment its functionality.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
            
            </summary>
            <param name="kernel"></param>
            <param name="facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Terminate">
            <summary>
            
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init">
            <summary>
              The custom initialization for the Facility.
            </summary>
            <remarks>
              It must be overridden.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose">
            <summary>
              Performs the tasks associated with freeing, releasing, or resetting 
              the facility resources.
            </summary>
            <remarks>
              It can be overriden.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Castle#MicroKernel#IFacility#Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Initializes the facility. First it performs the initialization common for all 
              facilities, setting the <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel"/> and the 
              <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig"/>. After it, the <c>Init</c> method is invoked
              and the custom initilization is perfomed.
            </summary>
            <param name="kernel"></param>
            <param name="facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Castle#MicroKernel#IFacility#Terminate">
            <summary>
              Terminates the Facility, invokes the <see cref="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose"/> method and sets 
              the Kernel to a null reference.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig">
            <summary>
              Gets the facility configuration.
            </summary>
            <value>The <see cref="T:Castle.Core.Configuration.IConfiguration"/> representing 
              the facility configuration.</value>
        </member>
        <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel">
            <summary>
              Gets the <see cref="T:Castle.MicroKernel.IKernel"/> where the facility is registered.
            </summary>
            <value>The <see cref="T:Castle.MicroKernel.IKernel"/>.</value>
        </member>
        <member name="T:Castle.Facilities.EventWiring.EventWiringException">
            <summary>
            Exception that is thrown when a error occurs during the Event Wiring process
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.FacilityException">
            <summary>
            Base exception to be used by facilities.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.Facilities.EventWiring.EventWiringFacility">
             <summary>
             Facility to allow components to dynamically subscribe to events offered by 
             other components. We call the component that offers events publishers and 
             the components that uses them, subscribers.
             </summary>
             <remarks>
             A component that wish to subscribe to an event must use the external configuration
             adding a node <c>subscribers</c> on the publisher. This node can have multiple entries using the 
             <c>subscriber</c> node.
             </remarks>
             <example>
             <para>This example shows two simple components: one is the event publisher and the other is the 
             subscriber. The subscription will be done by the facility, using the publisher associated configuration.</para>
             <para>The Publisher class:</para>
             <code>
             public class SimplePublisher
            	{
            		public event PublishEventHandler Event;
            
            		public void Trigger()
            		{
            			if (Event != null)
            			{
            				Event(this, new EventArgs()); 
            			}
            		}
             }
             </code>
             <para>The Subscriber class:</para>
             <code>
             public class SimpleListener
             {
             	private bool _listened;
             	private object _sender;
             
             	public void OnPublish(object sender, EventArgs e)
             	{
             		_sender = sender; 
             		_listened = sender != null;
             	}
             
             	public bool Listened
             	{
             		get { return _listened;	}
             	}
             
             	public object Sender
             	{
             		get { return _sender; }
             	}
             }
             </code>
             <para>The configuration file:</para>
             <code>
             <![CDATA[
             <?xml version="1.0" encoding="utf-8" ?>
             <configuration>
             	<facilities>
             		<facility 
             			id="event.wiring"
             			type="Castle.Facilities.EventWiring.EventWiringFacility, Castle.Windsor" />
             	</facilities>
             
             	<components>
             		<component 
             			id="SimpleListener" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimpleListener, Castle.Facilities.EventWiring.Tests" />
             
             		<component 
             			id="SimplePublisher" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimplePublisher, Castle.Facilities.EventWiring.Tests" >
             			<subscribers>
             				<subscriber id="SimpleListener" event="Event" handler="OnPublish"/>
             			</subscribers>
             		</component>
             	</components>
             </configuration>
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.Init">
            <summary>
            Overridden. Initializes the facility, subscribing to the <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated"/>,
            <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentCreated"/>, <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed"/> Kernel events.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentModelCreated(Castle.Core.ComponentModel)">
            <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            parses the configuration (the subscribers node) getting the event wiring info.
            </summary>
            <param name="model">The component model.</param>
            <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">Invalid and/or a error in the configuration</exception>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentCreated(Castle.Core.ComponentModel,System.Object)">
            <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            iterates the subscribers starting them and wiring the events.
            </summary>
            <param name="model">The component model.</param>
            <param name="instance">The instance representing the component.</param>
            <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">When the subscriber is not found
            <br/> or <br/>
            The handler method isn't found
            <br/> or <br/>
            The event isn't found
            </exception>
        </member>
        <member name="T:Castle.Facilities.EventWiring.WireInfo">
            <summary>
            Represents the information about an event.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.WireInfo"/> class.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="handler">The name of the handler method.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
        </member>
        <member name="P:Castle.Facilities.EventWiring.WireInfo.EventName">
            <summary>
            Gets the name of the event.
            </summary>
            <value>The name of the event.</value>
        </member>
        <member name="P:Castle.Facilities.EventWiring.WireInfo.Handler">
            <summary>
            Gets the handler method name.
            </summary>
            <value>The handler.</value>
        </member>
        <member name="T:Castle.Facilities.FactorySupport.FactoryActivator">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Facilities.Remoting.CustomActivators.RemoteActivator">
            <summary>
            Activates a object connecting to the remote server.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.CustomActivators.RemoteActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.CustomActivators.RemoteActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.CustomActivators.RemoteActivatorThroughConnector">
            <summary>
            Activates a client connecting to the remote server, enforcing the uri and the server activation.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.CustomActivators.RemoteActivatorThroughConnector.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.CustomActivators.RemoteActivatorThroughConnector"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.CustomActivators.RemoteActivatorThroughRegistry">
            <summary>
            Activates a client connecting to the remote server through the <see cref="T:Castle.Facilities.Remoting.RemotingRegistry"/>.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.CustomActivators.RemoteActivatorThroughRegistry.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.CustomActivators.RemoteActivatorThroughRegistry"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.CustomActivators.RemoteClientActivatedActivator">
            <summary>
            Activates a client activated object.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.CustomActivators.RemoteClientActivatedActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.CustomActivators.RemoteClientActivatedActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.CustomActivators.RemoteMarshallerActivator">
            <summary>
            Activates and publishes a server object.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.CustomActivators.RemoteMarshallerActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.CustomActivators.RemoteMarshallerActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemotingFacility">
            <summary>
              Facility to allow the communication with remote kernel, using the .NET Remoting infrastructure.
            </summary>
            <remarks>
              TODO
            </remarks>
            <example>
              TODO
            </example>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.baseUri">
            <summary>
              Used for client side (Expand explanation)
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.localRegistry">
            <summary>
              Used for server side. 
              Holds the local registry
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.remoteRegistry">
            <summary>
              Used for client side. 
              Holds a remote proxy to the server registry
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingFacility.Dispose">
            <summary>
              Performs the tasks associated with freeing, releasing, or resetting
              the facility resources.
            </summary>
            <remarks>
              It can be overridden.
            </remarks>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemotingInspector">
            <summary>
            Inspects the model looking for remote component configuration. If found, 
            do the component Remoting configuration.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingInspector.#ctor(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter,System.Boolean,System.Boolean,System.String,Castle.Facilities.Remoting.RemotingRegistry,Castle.Facilities.Remoting.RemotingRegistry)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemotingInspector"/> class.
            </summary>
            <param name="converter">The converter.</param>
            <param name="isServer">if set to <c>true</c> is a server.</param>
            <param name="isClient">if set to <c>true</c> is a client.</param>
            <param name="baseUri">The base URI.</param>
            <param name="remoteRegistry">The remote registry.</param>
            <param name="localRegistry">The local registry.</param>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingInspector.ResetDependencies(Castle.Core.ComponentModel)">
            <summary>
            Client components are not created by the container
            so there's no point collecting constructor dependencies
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingRegistry.GetModel(System.Type)">
            <summary>
            Used in case of generics:
            </summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.DeferredStart">
            <summary>
              This method changes behavior of the facility. Deferred mode should be used when you
              have single call to <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> and register all your components there.
              Enabling this mode will optimize the behavior of the facility so that it will wait 'till the end of
              installation and only after all <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>s were ran it will instantiate and
              start all the startable components. An exception will be thrown if a startable component can't be 
              instantiated and started. This will help you fail fast and diagnose issues quickly. If you don't want
              the exception to be thrown and you prefer the component to fail silently, use <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart"/> method instead.
            </summary>
            <remarks>
              It is recommended to use this method over <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart"/> method.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart">
            <summary>
              This method changes behavior of the facility. Deferred mode should be used when you
              have single call to <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> and register all your components there.
              Enabling this mode will optimize the behavior of the facility so that it will wait 'till the end of
              installation and only after all <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>s were ran it will instantiate and
              start all the startable components. No exception will be thrown if a startable component can't be 
              instantiated and started. If you'd rather fail fast and diagnose issues quickly, use <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredStart"/> method instead.
            </summary>
            <remarks>
              It is recommended to use <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredStart"/> method over this method.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.CheckWaitingList">
            <summary>
              For each new component registered,
              some components in the WaitingDependency
              state may have became valid, so we check them
            </summary>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.TryStart(Castle.MicroKernel.IHandler)">
            <summary>
              Request the component instance
            </summary>
            <param name = "handler"></param>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StartUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.String)">
            <summary>
            Assigns the start method for the startable.
            </summary>
            <param name="registration"></param>
            <param name="startMethod">The start method.</param>
            <returns></returns>
            <remarks>Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
            to the kernel, before registering this component.</remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StartUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Action}})">
            <summary>
            Assigns the start method for the startable.
            </summary>
            <param name="registration"></param>
            <param name="methodToUse">Method to use. something like: StartUsingMethod(s =&gt; s.Start)</param>
            <returns></returns>
            <remarks>Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
            to the kernel, before registering this component.</remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StopUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.String)">
            <summary>
            Assigns the stop method for the startable.
            </summary>
            <param name="registration"></param>
            <param name="stopMethod">The stop method.</param>
            <returns></returns>
            <remarks>Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
            to the kernel, before registering this component.</remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StopUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Action}})">
            <summary>
            Assigns the stop method for the startable.
            </summary>
            <param name="registration"></param>
            <param name="methodToUse">Method to use. something like: StartUsingMethod(s =&gt; s.Start)</param>
            <returns></returns>
            <remarks>Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
            to the kernel, before registering this component.</remarks>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.FactoryEntry">
            <summary>
            Legacy class from old impl. of the facility. Do not use it.
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.Internal.FactoryInterceptor">
            <summary>
            Legacy interceptor for old impl. of the facility.
            </summary>
        </member>
        <member name="T:Castle.Core.Interceptor.IOnBehalfAware">
            <summary>
            Interceptors might implement this to receive the
            ComponentModel on behalf of the component where the
            interceptor is acting.
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.TypedFactoryComponent">
            <summary>
              Represents a single component to be resolved via Typed Factory
            </summary>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryComponent.Resolve(Castle.MicroKernel.IKernel)">
            <summary>
              Resolves the component(s) from given kernel.
            </summary>
            <param name = "kernel"></param>
            <returns>Resolved component(s).</returns>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.TypedFactoryComponentCollection">
            <summary>
              Represents a set of components to be resolved via Typed Factory. Uses <see cref="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Collections.IDictionary)"/> to resolve the components.
            </summary>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryComponentCollection.#ctor(System.Type,System.Collections.IDictionary)">
            <summary>
              Creates new instance of <see cref="T:Castle.Facilities.TypedFactory.TypedFactoryComponentCollection"/>.
            </summary>
            <param name="componentCollectionType">Collection type to resolve. Must be an array (SomeComponent[]) or IEnumerable{SomeComponent}. Type of the element of the collection will be used as first argument to <see cref="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Collections.IDictionary)"/></param>
            <param name="additionalArguments">Additional arguents that will be passed as second argument to <see cref="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Collections.IDictionary)"/></param>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.TypedFactoryFacility">
            <summary>
              Provides automatically generated factories on top of interfaces or delegates that
              you can use to pull components out of the container without ever referencing it 
              explicitly.
            </summary>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0})">
            <summary>
              Marks the component as typed factory.
            </summary>
            <typeparam name="TFactoryInterface"></typeparam>
            <param name="registration"></param>
            <returns></returns>
            <remarks>
              Only interfaces are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector"/> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Action{Castle.Facilities.TypedFactory.TypedFactoryConfiguration})">
            <summary>
              Marks the component as typed factory.
            </summary>
            <typeparam name="TFactoryInterface"></typeparam>
            <param name="registration"></param>
            <param name="configuration"></param>
            <returns></returns>
            <remarks>
              Only interfaces are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector"/> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver">
            <summary>
              Redirects resolution to the main resolver, and if not found uses
              the parent handler.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver"/> class.
            </summary>
            <param name="parentHandler">The parent handler.</param>
            <param name="childResolver">The child resolver.</param>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultGenericHandler">
            <summary>
            Summary description for DefaultGenericHandler.
            </summary>
            <remarks>
            TODO: Consider refactoring AbstractHandler moving lifestylemanager
            creation to DefaultHandler
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultGenericHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.DefaultGenericHandler"/> class.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultGenericHandler.CloneParentProperties(Castle.Core.ComponentModel)">
            <summary>
            Clone some of the parent componentmodel properties to the generic subhandler.
            </summary>
            <remarks>
            The following properties are copied:
            <list type="bullet">
            <item>
            	<description>The <see cref="T:Castle.Core.LifestyleType"/></description>
            </item>
            <item>
            	<description>The <see cref="P:Castle.Core.ComponentModel.Interceptors"/></description>
            </item>
            </list>
            </remarks>
            <param name="newModel">the subhandler</param>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandlerFactory">
            <summary>
            Summary description for DefaultHandlerFactory.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandlerFactory">
            <summary>
            Extension point to allow the developer
            to use his implementation of <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.HandlerException">
            <summary>
            Summary description for HandlerException.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.HandlerState">
            <summary>
            Possible states for a IHandler instance
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.Valid">
            <summary>
            The component can be requested
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.WaitingDependency">
            <summary>
            The component can not be requested 
            as it still depending on a external 
            dependency not yet available
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerStateDelegate">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentDataDelegate">
            <summary>
            Represents a delegate which holds basic information about a component.
            </summary>
            <param name="key">Key which identifies the component</param>
            <param name="handler">handler that holds this component and is capable of 
            creating an instance of it.
            </param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentInstanceDelegate">
            <summary>
            Represents a delegate which holds basic information about a component
            and its instance.
            </summary>
            <param name="model">Component meta information</param>
            <param name="instance">Component instance</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentModelDelegate">
            <summary>
            Represents a delegate which holds the information about the 
            component
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerDelegate">
            <summary>
            Represents a delegate which holds a handler
            </summary>
            <param name="handler">handler that holds a component and is capable of 
            creating an instance of it.
            </param>
            <param name="stateChanged"></param>
        </member>
        <member name="T:Castle.MicroKernel.DependencyDelegate">
            <summary>
            Represents a delegate which holds dependency
            resolving information.
            </summary>
        </member>
        <member name="T:Castle.Core.Internal.IVertex">
            <summary>
            Abstract representation of a vertex.
            </summary>
        </member>
        <member name="P:Castle.Core.Internal.GraphNode.Dependers">
            <summary>
            The nodes that depends on this node
            </summary>
        </member>
        <member name="P:Castle.Core.Internal.GraphNode.Dependents">
            <summary>
            The nodes that this node depends
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.White">
            <summary>
            The node has not been visited yet
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.Gray">
            <summary>
            This node is in the process of being visited
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.Black">
            <summary>
            This now was visited
            </summary>
        </member>
        <member name="T:Castle.Core.Internal.ColorsSet">
            <summary>
            Represents a collection of objects
            which are guaranteed to be unique 
            and holds a color for them
            </summary>
        </member>
        <member name="T:Castle.Core.Internal.TimestampSet">
            <summary>
            Holds a timestamp (integer) 
            for a given item
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.DisposalConcern">
            <summary>
            Summary description for DisposalConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.InitializationConcern">
            <summary>
            Summary description for InitializationConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.LateBoundConcerns">
            <summary>
            Lifetime concern that works for components that don't have their actual type determined upfront
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.SupportInitializeConcern">
            <summary>
            Summary description for SupportInitializeConcern.
            </summary>
        </member>
        <member name="T:Castle.Core.IRecyclable">
            <summary>
            Only called for components that 
            belongs to a pool when the component
            comes back to the pool.
            </summary>
        </member>
        <member name="M:Castle.Core.IRecyclable.Recycle">
            <summary>
            Implementors should perform any 
            initialization/clean up.
            </summary>
        </member>
        <member name="T:Castle.Core.IStartable">
            <summary>
            Interface for components that wish to be started by the container
            </summary>
        </member>
        <member name="M:Castle.Core.IStartable.Start">
            <summary>
            Starts this instance.
            </summary>
        </member>
        <member name="M:Castle.Core.IStartable.Stop">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager">
            <summary>
            Summary description for PerThreadLifestyleManager.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PoolableLifestyleManager">
            <summary>
            Implements a Poolable Lifestyle Manager. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Pool.IPool">
            <summary>
            Pool implementation contract. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Request(Castle.MicroKernel.Context.CreationContext)">
            <summary>
            Implementors should return a component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Release(System.Object)">
            <summary>
            Implementors should release the instance or put it
            on the pool
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.DefaultPool.InitPool">
            <summary>
            Initializes the pool to a initial size by requesting
            n components and then releasing them.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.SingletonLifestyleManager">
            <summary>
            Summary description for SingletonLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.TransientLifestyleManager">
            <summary>
            Summary description for TransientLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder">
            <summary>
            Summary description for DefaultComponentModelBuilder.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentModelBuilder">
            <summary>
            Implementors must construct a populated
            instance of ComponentModel by inspecting the component
            and|or the configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.BuildModel(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Constructs a new ComponentModel by invoking
            the registered contributors.
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            "To give or supply in common with others; give to a 
            common fund or for a common purpose". The contributor
            should inspect the component, or even the configuration
            associated with the component, to add or change information
            in the model that can be used later.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            Removes the specified contributor
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.#ctor(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder"/> class.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.BuildModel(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Constructs a new ComponentModel by invoking
            the registered contributors.
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            "To give or supply in common with others; give to a
            common fund or for a common purpose". The contributor
            should inspect the component, or even the configuration
            associated with the component, to add or change information
            in the model that can be used later.
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            Removes the specified contributor
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.InitializeContributors">
            <summary>
            Initializes the default contributors.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.Contributors">
            <summary>
            Gets the contributors.
            </summary>
            <value>The contributors.</value>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector">
            <summary>
            Inspects the component configuration and the type looking for a
            definition of component activator type. The configuration preceeds whatever
            is defined in the component.
            </summary>
            <remarks>
            This inspector is not guarantee to always set up an component activator type. 
            If nothing could be found it wont touch the model. In this case is up to
            the kernel to establish a default component activator for components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Searches for the component activator in the configuration and, if unsuccessful
            look for the component activator attribute in the implementation type.
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The model instance</param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromConfiguration(Castle.Core.ComponentModel)">
            <summary>
            Reads the attribute "componentActivatorType" associated with the 
            component configuration and verifies it implements the <see cref="T:Castle.MicroKernel.IComponentActivator"/> 
            interface. 
            </summary>
            <exception cref="T:System.Exception">
            If the type does not implement the proper interface
            </exception>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromType(Castle.Core.ComponentModel)">
            <summary>
            Check if the type expose one of the component activator attributes
            defined in Castle.Core namespace.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ValidateComponentActivator(System.Type)">
            <summary>
            Validates that the provide type implements IComponentActivator
            </summary>
            <param name="customComponentActivator">The custom component activator.</param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector">
            <summary>
            Inspects the component configuration and type looking for information
            that can influence the generation of a proxy for that component.
            <para>
            We specifically look for <c>useSingleInterfaceProxy</c> and <c>marshalByRefProxy</c> 
            on the component configuration or the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> 
            attribute.
            </para>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Searches for proxy behavior in the configuration and, if unsuccessful
            look for the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> attribute in 
            the implementation type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ReadProxyBehavior(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Reads the proxy behavior associated with the 
            component configuration/type and applies it to the model.
            </summary>
            <exception cref="T:System.Exception">
            If the conversion fails
            </exception>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.GetProxyBehaviorFromType(System.Type)">
            <summary>
            Returns a <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> instance if the type
            uses the attribute. Otherwise returns null.
            </summary>
            <param name="implementation"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector">
            <summary>
            Uses the ConfigurationStore registered in the kernel to obtain
            an <see cref="T:Castle.Core.Configuration.IConfiguration"/> associated with the component.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Queries the kernel's ConfigurationStore for a configuration
            associated with the component name.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector">
            <summary>
            Check for a node 'parameters' within the component 
            configuration. For each child it, a ParameterModel is created
            and added to ComponentModel's Parameters collection
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Inspect the configuration associated with the component
            and populates the parameter model collection accordingly
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConstructorDependenciesModelInspector">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
            collects all available constructors and populates them in the model
            as candidates. The Kernel will pick up one of the candidates
            according to a heuristic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ExtendedPropertiesConstants">
            <summary>
            Only to hold internal constants and get rid of 
            magic numbers and hardcode names.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.InterceptorInspector">
            <summary>
            Inspect the component for <c>InterceptorAttribute</c> and
            the configuration for the interceptors node
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector">
            <summary>
            Inspects the type looking for interfaces that constitutes
            lifecycle interfaces, defined in the Castle.Model namespace.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Checks if the type implements <see cref="T:Castle.Core.IInitializable"/> and or
            <see cref="T:System.IDisposable"/> interfaces.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector">
            <summary>
            Inspects the component configuration and the type looking for a
            definition of lifestyle type. The configuration preceeds whatever
            is defined in the component.
            </summary>
            <remarks>
            This inspector is not guarantee to always set up an lifestyle type. 
            If nothing could be found it wont touch the model. In this case is up to
            the kernel to establish a default lifestyle for components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Searches for the lifestyle in the configuration and, if unsuccessful
            look for the lifestyle attribute in the implementation type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromConfiguration(Castle.Core.ComponentModel)">
            <summary>
            Reads the attribute "lifestyle" associated with the 
            component configuration and tries to convert to <see cref="T:Castle.Core.LifestyleType"/>  
            enum type. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromType(Castle.Core.ComponentModel)">
            <summary>
            Check if the type expose one of the lifestyle attributes
            defined in Castle.Model namespace.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector">
            <summary>
            Base for inspectors that want configuration associated with methods.
            For each child a <see cref="T:Castle.Core.MethodMetaModel"/> is created
            and added to ComponentModel's methods collection
            </summary>
            <remarks>
            Implementors should override the <see cref="M:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector.ObtainNodeName"/> return
            the name of the node to be inspected. For example:
            <code>
            <![CDATA[
              <transactions>
                <method name="Save" transaction="requires" />
              </transactions>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
            collects all potential writable public properties exposed by the component 
            implementation and populates the model with them.
            The Kernel might be able to set some of these properties when the component 
            is requested.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Adds the properties as optional dependencies of this component.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.Core.ComponentModel">
            <summary>
            Represents the collection of information and
            meta information collected about a component.
            </summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.extended">
            <summary>Extended properties</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.dependencies">
            <summary>Dependencies the kernel must resolve</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.constructors">
            <summary>All available constructors</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.properties">
            <summary>All potential properties that can be setted by the kernel</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.lifecycle">
            <summary>Steps of lifecycle</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.parameters">
            <summary>External parameters</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.interceptors">
            <summary>Interceptors associated</summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.customDependencies">
            <summary>/// Custom dependencies/// </summary>
        </member>
        <member name="M:Castle.Core.ComponentModel.#ctor(System.String,System.Type,System.Type)">
            <summary>
            Constructs a ComponentModel
            </summary>
        </member>
        <member name="M:Castle.Core.ComponentModel.Requires(System.Predicate{Castle.Core.PropertySet}[])">
            <summary>
            Requires the selected property dependencies.
            </summary>
            <param name="selectors">The property selector.</param>
        </member>
        <member name="M:Castle.Core.ComponentModel.Requires``1">
            <summary>
            Requires the property dependencies of type <typeparamref name="D"/>.
            </summary>
            <typeparam name="D">The dependency type.</typeparam>
        </member>
        <member name="P:Castle.Core.ComponentModel.Name">
            <summary>
            Sets or returns the component key
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.Service">
            <summary>
            Gets or sets the service exposed.
            </summary>
            <value>The service.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Implementation">
            <summary>
            Gets or sets the component implementation.
            </summary>
            <value>The implementation.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.RequiresGenericArguments">
            <summary>
            Gets or sets a value indicating whether the component requires generic arguments.
            </summary>
            <value>
            <c>true</c> if generic arguments are required; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.ComponentModel.ExtendedProperties">
            <summary>
            Gets or sets the extended properties.
            </summary>
            <value>The extended properties.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Constructors">
            <summary>
            Gets the constructors candidates.
            </summary>
            <value>The constructors.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Properties">
            <summary>
            Gets the properties set.
            </summary>
            <value>The properties.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Configuration">
            <summary>
            Gets or sets the configuration.
            </summary>
            <value>The configuration.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Lifecycle">
            <summary>
            Gets the lifecycle steps.
            </summary>
            <value>The lifecycle steps.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.LifestyleType">
            <summary>
            Gets or sets the lifestyle type.
            </summary>
            <value>The type of the lifestyle.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.InspectionBehavior">
            <summary>
            Gets or sets the strategy for
            inspecting public properties 
            on the components
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomLifestyle">
            <summary>
            Gets or sets the custom lifestyle.
            </summary>
            <value>The custom lifestyle.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomComponentActivator">
            <summary>
            Gets or sets the custom component activator.
            </summary>
            <value>The custom component activator.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Interceptors">
            <summary>
            Gets the interceptors.
            </summary>
            <value>The interceptors.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Parameters">
            <summary>
            Gets the parameter collection.
            </summary>
            <value>The parameters.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Dependencies">
            <summary>
            Dependencies are kept within constructors and
            properties. Others dependencies must be 
            registered here, so the kernel (as a matter 
            of fact the handler) can check them
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomDependencies">
            <summary>
            Gets the custom dependencies.
            </summary>
            <value>The custom dependencies.</value>
        </member>
        <member name="T:Castle.Core.ConstructorCandidate">
            <summary>
            Represents a constructor of the component 
            that the container can use to initialize it properly.
            </summary>
        </member>
        <member name="M:Castle.Core.ConstructorCandidate.#ctor(System.Reflection.ConstructorInfo,Castle.Core.DependencyModel[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ConstructorCandidate"/> class.
            </summary>
            <param name="constructorInfo">The constructor info.</param>
            <param name="dependencies">The dependencies.</param>
        </member>
        <member name="P:Castle.Core.ConstructorCandidate.Constructor">
            <summary>
            Gets the ConstructorInfo (from reflection).
            </summary>
            <value>The constructor.</value>
        </member>
        <member name="P:Castle.Core.ConstructorCandidate.Dependencies">
            <summary>
            Gets the dependencies this constructor candidate exposes.
            </summary>
            <value>The dependencies.</value>
        </member>
        <member name="T:Castle.Core.ConstructorCandidateCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.ConstructorCandidate"/>
            </summary>
        </member>
        <member name="P:Castle.Core.ConstructorCandidateCollection.FewerArgumentsCandidate">
            <summary>
            Gets the fewer arguments candidate.
            </summary>
            <value>The fewer arguments candidate.</value>
        </member>
        <member name="T:Castle.Core.DependencyModelCollection">
            <summary>
              Collection of <see cref="T:Castle.Core.DependencyModel"/>.
            </summary>
        </member>
        <member name="T:Castle.Core.InterceptorReference">
            <summary>
              Represents an reference to a Interceptor component.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IReference`1">
            <summary>
            Represents obtained just in time object.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Castle.MicroKernel.IReference`1.Resolve(Castle.MicroKernel.IKernel,Castle.MicroKernel.Context.CreationContext)">
            <summary>
            Resolves object referenced by this reference, optionally using provided <paramref name="kernel"/>.
            If object is resolved from the kernel, the <paramref name="context"/> should be used to guard
            against against cyclic dependencies.
            </summary>
            <param name="kernel"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IReference`1.Attach(Castle.Core.DependencyModelCollection)">
            <summary>
            If the reference introduces dependency on a component, should return <see cref="T:Castle.Core.DependencyModel"/> for that dependency, otherwise <c>null</c>.
            </summary>
            <param name="dependencies"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.InterceptorReference.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference"/> class.
            </summary>
            <param name="componentKey">The component key.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReference.#ctor(System.Type)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference"/> class.
            </summary>
            <param name="serviceType">Type of the service.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForKey(System.String)">
            <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the component key.
            </summary>
            <param name="key">The component key.</param>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForType(System.Type)">
            <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the service.
            </summary>
            <param name="service">The service.</param>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForType``1">
            <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the service.
            </summary>
            <typeparam name="T">The service type.</typeparam>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="T:Castle.Core.InterceptorReferenceCollection">
            <summary>
              Collection of <see cref="T:Castle.Core.InterceptorReference"/>
            </summary>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddFirst(Castle.Core.InterceptorReference)">
            <summary>
              Adds the specified interceptor as the first.
            </summary>
            <param name = "item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddIfNotInCollection(Castle.Core.InterceptorReference)">
            <summary>
              Adds the interceptor to the end of the interceptors list if it does not exist already.
            </summary>
            <param name = "interceptorReference">The interceptor reference.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddLast(Castle.Core.InterceptorReference)">
            <summary>
              Adds the specified interceptor as the last.
            </summary>
            <param name = "item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.Insert(System.Int32,Castle.Core.InterceptorReference)">
            <summary>
              Inserts the specified interceptor at the specified index.
            </summary>
            <param name = "index">The index.</param>
            <param name = "item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.Add(Castle.Core.InterceptorReference)">
            <summary>
              Adds the specified item.
            </summary>
            <param name = "item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.GetEnumerator">
            <summary>
              Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
              An <see cref = "T:System.Collections.IEnumerator" />
              that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.Core.InterceptorReferenceCollection.HasInterceptors">
            <summary>
              Gets a value indicating whether this instance has interceptors.
            </summary>
            <value>
              <c>true</c> if this instance has interceptors; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.InterceptorReferenceCollection.Count">
            <summary>
              Gets the number of
              elements contained in the <see cref = "T:System.Collections.ICollection" />.
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.Core.LifecycleConcernsCollection">
            <summary>
            Represents a collection of ordered lifecycle concerns.
            </summary>
        </member>
        <member name="P:Castle.Core.LifecycleConcernsCollection.CommissionConcerns">
            <summary>
            Returns all concerns for the commission phase
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.LifecycleConcernsCollection.DecommissionConcerns">
            <summary>
            Returns all concerns for the decommission phase
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.LifecycleConcernsCollection.HasCommissionConcerns">
            <summary>
            Gets a value indicating whether this instance has commission steps.
            </summary>
            <value>
            	<c>true</c> if this instance has commission steps; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.LifecycleConcernsCollection.HasDecommissionConcerns">
            <summary>
            Gets a value indicating whether this instance has decommission steps.
            </summary>
            <value>
            	<c>true</c> if this instance has decommission steps; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.Core.MethodMetaModel">
            <summary>
            Represents meta information associated with a method
            (not yet defined)
            </summary>
        </member>
        <member name="M:Castle.Core.MethodMetaModel.#ctor(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.MethodMetaModel"/> class.
            </summary>
            <param name="configNode">The config node.</param>
        </member>
        <member name="P:Castle.Core.MethodMetaModel.ConfigNode">
            <summary>
            Gets the config node.
            </summary>
            <value>The config node.</value>
        </member>
        <member name="T:Castle.Core.MethodMetaModelCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.MethodMetaModel"/>
            </summary>
        </member>
        <member name="P:Castle.Core.MethodMetaModelCollection.MethodInfo2Model">
            <summary>
            Gets the method info2 model.
            </summary>
            <value>The method info2 model.</value>
        </member>
        <member name="T:Castle.Core.ParameterModel">
            <summary>
            Represents a parameter. Usually the parameter
            comes from the external world, ie, an external configuration.
            </summary>
        </member>
        <member name="M:Castle.Core.ParameterModel.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModel.#ctor(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:Castle.Core.ParameterModel.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Castle.Core.ParameterModel.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Castle.Core.ParameterModel.ConfigValue">
            <summary>
            Gets the config value.
            </summary>
            <value>The config value.</value>
        </member>
        <member name="T:Castle.Core.ParameterModelCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.ParameterModel"/>
            </summary>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,System.String)">
            <summary>
            Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="configNode">The config node.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Contains(System.Object)">
            <summary>
            Determines whether this collection contains the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns>
            <c>true</c> if yes; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.Object,System.Object)">
            <summary>
            Adds the specified key.
            </summary>
            <remarks>
            Not implemented
            </remarks>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Clear">
            <summary>
            Clears this instance.
            </summary>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Remove(System.Object)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy the content to the specified array
            </summary>
            <param name="array">target array</param>
            <param name="index">target index</param>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Values">
            <summary>
            Gets the values.
            </summary>
            <value>The values.</value>
            <remarks>
            Not implemented
            </remarks>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value>
            	<c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.IsFixedSize">
            <summary>
            Gets a value indicating whether this instance is fixed size.
            </summary>
            <value>
            	<c>true</c> if this instance is fixed size; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Castle.Core.ParameterModel"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Count">
            <summary>
            Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.SyncRoot">
            <summary>
            Gets the sync root.
            </summary>
            <value>The sync root.</value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.IsSynchronized">
            <summary>
            Gets a value indicating whether this instance is synchronized.
            </summary>
            <value>
            	<c>true</c> if this instance is synchronized; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.Core.PropertySet">
            <summary>
            Represents a property and the respective dependency.
            </summary>
        </member>
        <member name="M:Castle.Core.PropertySet.#ctor(System.Reflection.PropertyInfo,Castle.Core.DependencyModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PropertySet"/> class.
            </summary>
            <param name="propertyInfo">The property info.</param>
            <param name="dependency">The dependency.</param>
        </member>
        <member name="P:Castle.Core.PropertySet.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.Core.PropertySet.Dependency">
            <summary>
            Gets the dependency.
            </summary>
            <value>The dependency.</value>
        </member>
        <member name="T:Castle.Core.PropertySetCollection">
            <summary>
            Collection of <see cref="T:Castle.Core.PropertySet"/>
            </summary>
        </member>
        <member name="M:Castle.Core.PropertySetCollection.FindByPropertyInfo(System.Reflection.PropertyInfo)">
            <summary>
            Finds a PropertySet the by PropertyInfo.
            </summary>
            <param name="info">The info.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.ComponentReference`1">
            <summary>
            Reference to component obtained from a container.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.IModelInterceptorsSelector">
            <summary>
            Select the appropriate interceptors based on the application specific
            business logic
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IModelInterceptorsSelector.HasInterceptors(Castle.Core.ComponentModel)">
            <summary>
            Determine whatever the specified has interceptors.
            The selector should only return true from this method if it has determined that is
            a model that it would likely add interceptors to.
            </summary>
            <param name="model">The model</param>
            <returns>Whatever this selector is likely to add interceptors to the specified model</returns>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IModelInterceptorsSelector.SelectInterceptors(Castle.Core.ComponentModel,Castle.Core.InterceptorReference[])">
            <summary>
            Select the appropriate interceptor references.
            The interceptor references aren't necessarily registered in the model.Intereceptors
            </summary>
            <param name="model">The model to select the interceptors for</param>
            <param name="interceptors">The interceptors selected by previous selectors in the pipeline or <see cref="P:Castle.Core.ComponentModel.Interceptors"/> if this is the first interceptor in the pipeline.</param>
            <returns>The interceptor for this model (in the current context) or a null reference</returns>
            <remarks>
            If the selector is not interested in modifying the interceptors for this model, it 
            should return <paramref name="interceptors"/> and the next selector in line would be executed.
            If the selector wants no interceptors to be used it can either return <c>null</c> or empty array.
            However next interceptor in line is free to override this choice.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.InstanceReference`1">
            <summary>
            Represents a reference to an existing object.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Castle.MicroKernel.IProxyFactory">
            <summary>
            Defines the contract used by the kernel 
            to obtain proxies for components. The implementor
            must return a proxied instance that dispatch 
            the invocation to the registered interceptors in the model
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])">
            <summary>
            Implementors must create a proxy based on 
            the information exposed by ComponentModel
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
            <param name="instance">The component instance to be proxy (only required in some cases)</param>
            <param name="constructorArguments">array of parameters to the constructor (if any)</param>
            <param name="context">The creation context</param>
            <returns>proxy instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.RequiresTargetInstance(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Implementor should check the component model
            and determine if the caller must pass on the component 
            instance to the proxy
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
            <returns><c>true</c> if an instance must be passed to <see cref="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.AddInterceptorSelector(Castle.MicroKernel.Proxy.IModelInterceptorsSelector)">
            <summary>
            Add the selector to the list of selectors that can affect interceptor's decisions
            in the container.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.ShouldCreateProxy(Castle.Core.ComponentModel)">
            <summary>
            Determines whatever we need to create a proxy for this model
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.NotSupportedProxyFactory">
            <summary>
            This is a placeholder implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>.
            </summary>
            <remarks>
            The decision to supply no implementation for <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            is supported by the fact that the MicroKernel should be a thin
            assembly with the minimal set of features, although extensible.
            Providing the support for this interface would obligate 
            the user to import another assembly, even if the large majority of
            simple cases, no use use of interceptors will take place.
            If you want to use however, see the Windsor container.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyConstants">
            <summary>
            Holds the keys used by the proxy factories.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Proxy.ProxyConstants.ProxyOptionsKey">
            <summary>
            Key used to supply custom proxy options.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyOptions">
            <summary>
              Represents options to configure proxies.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.#ctor(Castle.Core.DependencyModelCollection)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Proxy.ProxyOptions"/> class.
            </summary>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddAdditionalInterfaces(System.Type[])">
            <summary>
              Adds the additional interfaces to proxy.
            </summary>
            <param name = "interfaces">The interfaces.</param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddMixIns(System.Object[])">
            <summary>
              Adds the additional mix ins to integrate.
            </summary>
            <param name = "mixIns">The mix ins.</param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddMixinReference(Castle.MicroKernel.IReference{System.Object})">
            <summary>
              Adds the additional mix in to integrate.
            </summary>
            <param name = "mixIn">The mix in.</param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.Equals(System.Object)">
            <summary>
            Equals the specified obj.
            </summary>
            <param name = "obj">The obj.</param>
            <returns>true if equal.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.GetHashCode">
            <summary>
              Gets the hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.AdditionalInterfaces">
            <summary>
              Gets the additional interfaces to proxy.
            </summary>
            <value>The interfaces.</value>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.AllowChangeTarget">
            <summary>
              Determines if the proxied component can change targets.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.UseMarshalByRefAsBaseClass">
            <summary>
              Determines if the interface proxied component should inherit 
              from <see cref="T:System.MarshalByRefObject"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.Hook">
            <summary>
              Gets or sets the proxy hook.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.MixIns">
            <summary>
              Gets the mix ins to integrate.
            </summary>
            <value>The interfaces.</value>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.OmitTarget">
            <summary>
              Determines if the proxied component uses a target.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.Selector">
            <summary>
              Gets or sets the interceptor selector.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.UseSingleInterfaceProxy">
            <summary>
              Determines if the proxied component should only include
              the service interface.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyUtil">
            <summary>
            Helper support for proxy configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyUtil.ObtainProxyOptions(Castle.Core.ComponentModel,System.Boolean)">
            <summary>
            Obtains the <see cref="T:Castle.MicroKernel.Proxy.ProxyOptions"/> associated with the <see cref="T:Castle.Core.ComponentModel"/>.
            </summary>
            <param name="model">The component model.</param>
            <param name="createOnDemand">true if the options should be created if not present.</param>
            <returns>The associated proxy options for the component model.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AttributeDescriptor`1.#ctor(System.String,System.String)">
            <summary>
            Constructs the <see cref="T:Castle.MicroKernel.Registration.AttributeDescriptor`1"/> descriptor with name and value.
            </summary>
            <param name="name">The attribute name.</param>
            <param name="value">The attribute value.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AttributeKeyDescriptor`1.#ctor(Castle.MicroKernel.Registration.ComponentRegistration{`0},System.String)">
            <summary>
            Constructs the <see cref="T:Castle.MicroKernel.Registration.AttributeKeyDescriptor`1"/> descriptor with name.
            </summary>
            <param name="component">The component.</param>
            <param name="name">The attribute name.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AttributeKeyDescriptor`1.Eq(System.Object)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.AttributeKeyDescriptor`1"/> with value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Component">
            <summary>
            Factory for creating <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration"/> objects.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Type)">
            <summary>
            Creates a component registration for the <paramref name="serviceType"/>
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Type[])">
            <summary>
            Creates a component registration for the <paramref name="serviceTypes"/>
            </summary>
            <param name="serviceTypes">Types of the service.</param>
            <returns>The component registration.</returns>B
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Creates a component registration for the <paramref name="serviceTypes"/>
            </summary>
            <param name="serviceTypes">Types of the service.</param>
            <returns>The component registration.</returns>B
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``1">
            <summary>
            Creates a component registration for the service type.
            </summary>
            <typeparam name="S">The service type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(Castle.Core.ComponentModel)">
            <summary>
            Create a component registration for an existing <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="model">The component model.</param>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsCastleComponent(System.Type)">
            <summary>
            Determines if the component is a Castle component, that is - if it has a <see cref="T:Castle.Core.CastleComponentAttribute"/>.
            </summary>
            <returns>true if the service is a Castle Component.</returns>
            <remarks>
            This method is usually used as argument for <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.If(Castle.MicroKernel.Registration.ComponentFilter)"/> method.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInNamespace(System.String)">
            <summary>
            Creates a predicate to check if a component is in a namespace.
            </summary>
            <param name="namespace">The namespace.</param>
            <returns>true if the component type is in the namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInNamespace(System.String,System.Boolean)">
            <summary>
            Creates a predicate to check if a component is in a namespace.
            </summary>
            <param name="namespace">The namespace.</param>
            <param name="includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component type is in the namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs(System.Type)">
            <summary>
            Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <param name="type">The component type to test namespace against.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <param name="type">The component type to test namespace against.</param>
            <param name="includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs``1">
            <summary>
            Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <typeparam name="T">The component type to test namespace against.</typeparam>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <typeparam name="T">The component type to test namespace against.</typeparam>
            <param name="includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.ServiceAlreadyRegistered(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Determines if the component service is already registered.
            </summary>
            <param name="kernel">The kernel.</param>
            <param name="model">The component model.</param>
            <returns>true if the service is already registered.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``2">
            <summary>
            Creates a component registration for the service types.
            </summary>
            <typeparam name="S">The primary service type.</typeparam>
            <typeparam name="F">The forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``3">
            <summary>
            Creates a component registration for the service types.
            </summary>
            <typeparam name="S">The primary service type.</typeparam>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``4">
            <summary>
            Creates a component registration for the service types.
            </summary>
            <typeparam name="S">The primary service type.</typeparam>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <typeparam name="F3">The third forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``5">
            <summary>
            Creates a component registration for the service types.
            </summary>
            <typeparam name="S">The primary service type.</typeparam>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <typeparam name="F3">The third forwarded type.</typeparam>
            <typeparam name="F4">The fourth forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert(System.Collections.IDictionary,System.String,System.Object)">
            <summary>
            Inserts a new named argument with given key. If an argument for this name already exists, it will be overwritten.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert(System.Collections.IDictionary,System.Type,System.Object)">
            <summary>
            Inserts a new typed argument with given type. If an argument for this type already exists, it will be overwritten.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert``1(System.Collections.IDictionary,``0)">
            <summary>
            Inserts a new typed argument with given type. If an argument for this type already exists, it will be overwritten.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert(System.Collections.IDictionary,System.Object)">
            <summary>
            Inserts a set of typed arguments. Property names of the anonymous type will be used as key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert(System.Collections.IDictionary,System.Object[])">
            <summary>
            Inserts a set of typed arguments. Actual type of the arguments will be used as key.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComponentFilter">
            <summary>
            Delegate to filter component registration.
            </summary>
            <param name="kernel">The kernel.</param>
            <param name="model">The component model.</param>
            <returns>true if accepted.</returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComponentRegistration`1">
            <summary>
            Registration for a single type as a component with the kernel.
            <para/>
            You can create a new registration with the <see cref="T:Castle.MicroKernel.Registration.Component"/> factory.
            </summary>
            <typeparam name="TService">The service type</typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.IRegistration">
            <summary>
            The contract for all registrations with the kernel.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.IRegistration.Register(Castle.MicroKernel.IKernel)">
            <summary>
            Performs the registration in the <see cref="T:Castle.MicroKernel.IKernel"/>.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.#ctor(Castle.Core.ComponentModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/> class
            with an existing <see cref="T:Castle.Core.ComponentModel"/>.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ActAs(System.Object[])">
            <summary>
            Marks the components with one or more actors.
            </summary>
            <param name="actors">The component actors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Activator``1">
            <summary>
            Set a custom <see cref="T:Castle.MicroKernel.IComponentActivator"/> which creates and destroys the component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.AddAttributeDescriptor(System.String,System.String)">
            <summary>
            Adds the attribute descriptor.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.AddDescriptor(Castle.MicroKernel.Registration.ComponentDescriptor{`0})">
            <summary>
            Adds the descriptor.
            </summary>
            <param name="descriptor">The descriptor.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Attribute(System.String)">
            <summary>
            Creates an attribute descriptor.
            </summary>
            <param name="key">The attribute key.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Configuration(Castle.MicroKernel.Registration.Node[])">
            <summary>
            Apply more complex configuration to this component registration.
            </summary>
            <param name="configNodes">The config nodes.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Configuration(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Apply more complex configuration to this component registration.
            </summary>
            <param name="configuration">The configuration <see cref="T:Castle.Core.Configuration.MutableConfiguration"/>.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.CustomDependencies(Castle.MicroKernel.Registration.Property[])">
            <summary>
            Obsolete, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Property[])"/> instead.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.CustomDependencies(System.Collections.IDictionary)">
            <summary>
            Obsolete, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)"/> instead.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.CustomDependencies(System.Object)">
            <summary>
            Obsolete, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)"/> instead.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Property[])">
            <summary>
            Specify custom dependencies using <see cref="M:Castle.MicroKernel.Registration.Property.ForKey(System.String)"/> or <see cref="M:Castle.MicroKernel.Registration.Property.ForKey(System.Type)"/>.
            <para/>
            You can pass <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/>s to specify the components
            this component should be resolved with.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)">
            <summary>
            Uses a dictionary of key/value pairs, to specify custom dependencies.
            <para/>
            Use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Collections.IDictionary)"/> to specify the components
            this component should be resolved with.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)">
            <summary>
            Uses an (anonymous) object as a dictionary, to specify custom dependencies.
            <para/>
            Use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Object)"/> to specify the components
            this component should be resolved with.
            </summary>
            <param name="anonymous">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersDelegate)">
            <summary>
            Allows custom dependencies to by defined dyncamically.
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersResolveDelegate)">
            <summary>
            Allows custom dependencies to by defined dynamically with releasing capability.
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersWithContextResolveDelegate)">
            <summary>
            Allows custom dependencies to by defined dynamically with releasing capability.
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
            <remarks>
            Use <see cref="T:Castle.MicroKernel.Context.CreationContext"/> when resolving components from <see cref="T:Castle.MicroKernel.IKernel"/> in order to detect cycles.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(Castle.MicroKernel.Registration.Property[])">
            <summary>
            Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties"/> for this component.
            </summary>
            <param name="properties">The extended properties.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(System.Object)">
            <summary>
            Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties"/> for this component.
            </summary>
            <param name="anonymous">The extendend properties as key/value pairs.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Type[])">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <param name="types">The types to forward.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``1">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <typeparam name="TSecondService">The forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``2">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <typeparam name="TSecondService">The first forwarded type.</typeparam>
            <typeparam name="TThirdService">The second forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``3">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <typeparam name="TSecondService">The first forwarded type.</typeparam>
            <typeparam name="TThirdService">The second forwarded type.</typeparam>
            <typeparam name="TFourthService">The third forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``4">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <typeparam name="TSecondService">The first forwarded type.</typeparam>
            <typeparam name="TThirdService">The second forwarded type.</typeparam>
            <typeparam name="TFourthService">The third forwarded type.</typeparam>
            <typeparam name="TFifthService">The fourth forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <param name="types">The types to forward.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.If(Castle.MicroKernel.Registration.ComponentFilter)">
            <summary>
            Assigns a conditional predication which must be satisfied.
            <para />
            The component will only be registered into the kernel 
            if this predicate is satisfied (or not assigned at all).
            </summary>
            <param name="ifFilter">The predicate to satisfy.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy``1">
            <summary>
            Sets the concrete type that implements the service to <typeparamref name="TImpl"/>.
            <para/>
            If not set, the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceType"/> will be used as the implementation for this component.
            </summary>
            <typeparam name="TImpl">The type that is the implementation for the service.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type)">
            <summary>
            Sets the concrete type that implements the service to <paramref name="type"/>.
            <para/>
            If not set, the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceType"/> will be used as the implementation for this component.
            </summary>
            <param name="type">The type that is the implementation for the service.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Instance(`0)">
            <summary>
            Assigns an existing instance as the component for this registration.
            </summary>
            <param name="instance">The component instance.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(Castle.Core.InterceptorReference[])">
            <summary>
            Set the interceptors for this component.
            </summary>
            <param name="interceptors">The interceptors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(System.Type[])">
            <summary>
            Set the interceptors for this component.
            </summary>
            <param name="interceptors">The interceptors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors``1">
            <summary>
            Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors``2">
            <summary>
            Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(System.String[])">
            <summary>
            Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)">
            <summary>
            Change the name of this registration. 
            This will be the key for the component in the kernel.
            <para/>
            If not set, the <see cref="P:System.Type.FullName"/> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation"/>
            will be used as the key to register the component.
            </summary>
            <param name="name">The name of this registration.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnCreate(Castle.MicroKernel.LifecycleConcerns.OnCreateActionDelegate{`0}[])">
            <summary>
            Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.OnCreateActionDelegate`1"/> which will be invoked when the component
            is created and before it's returned from the container.
            </summary>
            <param name="actions">A set of actions to be executed right after the component is created and before it's returned from the container.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OverWrite">
            <summary>
            With the overwrite.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Parameters(Castle.MicroKernel.Registration.Parameter[])">
            <summary>
            Set configuration parameters with string or <see cref="T:Castle.Core.Configuration.IConfiguration"/> values.
            </summary>
            <param name="parameters">The parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.SelectInterceptorsWith(Castle.DynamicProxy.IInterceptorSelector)">
            <summary>
            Sets the interceptor selector for this component.
            </summary>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.SelectInterceptorsWith(System.Action{Castle.MicroKernel.Registration.Proxy.ItemRegistration{Castle.DynamicProxy.IInterceptorSelector}})">
            <summary>
            Sets the interceptor selector for this component.
            </summary>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(Castle.MicroKernel.Registration.ServiceOverride[])">
            <summary>
            Override (some of) the services that this component needs.
            Use <see cref="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.String)"/> to create an override.
            <para/>
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
            The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
            <para/>
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Property[])"/>
            </summary>
            <param name="overrides">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Collections.IDictionary)">
            <summary>
            Override (some of) the services that this component needs, using a dictionary.
            <para/>
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
            The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
            <para/>
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)"/>
            </summary>
            <param name="overrides">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Object)">
            <summary>
            Override (some of) the services that this component needs, using an (anonymous) object as a dictionary.
            <para/>
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
            The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
            <para/>
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)"/>
            </summary>
            <param name="anonymous">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Unless(Castle.MicroKernel.Registration.ComponentFilter)">
            <summary>
            Assigns a conditional predication which must not be satisfied. 
            <para />
            The component will only be registered into the kernel 
            if this predicate is not satisfied (or not assigned at all).
            </summary>
            <param name="unlessFilter">The predicate not to satisfy.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactory``2(System.Converter{``0,``1})">
            <summary>
            Uses a factory to instantiate the component
            </summary>
            <typeparam name="U">Factory type. This factory has to be registered in the kernel.</typeparam>
            <typeparam name="V">Implementation type.</typeparam>
            <param name="factory">Factory invocation</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{``0})">
            <summary>
            Uses a factory method to instantiate the component.
            </summary>
            <typeparam name="TImpl">Implementation type</typeparam>
            <param name="factoryMethod">Factory method</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Converter{Castle.MicroKernel.IKernel,``0})">
            <summary>
            Uses a factory method to instantiate the component.
            </summary>
            <typeparam name="TImpl">Implementation type</typeparam>
            <param name="factoryMethod">Factory method</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{Castle.MicroKernel.IKernel,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,``0})">
            <summary>
            Uses a factory method to instantiate the component.
            </summary>
            <typeparam name="TImpl">Implementation type</typeparam>
            <param name="factoryMethod">Factory method</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{Castle.MicroKernel.IKernel,Castle.MicroKernel.Context.CreationContext,``0})">
            <summary>
            Uses a factory method to instantiate the component.
            </summary>
            <typeparam name="TImpl">Implementation type</typeparam>
            <param name="factoryMethod">Factory method</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Castle#MicroKernel#Registration#IRegistration#Register(Castle.MicroKernel.IKernel)">
            <summary>
            Registers this component with the <see cref="T:Castle.MicroKernel.IKernel"/>.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.ForwardedTypes">
            <summary>
            Gets the forwarded service types on behalf of this component.
            <para/>
            Add more types to forward using <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Type[])"/>.
            </summary>
            <value>The types of the forwarded services.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation">
            <summary>
            The concrete type that implements the service.
            <para/>
            To set the implementation, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type)"/>.
            </summary>
            <value>The implementation of the service.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.LifeStyle">
            <summary>
            Set the lifestyle of this component.
            For example singleton and transient (also known as 'factory').
            </summary>
            <value>The with lifestyle.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Name">
            <summary>
            The name of the component. Will become the key for the component in the kernel.
            <para/>
            To set the name, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)"/>.
            <para/>
            If not set, the <see cref="P:System.Type.FullName"/> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation"/>
            will be used as the key to register the component.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Proxy">
            <summary>
            Set proxy for this component.
            </summary>
            <value>The proxy.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceType">
            <summary>
            The type of the service, the same as <typeparamref name="TService"/>.
            <para/>
            This is the first type passed to <see cref="M:Castle.MicroKernel.Registration.Component.For(System.Type)"/>.
            </summary>
            <value>The type of the service.</value>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComponentRegistration">
            <summary>
            A non-generic <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/>.
            <para/>
            You can create a new registration with the <see cref="T:Castle.MicroKernel.Registration.Component"/> factory.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Node">
            <summary>
            Represents a configuration child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Node.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Attrib">
            <summary>
            Represents a configuration attribute.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Attrib.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Attrib.ForName(System.String)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.NamedAttribute"/> with name.
            </summary>
            <param name="name">The attribute name.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.NamedAttribute"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.NamedAttribute">
            <summary>
            Represents a named attribute.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedAttribute.Eq(System.String)">
            <summary>
            Builds the <see cref="T:System.Attribute"/> with name/value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedAttribute.Eq(System.Object)">
            <summary>
            Builds the <see cref="T:System.Attribute"/> with name/value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Child">
            <summary>
            Represents a configuration child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Child.ForName(System.String)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.NamedChild"/> with name.
            </summary>
            <param name="name">The child name.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.NamedChild"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.NamedChild">
            <summary>
            Represents a named child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(System.String)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/> with name/value.
            </summary>
            <param name="value">The child value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(System.Object)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/> with name/value.
            </summary>
            <param name="value">The child value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ComplexChild"/> with name/config.
            </summary>
            <param name="configNode">The child configuration.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ComplexChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(Castle.MicroKernel.Registration.Node[])">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.Child"/> with name/config.
            </summary>
            <param name="childNodes">The child nodes.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.CompoundChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.SimpleChild">
            <summary>
            Represents a simple child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.SimpleChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComplexChild">
            <summary>
            Represents a complex child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComplexChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.CompoundChild">
            <summary>
            Represents a compound child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.CompoundChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.IWindsorInstaller">
            <summary>
            The contract to install components in the container.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.IWindsorInstaller.Install(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
            Performs the installation in the <see cref="T:Castle.Windsor.IWindsorContainer"/>.
            </summary>
            <param name="container">The container.</param>
            <param name="store">The configuration store.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.OnCreateComponentDescriptor`1">
            <summary>
            Adds the actions to ExtendedProperties.
            </summary>
            <typeparam name="S"></typeparam>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Is(Castle.Core.LifestyleType)">
            <summary>
            Sets the lifestyle to the specified <paramref name="type"/>.
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Custom(System.Type)">
            <summary>
            Assign a custom lifestyle type, that implements <see cref="T:Castle.MicroKernel.ILifestyleManager"/>.
            </summary>
            <param name="customLifestyleType">Type of the custom lifestyle.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Custom``1">
            <summary>
            Assign a custom lifestyle type, that implements <see cref="T:Castle.MicroKernel.ILifestyleManager"/>.
            </summary>
            <typeparam name="L">The type of the custom lifestyle</typeparam>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Parameter">
            <summary>
            Represents a configuration parameter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Parameter.ForKey(System.String)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.ParameterKey"/> with key.
            </summary>
            <param name="key">The parameter key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ParameterKey"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.Key">
            <summary>
            Gets the parameter key.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.Value">
            <summary>
            Gets the parameter value.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.ConfigNode">
            <summary>
            Gets the parameter configuration.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ParameterKey">
            <summary>
            Represents a parameter key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ParameterKey.Eq(System.String)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.Parameter"/> with key/value.
            </summary>
            <param name="value">The parameter value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Parameter"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ParameterKey.Eq(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.Parameter"/> with key/config.
            </summary>
            <param name="configNode">The parameter configuration.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Parameter"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ParameterKey.Name">
            <summary>
            The parameter key name.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Property">
            <summary>
            Represents a key/value pair.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Property.ForKey(System.String)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/> with key.
            </summary>
            <param key="key">The property key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Property.ForKey(System.Type)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/> with key.
            </summary>
            <param key="key">The property key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Property.ForKey``1">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/> with key.
            </summary>
            <param key="key">The property key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Property.Key">
            <summary>
            Gets the property key.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Property.Value">
            <summary>
            Gets the property value.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.PropertyKey">
            <summary>
            Represents a property key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Eq(System.Object)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.Property"/> with key/value.
            </summary>
            <param key="value">The property value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Property"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is(System.String)">
            <summary>
            Builds a service override using other component registered with given <paramref name="componentName"/> as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key"/>.
            </summary>
            <param name="componentName"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is(System.Type)">
            <summary>
            Builds a service override using other component registered with given <paramref name="componentImplementation"/> and no explicit name, as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is``1">
            <summary>
            Builds a service override using other component registered with given <typeparam name="TComponentImplementation"/> and no explicit name, as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.PropertyKey.Key">
            <summary>
            The property key key.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceOverride">
            <summary>
            Represents a service override.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.String)">
            <summary>
            Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/> with key.
            </summary>
            <param name="key">The service override key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.Type)">
            <summary>
            Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/> with key.
            </summary>
            <param name="key">The service override key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey``1">
            <summary>
            Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/> with key.
            </summary>
            <typeparam name="TKey">The service override key.</typeparam>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ServiceOverride.Type">
            <summary>
            Gets the optional value type specifier.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceOverrideKey">
            <summary>
            Represents a service override key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.String)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/value.
            </summary>
            <param name="value">The service override value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.String[])">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service override values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq``1(System.String[])">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service override values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service override values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service override values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.AllTypes">
            <summary>
            Describes a set of components to register in the kernel.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Of(System.Type)">
            <summary>
            Describes all the types based on <c>basedOn</c>.
            </summary>
            <param name="basedOn">The base type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Of``1">
            <summary>
            Describes all the types based on type T.
            </summary>
            <typeparam name="T">The base type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Pick">
            <summary>
            Describes any types that are supplied.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyNamed(System.String)">
            <summary>
            Prepares to register types from an assembly.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssembly(System.Reflection.Assembly)">
            <summary>
            Prepares to register types from an assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyContaining(System.Type)">
            <summary>
            Prepares to register types from an assembly containing the type.
            </summary>
            <param name="type">The type belonging to the assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyContaining``1">
            <summary>
            Prepares to register types from an assembly containing the type.
            </summary>
            <typeparam name="T">The type belonging to the assembly.</typeparam>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly">
            <summary>
            Prepares to register types from the assembly containing the code invoking this method.
            </summary>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyInDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
            <summary>
            Prepares to register types from assemblies found in a given directory that meet additional optional restrictions.
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.From(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Pick(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.From(System.Type[])">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.AllTypesOf">
            <summary>
            Describes a related group of components to register in the kernel.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.FromAssemblyNamed(System.String)">
            <summary>
            Prepares to register types from an assembly.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.FromAssembly(System.Reflection.Assembly)">
            <summary>
            Prepares to register types from an assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.From(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.Pick(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.From(System.Type[])">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ConfigureDescriptor">
            <summary>
            Describes a configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.#ctor(Castle.MicroKernel.Registration.BasedOnDescriptor,System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
             Initializes a new instance of the ConfigureDescriptor.
            </summary>
            <param name="basedOn">The <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></param>
            <param name="configurer">The configuration action.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.#ctor(Castle.MicroKernel.Registration.BasedOnDescriptor,System.Type,System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
             Initializes a new instance of the ConfigureDescriptor.
            </summary>
            <param name="basedOn">The <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></param>
            <param name="baseType">The base type to match.</param>
            <param name="configurer">The configuration action.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.Configure(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
            Allows customized configurations of each matching type.
            </summary>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.Configure(Castle.MicroKernel.Registration.ConfigureDelegate)">
            <summary>
            Allows customized configurations of each matching type.
            </summary>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.ConfigureFor``1(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
            Allows customized configurations of each matching type that is 
            assignable to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type assignable from.</typeparam>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.ConfigureFor``1(Castle.MicroKernel.Registration.ConfigureDelegate)">
            <summary>
            Allows customized configurations of each matching type that is 
            assignable to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type assignable from.</typeparam>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.Apply(Castle.MicroKernel.Registration.ComponentRegistration)">
            <summary>
            Performs the component configuration.
            </summary>
            <param name="registration">The component registration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromAssemblyDescriptor">
            <summary>
            Selects a set of types from an assembly.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromDescriptor">
            <summary>
            Describes the source of types to register.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.AllowMultipleMatches">
            <summary>
            Allows a type to be registered multiple times.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn``1">
            <summary>
            Returns the descriptor for accepting a type.
            </summary>
            <typeparam name="T">The base type.</typeparam>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn(System.Type)">
            <summary>
            Returns the descriptor for accepting a type.
            </summary>
            <param name="basedOn">The base type.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.Pick">
            <summary>
            Returns the descriptor for accepting any type from given solutions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.Where(System.Predicate{System.Type})">
            <summary>
            Returns the descriptor for accepting a type based on a condition.
            </summary>
            <param name="accepted">The accepting condition.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromTypesDescriptor">
            <summary>
            Selects an existing set of types to register.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceDescriptor">
            <summary>
            Describes how to select a types service.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Base">
            <summary>
            Uses the base type matched on.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Self">
            <summary>
            Uses the type itself.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.AllInterfaces">
            <summary>
            Uses all interfaces implemented by the type (or its base types) as well as their base interfaces.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.DefaultInterface">
            <summary>
            Uses all interfaces that have names matched by implementation type name.
            Matches Foo to IFoo, SuperFooExtended to IFoo and IFooExtended etc
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FirstInterface">
            <summary>
            Uses the first interface of a type. This method has non-deterministic behavior when type implements more than one interface!
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FromInterface(System.Type)">
            <summary>
            Uses <paramref name="implements"/> to lookup the sub interface.
            For example: if you have IService and 
            IProductService : ISomeInterface, IService, ISomeOtherInterface.
            When you call FromInterface(typeof(IService)) then IProductService
            will be used. Useful when you want to register _all_ your services
            and but not want to specify all of them.
            </summary>
            <param name="implements"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FromInterface">
            <summary>
            Uses base type to lookup the sub interface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Select(Castle.MicroKernel.Registration.ServiceDescriptor.ServiceSelector)">
            <summary>
            Assigns a custom service selection strategy.
            </summary>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Select(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Assigns the supplied service types.
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.WorkaroundCLRBug(System.Type)">
            <summary>
            This is a workaround for a CLR bug in
            which GetInterfaces() returns interfaces
            with no implementations.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ConfigureDelegate">
            <summary>
              Delegate for custom registration configuration.
            </summary>
            <param name = "registration">The component registration.</param>
            <returns>Not used.</returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.BasedOnDescriptor">
            <summary>
              Describes how to register a group of related types.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.#ctor(System.Type,Castle.MicroKernel.Registration.FromDescriptor)">
            <summary>
              Initializes a new instance of the BasedOnDescriptor.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.AllowMultipleMatches">
            <summary>
              Allows a type to be registered multiple times.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.BasedOn``1">
            <summary>
              Returns the descriptor for accepting a new type.
            </summary>
            <typeparam name = "T">The base type.</typeparam>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.BasedOn(System.Type)">
            <summary>
              Returns the descriptor for accepting a new type.
            </summary>
            <param name = "basedOn">The base type.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Configure(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
              Allows customized configurations of each matching type.
            </summary>
            <param name = "configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Configure(Castle.MicroKernel.Registration.ConfigureDelegate)">
            <summary>
              Allows customized configurations of each matching type.
            </summary>
            <param name = "configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureFor``1(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
              Allows customized configurations of each matching type that is 
              assignable to
              <typeparamref name = "T" />
              .
            </summary>
            <typeparam name = "T">The type assignable from.</typeparam>
            <param name = "configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureFor``1(Castle.MicroKernel.Registration.ConfigureDelegate)">
            <summary>
              Allows customized configurations of each matching type that is 
              assignable to
              <typeparamref name = "T" />
              .
            </summary>
            <typeparam name = "T">The type assignable from.</typeparam>
            <param name = "configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.If(System.Predicate{System.Type})">
            <summary>
              Assigns a conditional predication which must be satisfied.
            </summary>
            <param name = "ifFilter">The predicate to satisfy.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Unless(System.Predicate{System.Type})">
            <summary>
              Assigns a conditional predication which must not be satisfied.
            </summary>
            <param name = "unlessFilter">The predicate not to satisify.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Where(System.Predicate{System.Type})">
            <summary>
              Returns the descriptor for accepting a type based on a condition.
            </summary>
            <param name = "accepted">The accepting condition.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.BasedOnDescriptor.InternalBasedOn">
            <summary>
              Gets the type all types must be based on.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.BasedOnDescriptor.WithService">
            <summary>
              Gets the service descriptor.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IReleasePolicy">
            <summary>
            Policy managing lifetime of components, and in particular their release process.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy">
            <summary>
            Only tracks components that have decommission steps
            registered or have pooled lifestyle.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy">
            <summary>
            No tracking of component instances are made.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver">
            <summary>
            Default implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>.
            This implementation is quite simple, but still should be useful
            for 99% of situations. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IDependencyResolver">
            <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.Initialize(Castle.MicroKernel.IKernel,Castle.MicroKernel.DependencyDelegate)">
            <summary>
            This method is called with a delegate for firing the
            IKernelEvents.DependencyResolving event.
            </summary>
            <param name="kernel">kernel</param>
            <param name="resolving">The delegate used to fire the event</param>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Registers a sub resolver instance
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Unregisters a sub resolver instance previously registered
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Initialize(Castle.MicroKernel.IKernel,Castle.MicroKernel.DependencyDelegate)">
            <summary>
              Initializes this instance with the specified dependency delegate.
            </summary>
            <param name="kernel">kernel</param>
            <param name = "dependencyDelegate">The dependency delegate.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
              Registers a sub resolver instance
            </summary>
            <param name = "subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
              Unregisters a sub resolver instance previously registered
            </summary>
            <param name = "subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.CanResolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
              Returns true if the resolver is able to satisfy the specified dependency.
            </summary>
            <param name = "context">Creation context, which is a resolver itself</param>
            <param name = "contextHandlerResolver">Parent resolver</param>
            <param name = "model">Model of the component that is requesting the dependency</param>
            <param name = "dependency">The dependency model</param>
            <returns>
              <c>true</c>
              if the dependency can be satisfied</returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
              Try to resolve the dependency by checking the parameters in 
              the model or checking the Kernel for the requested service.
            </summary>
            <remarks>
              The dependency resolver has the following precedence order:
              <list type="bullet">
                <item>
                  <description>The dependency is checked within the
                    <see cref="T:Castle.MicroKernel.Context.CreationContext"/>
                  </description>
                </item>
                <item>
                  <description>The dependency is checked within the
                    <see cref="T:Castle.MicroKernel.IHandler"/>
                    instance for the component</description>
                </item>
                <item>
                  <description>The dependency is checked within the registered
                    <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/>
                    s</description>
                </item>
                <item>
                  <description>Finally the resolver tries the normal flow 
                    which is using the configuration
                    or other component to satisfy the dependency</description>
                </item>
              </list>
            </remarks>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns>The dependency resolved value or null</returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ExtractComponentKey(System.String,System.String)">
            <summary>
              Extracts the component name from the a ref strings which is
              ${something}
            </summary>
            <param name = "name"></param>
            <param name = "keyValue"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RebuildContextForParameter(Castle.MicroKernel.Context.CreationContext,System.Type)">
            <summary>
              This method rebuild the context for the parameter type.
              Naive implementation.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DependencyResolverException">
            <summary>
            Summary description for DependencyResolverException.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ArrayResolver">
            <summary>
              Handle dependencies of services in the format of typed arrays.
            </summary>
            <remarks>
              This is a complimentary <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/> implementation 
              that is capable of satisfying dependencies of services as typed arrays.
              <para>
                Note that it will take precedence over service override for arrays defined 
                on the configuration.
              </para>
            </remarks>
            <example>
              In order to install the resolver:
              <code>
                var kernel = new DefaultKernel();
                kernel.Resolver.AddSubResolver(new ArrayResolver(kernel));
              </code>
            
              <para>
                To use it, assuming that IService is on the container:
              </para>
            
              <code>
                public class Component
                {
                public Component(IService[] services)
                {
                }
                }
              </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.CollectionResolver">
            <summary>
            More generic alternative to <see cref="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ArrayResolver"/> and <see cref="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ListResolver"/>.
            It supports arrays as well as any generic interface type assignable from arrays.
            </summary>
            <remarks>
            The collection instance that is provided is read only, even for interfaces like <see cref="T:System.Collections.Generic.IList`1"/>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ListResolver">
            <summary>
            Handle dependencies of services in the format of generic IList.
            </summary>
            <remarks>
            This is a complimentary <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/> implementation 
            that is capable of satisfying dependencies of services generic IList.
            <para>
            Note that it will take precedence over service override for lists defined 
            on the configuration.
            </para>
            </remarks>
            <example>
            In order to install the resolver:
            <code>
            var kernel = new DefaultKernel();
            kernel.Resolver.AddSubResolver(new ListResolver(kernel));
            </code>
            
            <para>
            To use it, assuming that IService is on the container:
            </para>
            
            <code>
            public class Component
            {
                public Component(IList&lt;IService&gt; services)
                {
                }
            }
            </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.ISubSystem">
            <summary>
            A subsystem is used by the MicroKernel to deal 
            with a specific concern.  
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the subsystem
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Terminate">
            <summary>
            Should perform the termination
            of the subsystem instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/>
            does not try to obtain an external configuration by any means.
            Its only purpose is to serve as a base class for subclasses
            that might obtain the configuration node from anywhere.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore">
            <summary>
            The contract used by the kernel to obtain
            external configuration for the components and
            facilities.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a facility key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddBootstrapComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a  configuration node with a bootstrap component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Adds the child container configuration.
            </summary>
            <param name="name">The container's name.</param>
            <param name="config">The config.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetChildContainerConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified child container key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified facility key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetBootstrapComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetFacilities">
            <summary>
            Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetComponents">
            <summary>
            Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetInstallers">
            <summary>
            Returns all configuration nodes for installers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetBootstrapComponents">
            <summary>
            Returns all configuration nodes for bootstrap components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetConfigurationForChildContainers">
            <summary>
            Gets the child containers configuration nodes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetResource(System.String,Castle.Core.Resource.IResource)">
            <summary>
            
            </summary>
            <param name="resourceUri"></param>
            <param name="resource"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a facility key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddBootstrapComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a bootstrap component key
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Adds the child container configuration.
            </summary>
            <param name="key">The key.</param>
            <param name="config">The config.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with
            the specified facility key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetChildContainerConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with
            the specified child container key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetBootstrapComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilities">
            <summary>
            Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetBootstrapComponents">
            <summary>
            Returns all configuration nodes for bootstrap components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetConfigurationForChildContainers">
            <summary>
            Returns all configuration nodes for child containers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponents">
            <summary>
            Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter">
            <summary>
            Base implementation of <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter">
            <summary>
            Implements a conversion logic to a type of a
            set of types. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type with the specified 
            configuration
            </summary>
            <param name="type"></param>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(System.String,System.Type)">
            <summary>
            Should perform the conversion from the
            string representation specified to the type
            specified.
            </summary>
            <param name="value"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
            <summary>
            Should perform the conversion from the
            configuration node specified to the type
            specified.
            </summary>
            <param name="configuration"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type with the specified
            configuration
            </summary>
            <param name="type"></param>
            <param name="configuration"></param>
            <returns></returns>
            <remarks>
            The default behavior is to just pass it to the normal CanHadnleType
            peeking into the configuration is used for some advanced functionality
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException">
            <summary>
            Summary description for ConverterException.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.AttributeAwareConverter">
            <summary>
            Looks for a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute"/> on the type to be converted. 
            If found, the TypeConverter defined by the attribute is used to perform the conversion.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IKernelDependentConverter">
            <summary>
            Marker interface that signals that a converter
            depends on IKernel to be able to perform 
            the conversion.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ComponentModelConverter">
            <summary>
            Attempts to utilize an existing <see cref="T:System.ComponentModel.TypeConverter"/> for conversion
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.CreateInstance(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Creates the target type instance.
            </summary>
            <param name="type">The type.</param>
            <param name="configuration">The configuration.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ChooseConstructor(System.Type)">
            <summary>
            Chooses the first non default constructor. Throws an exception if more than 
            one non default constructor is found
            </summary>
            <param name="type"></param>
            <returns>The chosen constructor, or <c>null</c> if none was found</returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertConstructorParameters(System.Reflection.ConstructorInfo,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Converts the constructor parameters.
            </summary>
            <param name="constructor">The constructor.</param>
            <param name="configuration">The configuration.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertPropertyValues(System.Object,System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Converts the property values.
            </summary>
            <param name="instance">The instance.</param>
            <param name="type">The type.</param>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.FindChildIgnoreCase(Castle.Core.Configuration.IConfiguration,System.String)">
            <summary>
            Finds the child (case insensitive).
            </summary>
            <param name="config">The config.</param>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConversionManager">
            <summary>
            Gets the conversion manager.
            </summary>
            <value>The conversion manager.</value>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.EnumConverter">
            <summary>
            Converts a string representation to an enum value
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.GenericDictionaryConverter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.GenericDictionaryConverter"/> class.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IGenericCollectionConverterHelper">
            <summary>
            This interface is needed because we want to isolate ourself from
            the generic parameters, so we can work type safe inside the implementations,
            and still call from non generic types outside.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.PrimitiveConverter">
            <summary>
            Implements all standard conversions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.TypeNameConverter">
            <summary>
            Convert a type name to a Type instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute">
            <summary>
            Declares a type as being convertible by a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/> and optionally defines the converter to be used
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor">
            <summary>
            Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter"/> to be used to convert the type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor(System.Type)">
            <summary>
            Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/> to be used to convert the type
            </summary>
            <param name="converterType"></param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.DefaultConversionManager">
            <summary>
            Composition of all available conversion managers
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IConversionManager">
            <summary>
            Establish a composition interface and a subsystem.
            Implementors should delegate the conversion to 
            a instance of a type converter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.IConversionManager.Add(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter)">
            <summary>
            Register a type converter instance.
            </summary>
            <param name="converter"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.BinaryTreeComponentName.FindSuccessor(Castle.MicroKernel.SubSystems.Naming.TreeNode)">
            <summary>
            Method finds the next biggest node
            It assumes Add puts lesser nodes on the right
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.left">
            <summary>Node's left</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.right">
            <summary>Node's right</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.parent">
            <summary>Node's parent</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.nextSibling">
            <summary>DA Linked List</summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String)">
            <summary>
            Creates a ComponentName using a name pattern like
            "service:key=value,key2=value2"
            </summary>
            <param name="name">Complete name</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String,System.String)">
            <summary>
            Creates a ComponentName with specified service and 
            properties.
            </summary>
            <param name="service">Service name</param>
            <param name="properties">Property list.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.Setup(System.String)">
            <summary>
            Parses the full name extracting the service and properties.
            </summary>
            <param name="name">Full name.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupService(System.String)">
            <summary>
            Sets up the service. Can be empty but can't be null.
            </summary>
            <param name="service"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.String)">
            <summary>
            Parses and validate a properties list string like 
            "key=value,key2=value2" and so on.
            </summary>
            <param name="properties">Property list.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Validates a properties IDictionary.
            </summary>
            <param name="properties">Property list.</param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem">
            <summary>
            Default <see cref="T:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem"/> implementation.
            Keeps services map as a simple hash table.
            Keeps key map as a list dictionary to maintain order.
            Does not support a query string.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem">
            <summary>
            Contract for SubSystem that wishes to keep and coordinate
            component registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.AddHandlerSelector(Castle.MicroKernel.IHandlerSelector)">
            <summary>
            Register a new component resolver that can take part in the decision
            making about which handler to resolve
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Contains(System.String)">
            <summary>
            Returns true if there is a component registered 
            for the specified key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Contains(System.Type)">
            <summary>
            Returns true if there is a component registered 
            for the specified service
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetAssignableHandlers(System.Type)">
            <summary>
            Return <see cref="T:Castle.MicroKernel.IHandler"/>s where components are compatible
            with the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandler(System.String)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandler(System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified service.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandler(System.String,System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified key with the service type.
            <remarks>
            It is expected that this will be used mainly to resolve a generic service
            by its key.
            </remarks>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandlers(System.String)">
            <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> that
            satisfies the specified query.
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandlers(System.Type)">
            <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandlers">
            <summary>
            Returns all <see cref="T:Castle.MicroKernel.IHandler"/> registered.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetKey2Handler">
            <summary>
            List of handler by key
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetService2Handler">
            <summary>
            List of handler by service
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Register(System.String,Castle.MicroKernel.IHandler)">
            <summary>
            Implementors should register the key and service pointing 
            to the specified handler
            </summary>
            <param name="key"></param>
            <param name="handler"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.UnRegister(System.String)">
            <summary>
            Unregister the handler by the given key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.UnRegister(System.Type)">
            <summary>
            Unregister the handler by the given service
            </summary>
            <param name="service"></param>
        </member>
        <member name="P:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.ComponentCount">
            <summary>
            Returns the number of components registered.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Item(System.Type)">
            <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler"/> with 
            the specified service
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Item(System.String)">
            <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler"/> with
            the specified key
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.key2Handler">
            <summary>
            Map(String, IHandler) to map component keys
            to <see cref="T:Castle.MicroKernel.IHandler"/>
            Items in this dictionary are sorted in insertion order.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.service2Handler">
            <summary>
            Map(Type, IHandler) to map a service
            to <see cref="T:Castle.MicroKernel.IHandler"/>.
            If there is more than a single service of the type, only the first
            registered services is stored in this dictionary.
            It serve as a fast lookup for the common case of having a single handler for 
            a type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem"/> class.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandlerSelector">
            <summary>
            Implementors of this interface allow to extend the way the container perform
            component resolution based on some application specific business logic.
            </summary>
            <remarks>
            This is the sibling interface to <seealso cref="T:Castle.MicroKernel.ISubDependencyResolver"/>.
            This is dealing strictly with root components, while the <seealso cref="T:Castle.MicroKernel.ISubDependencyResolver"/> is dealing with
            dependent components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IHandlerSelector.HasOpinionAbout(System.String,System.Type)">
            <summary>
            Whatever the selector has an opinion about resolving a component with the 
            specified service and key.
            </summary>
            <param name="key">The service key - can be null</param>
            <param name="service">The service interface that we want to resolve</param>
        </member>
        <member name="M:Castle.MicroKernel.IHandlerSelector.SelectHandler(System.String,System.Type,Castle.MicroKernel.IHandler[])">
            <summary>
            Select the appropriate handler from the list of defined handlers.
            The returned handler should be a member from the <paramref name="handlers"/> array.
            </summary>
            <param name="key">The service key - can be null</param>
            <param name="service">The service interface that we want to resolve</param>
            <param name="handlers">The defined handlers</param>
            <returns>The selected handler, or null</returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem">
            <summary>
            When requesting a component by service, KeySearchNamingSubSystem first 
            determines if more than one component has been registered for that service.  
            If not, Default resolution occurs.  If so, all of the registered keys for 
            that service are processed through the provided Predicate to determine which 
            key to use for service resolution.  If no Predicate matches, the default 
            resolution occurs.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.#ctor(System.Predicate{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem"/> class.
            </summary>
            <param name="keyPredicate">The key predicate.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.Register(System.String,Castle.MicroKernel.IHandler)">
            <summary>
            Registers the given handler with the give key.
            </summary>
            <param name="key">The key.</param>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.UnRegister(System.String)">
            <summary>
            Unregisters the handler associated with the given key
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.UnRegister(System.Type)">
            <summary>
            Unregisters the handler associated with the given service
            </summary>
            <param name="service">The service.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.GetHandler(System.Type)">
            <summary>
            Executes the Predicate against all keys for the registered service to 
            determine which component to return.
            </summary>
            <param name="service">The service.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.NamingPartsSubSystem">
            <summary>
            Alternative <see cref="T:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem"/> implementation.
            Extends the default implementation replacing the 
            key support with a more complete ComponentName. Supports
            queries.
            </summary>
            <example>
            The user must register components using the following construction
            <code>
              service:properties
            </code>
            Where properties is a list of key value pairs (comma separated). Example:
            <code>
              protocol:secure=true,version=1.2
            </code>
            The user can then query for components using the same construction:
            <code>
              protocol:secure=true
            </code>
            Or to return all:
            <code>
              protocol:*
            </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.DefaultResourceSubSystem">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem">
            <summary>
            An implementation of <c>a</c> should 
            be able to return instances of <see cref="T:Castle.Core.Resource.IResource"/>
            for a given resource identifier.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystemConstants">
            <summary>
            Holds the keys used by Kernel to register/request 
            a subsystem.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConfigurationStoreKey">
            <summary>
            Key used for the configuration store subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConversionManagerKey">
            <summary>
            Key used for the conversion manager
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.NamingKey">
            <summary>
            Key used for the naming subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ResourceKey">
            <summary>
            Key used for the resource subsystem
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Util.ReferenceComparer">
            <summary>
            Compares if the reference of two objects are equals.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Util.ReferenceExpressionUtil">
            <summary>
            Summary description for ReferenceExpressionUtil.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Adapters.ComponentModel.IContainerAdapter">
            <summary>
            Integrates the <see cref="T:Castle.Windsor.WindsorContainer"/> to the System.ComponentModel
            and System.ComponentMode.Design infrastructure.
            </summary>
            <seealso cref="T:System.ComponentModel.IComponent"/>
            <seealso cref="T:System.ComponentModel.IContainer"/>
            <seealso cref="T:System.ComponentModel.Design.IServiceContainer"/>
        </member>
        <member name="T:Castle.Windsor.IContainerAccessor">
            <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <para>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </para>
            </summary>
        </member>
        <member name="T:Castle.Windsor.Adapters.ComponentModel.ServiceCreatorCallbackActivator">
            <summary>
            Custom activator to create the instance on demand.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.AppDomain.CastleSectionHandler">
            <summary>
            Implementation of <see cref="T:System.Configuration.IConfigurationSectionHandler"/>.
            Do not support configuration inheritance.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.IConfigurationInterpreter">
            <summary>
            Interpreter of a specific language to describe 
            configuration nodes in a hierarchical manner.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.IConfigurationInterpreter.ProcessResource(Castle.Core.Resource.IResource,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
            Should obtain the contents from the resource,
            interpret it and populate the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/>
            accordingly.
            </summary>
            <param name="resource"></param>
            <param name="store"></param>
        </member>
        <member name="P:Castle.Windsor.Configuration.IConfigurationInterpreter.EnvironmentName">
            <summary>
            Gets or sets the name of the environment.
            </summary>
            <value>The name of the environment.</value>
        </member>
        <member name="P:Castle.Windsor.Configuration.IConfigurationInterpreter.Source">
            <summary>
            Exposes the reference to <see cref="T:Castle.Core.Resource.IResource"/>
            which the interpreter is likely to hold
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter">
            <summary>
            Provides common methods for those who wants 
            to implement <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/>
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.ProcessResource(Castle.Core.Resource.IResource,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
            Should obtain the contents from the resource,
            interpret it and populate the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/>
            accordingly.
            </summary>
            <param name="resource"></param>
            <param name="store"></param>
        </member>
        <member name="P:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.Source">
            <summary>
            Exposes the reference to <see cref="T:Castle.Core.Resource.IResource"/>
            which the interpreter is likely to hold
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.EnvironmentName">
            <summary>
            Gets or sets the name of the environment.
            </summary>
            <value>The name of the environment.</value>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter">
            <summary>
            Reads the configuration from a XmlFile. Sample structure:
            <code>
            &lt;configuration&gt;
              &lt;facilities&gt;
                &lt;facility id="myfacility"&gt;
                
                &lt;/facility&gt;
              &lt;/facilities&gt;
              
              &lt;components&gt;
                &lt;component id="component1"&gt;
                
                &lt;/component&gt;
              &lt;/components&gt;
            &lt;/configuration&gt;
            </code>
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter"/> class.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter"/> class.
            </summary>
            <param name="filename">The filename.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor(Castle.Core.Resource.IResource)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter"/> class.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="P:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.Kernel">
            <summary>
            Gets or sets the kernel.
            </summary>
            <value>The kernel.</value>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine"/> class.
            </summary>
            <param name="environmentName">Name of the environment.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.#ctor(System.String,Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine"/> class.
            </summary>
            <param name="environmentName">Name of the environment.</param>
            <param name="resourceSubSystem">The resource sub system.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.DispatchProcessAll(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList)">
            <summary>
            Processes the element.
            </summary>
            <param name="nodeList">The element.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.DispatchProcessCurrent(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList)">
            <summary>
            Processes the element.
            </summary>
            <param name="nodeList">The element.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorNodeList.CloneNodeList(System.Xml.XmlNodeList)">
            <summary>
            Make a shallow copy of the nodeList.
            </summary>
            <param name="nodeList">The nodeList to be copied.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor.Accept(System.Xml.XmlNode)">
            <summary>
            Accepts the specified node.
            Check if node has the same name as the processor and the node.NodeType
            is in the AcceptNodeTypes List
            </summary>
            <param name="node">The node.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor.GetNodeAsElement(System.Xml.XmlElement,System.Xml.XmlNode)">
            <summary>
            Convert and return child parameter into an XmlElement
            An exception will be throw in case the child node cannot be converted
            </summary>
            <param name="element">Parent node</param>
            <param name="child">Node to be converted</param>
            <returns>child node as XmlElement</returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AttributesElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
            
            </summary>
            <param name="nodeList"></param>
            <param name="engine"></param>
            <example>
            <code>
            	<properties>
            		<attributes>
            			<myAttribute>attributeValue</myAttribute>
            		</attributes>
            		<myProperty>propertyValue</myProperty>
            	</properties>
            </code>
            </example>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
            Processes the specified node list.
            </summary>
            <param name="nodeList">The node list.</param>
            <param name="engine">The engine.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultElementProcessor.ProcessAttributes(System.Xml.XmlElement,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
            Processes element attributes.
            if the attribute is include will append to the element
            all contents from the file.
            if the attribute has a property reference the reference will be
            expanded
            </summary>
            <param name="element">The element.</param>
            <param name="engine"></param>
        </member>
        <member name="F:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor.PropertyValidationRegExp">
            <summary>
            Properties names can contain a-zA-Z0-9_. 
            i.e. #!{ my_node_name } || #{ my.node.name }
            spaces are trimmed
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor.ProcessString(System.Xml.XmlNode,System.String,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
            Processes the string.
            </summary>
            <param name="node">The node.</param>
            <param name="value">The value.</param>
            <param name="engine">The context.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.IncludeElementProcessor.Accept(System.Xml.XmlNode)">
            <summary>
            Accepts the specified node.
            Check if node has the same name as the processor and the node.NodeType
            is in the AcceptNodeTypes List
            NOTE: since the BatchRegistrationFacility already uses an include
            element we will distinguish between both by looking for the presence of an uri attribute
            we should revisit this later by using xml-namespaces
            </summary>
            <param name="node">The node.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.PropertiesElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
            
            </summary>
            <param name="nodeList"></param>
            <param name="engine"></param>
            <example>
            <code>
            	<properties>
            		<attributes>
            			<myAttribute>attributeValue</myAttribute>
            		</attributes>
            		<myProperty>propertyValue</myProperty>
            	</properties>
            </code>
            </example>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor"/> class.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor(System.String,Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor"/> class.
            </summary>
            <param name="environmentName">Name of the environment.</param>
            <param name="resourceSubSystem">The resource sub system.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor"/> class.
            </summary>
        </member>
        <member name="T:Castle.Windsor.IEnvironmentInfo">
            <summary>
            Gets the environment information (name). Implementors should 
            use to define their environments and how those affect the configuration.
            </summary>
        </member>
        <member name="M:Castle.Windsor.IEnvironmentInfo.GetEnvironmentName">
            <summary>
            Gets the name of the environment.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.Configuration.FromAppConfig">
            <summary>
            Installs all the components from the App.Config file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.Configuration.FromXmlFile(System.String)">
            <summary>
            Installs all the component from the xml configuration file.
            </summary>
            <param name="file">The xml configuration file.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.Configuration.FromXml(Castle.Core.Resource.IResource)">
            <summary>
            Installs all the component from the xml configuration.
            </summary>
            <param name="resource">The xml configuration resource.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Installer.EnvironmentDelegate">
            <summary>
            Delegate to provide environment name.
            </summary>
            <returns>The environment name.</returns>
        </member>
        <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
            Initializes a new instance of the ConfigurationInstaller class.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.Environment(System.String)">
            <summary>
            Sets the configuration environment name.
            </summary>
            <param name="environmentName">The environment name.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.Environment(Castle.Windsor.Installer.EnvironmentDelegate)">
            <summary>
            Set the configuration environment strategy.
            </summary>
            <param name="environment">The environment strategy.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Installer.DefaultComponentInstaller">
            <summary>
            Default <see cref="T:Castle.Windsor.IComponentsInstaller"/> implementation.
            </summary>
        </member>
        <member name="T:Castle.Windsor.IComponentsInstaller">
            <summary>
            Installs the components and facilities based on the
            information on the configuration store.
            </summary>
        </member>
        <member name="M:Castle.Windsor.IComponentsInstaller.SetUp(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
            Perform installation.
            </summary>
            <param name="container">Target container</param>
            <param name="store">Configuration store</param>
        </member>
        <member name="M:Castle.Windsor.Installer.DefaultComponentInstaller.SetUp(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
            Perform installation.
            </summary>
            <param name="container">Target container</param>
            <param name="store">Configuration store</param>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Containing(System.Type)">
            <summary>
            Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Containing(System.Type,Castle.Windsor.Installer.InstallerFactory)">
            <summary>
            Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Containing``1">
            <summary>
            Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Containing``1(Castle.Windsor.Installer.InstallerFactory)">
            <summary>
            Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Instance(System.Reflection.Assembly)">
            <summary>
            Scans the specified assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Instance(System.Reflection.Assembly,Castle.Windsor.Installer.InstallerFactory)">
            <summary>
            Scans the specified assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Named(System.String)">
            <summary>
            Scans the assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Named(System.String,Castle.Windsor.Installer.InstallerFactory)">
            <summary>
            Scans the assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.This">
            <summary>
            Scans assembly that contains code calling this method for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, 
            instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.This(Castle.Windsor.Installer.InstallerFactory)">
            <summary>
            Scans assembly that contains code calling this method for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.InDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
            <summary>
            Scans assemblies in directory specified by <paramref name="filter"/> for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.InDirectory(Castle.MicroKernel.Registration.AssemblyFilter,Castle.Windsor.Installer.InstallerFactory)">
            <summary>
            Scans assemblies in directory specified by <paramref name="filter"/> for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <param name="filter"></param>
            <param name="installerFactory"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Installer.InstallerFactory">
            <summary>
            Helper class used by <see cref="T:Castle.Windsor.Installer.FromAssembly"/> to filter/order and instantiate <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/> implementations
            </summary>
        </member>
        <member name="M:Castle.Windsor.Installer.InstallerFactory.CreateInstance(System.Type)">
            <summary>
            Performs custom instantiation of given <param name="installerType"/>
            </summary>
            <remarks>
            Default implementation uses public parameterless constructor to create the instance.
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Installer.InstallerFactory.Select(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Performs custom filtering/ordering of given set of types.
            </summary>
            <param name="installerTypes">Set of concrete class types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/> interface.</param>
            <returns>Transformed <paramref name="installerTypes"/>.</returns>
            <remarks>Default implementation simply returns types passed into it.</remarks>
        </member>
        <member name="T:Castle.Windsor.IWindsorContainer">
            <summary>
              The <c>IWindsorContainer</c> interface exposes all the 
              functionality the Windsor implements.
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
              Registers a subcontainer. The components exposed
              by this container will be accessible from subcontainers.
            </summary>
            <param name = "childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
              Registers a facility within the container.
            </summary>
            <param name="key">The key by which the <see cref="T:Castle.MicroKernel.IFacility"/> gets indexed.</param>
            <param name="facility">The <see cref="T:Castle.MicroKernel.IFacility"/> to add to the container.</param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.String)">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.String,System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.String,System.Func{``0,System.Object})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.Func{``0,System.Object})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.GetChildContainer(System.String)">
            <summary>
              Gets a child container instance by name.
            </summary>
            <param name = "name">The container's name.</param>
            <returns>The child container instance or null</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])">
            <summary>
              Installs the components provided by the <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>s
              with the <see cref="T:Castle.Windsor.IWindsorContainer"/>.
              <param name="installers">The component installers.</param>
              <returns>The container.</returns>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
              Registers the components provided by the <see cref="T:Castle.MicroKernel.Registration.IRegistration"/>s
              with the <see cref="T:Castle.Windsor.IWindsorContainer"/>.
              <para/>
              Create a new registration using <see cref="T:Castle.MicroKernel.Registration.Component"/>.For() or <see cref="T:Castle.MicroKernel.Registration.AllTypes"/>.
            </summary>
            <example>
              <code>
                container.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;());
              </code>
            </example>
            <param name="registrations">The component registrations.</param>
            <returns>The container.</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Release(System.Object)">
            <summary>
              Releases a component instance
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.RemoveChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
              Remove a child container
            </summary>
            <param name = "childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type,System.Object)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <returns>The component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "arguments"></param>
            <returns>The component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.Object)">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "argumentsAsAnonymousType"></param>
            <returns>The component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key">Component's key</param>
            <typeparam name = "T">Service type</typeparam>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "key">Component's key</param>
            <param name = "arguments"></param>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "key">Component's key</param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1">
            <summary>
              Resolve all valid components that match this type.
            </summary>
            <typeparam name = "T">The service type</typeparam>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type)">
            <summary>
              Resolve all valid components that match this service
              <param name = "service">the service to match</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type,System.Collections.IDictionary)">
            <summary>
              Resolve all valid components that match this service
              <param name = "service">the service to match</param>
              <param name = "arguments">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type,System.Object)">
            <summary>
              Resolve all valid components that match this service
              <param name = "service">the service to match</param>
              <param name = "argumentsAsAnonymousType">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
              Resolve all valid components that match this type.
              <typeparam name = "T">The service type</typeparam>
              <param name = "arguments">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1(System.Object)">
            <summary>
              Resolve all valid components that match this type.
              <typeparam name = "T">The service type</typeparam>
              <param name = "argumentsAsAnonymousType">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Kernel">
            <summary>
              Returns the inner instance of the MicroKernel
            </summary>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Name">
            <summary>
              Gets the container's name
            </summary>
            <remarks>
              Only useful when child containers are being used
            </remarks>
            <value>The container's name.</value>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Parent">
            <summary>
              Gets or sets the parent container if this instance
              is a sub container.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Proxy.AbstractProxyFactory.ObtainInterceptors(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext)">
            <summary>
            Obtains the interceptors associated with the component.
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
            <param name="context">The creation context</param>
            <returns>interceptors array</returns>
        </member>
        <member name="T:Castle.Windsor.Proxy.DefaultProxyFactory">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/> relies 
            on DynamicProxy to expose proxy capabilities.
            </summary>
            <remarks>
            Note that only virtual methods can be intercepted in a 
            concrete class. However, if the component 
            was registered with a service interface, we proxy
            the interface and the methods don't need to be virtual,
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.#ctor">
            <summary>
            Constructs a DefaultProxyFactory
            </summary>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])">
            <summary>
            Creates the proxy for the supplied component.
            </summary>
            <param name="kernel">The kernel.</param>
            <param name="target">The target.</param>
            <param name="model">The model.</param>
            <param name="constructorArguments">The constructor arguments.</param>
            <param name="context">The creation context</param>
            <returns>The component proxy.</returns>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.RequiresTargetInstance(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Determines if the component requires a target instance for proxying.
            </summary>
            <param name="kernel">The kernel.</param>
            <param name="model">The model.</param>
            <returns>true if an instance is required.</returns>
        </member>
        <member name="T:Castle.Windsor.WindsorContainer">
            <summary>
              Implementation of <see cref="T:Castle.Windsor.IWindsorContainer"/>
              which delegates to <see cref="T:Castle.MicroKernel.IKernel"/> implementation.
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor">
            <summary>
              Constructs a container without any external 
              configuration reference
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
              Constructs a container using the specified 
              <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/> implementation.
            </summary>
            <param name="store">The instance of an <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/> implementation.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
              Constructs a container using the specified 
              <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/> implementation.
            </summary>
            <param name="interpreter">The instance of an <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/> implementation.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter,Castle.Windsor.IEnvironmentInfo)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer"/> class.
            </summary>
            <param name="interpreter">The interpreter.</param>
            <param name="environmentInfo">The environment info.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer"/> class using a
              xml file to configure it.
              <para>
                Equivalent to the use of <c>new WindsorContainer(new XmlInterpreter(xmlFile))</c>
              </para>
            </summary>
            <param name="xmlFile">The XML file.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
            <summary>
              Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel"/>
              implementation. Rarely used.
            </summary>
            <remarks>
              This constructs sets the Kernel.ProxyFactory property to
              <c>Proxy.DefaultProxyFactory</c>
            </remarks>
            <param name="kernel">Kernel instance</param>
            <param name="installer">Installer instance</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String,Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
            <summary>
              Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel"/>
              implementation. Rarely used.
            </summary>
            <remarks>
              This constructs sets the Kernel.ProxyFactory property to
              <c>Proxy.DefaultProxyFactory</c>
            </remarks>
            <param name="name">Container's name</param>
            <param name="kernel">Kernel instance</param>
            <param name="installer">Installer instance</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IProxyFactory)">
            <summary>
              Constructs with a given <see cref="T:Castle.MicroKernel.IProxyFactory"/>.
            </summary>
            <param name="proxyFactory">A instance of an <see cref="T:Castle.MicroKernel.IProxyFactory"/>.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.IWindsorContainer,Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
              Constructs a container assigning a parent container 
              before starting the dependency resolution.
            </summary>
            <param name="parent">The instance of an <see cref="T:Castle.Windsor.IWindsorContainer"/></param>
            <param name="interpreter">The instance of an <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/> implementation</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String,Castle.Windsor.IWindsorContainer,Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer"/> class.
            </summary>
            <param name="name">The container's name.</param>
            <param name="parent">The parent.</param>
            <param name="interpreter">The interpreter.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Dispose">
            <summary>
              Executes Dispose on underlying <see cref="T:Castle.MicroKernel.IKernel"/>
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.GetService(System.Type)">
            <summary>
              Gets the service object of the specified type.
            </summary>
            <returns>
              A service object of type serviceType.
            </returns>
            <param name = "serviceType">An object that specifies the type of service object to get. </param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.GetService``1">
            <summary>
              Gets the service object of the specified type.
            </summary>
            <returns>
              A service object of type serviceType.
            </returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
              Registers a subcontainer. The components exposed
              by this container will be accessible from subcontainers.
            </summary>
            <param name = "childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
              Registers a facility within the kernel.
            </summary>
            <param name = "key"></param>
            <param name = "facility"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.String)">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.String,System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.String,System.Func{``0,System.Object})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.Func{``0,System.Object})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.GetChildContainer(System.String)">
            <summary>
              Gets a child container instance by name.
            </summary>
            <param name = "name">The container's name.</param>
            <returns>The child container instance or null</returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])">
            <summary>
              Installs the components provided by the <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>s
              with the <see cref="T:Castle.Windsor.IWindsorContainer"/>.
              <param name="installers">The component installers.</param>
              <returns>The container.</returns>
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
              Registers the components described by the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/>s
              with the <see cref="T:Castle.Windsor.IWindsorContainer"/>.
              <param name="registrations">The component registrations.</param>
              <returns>The container.</returns>
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Release(System.Object)">
            <summary>
              Releases a component instance
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.RemoveChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
              Removes (unregisters) a subcontainer.  The components exposed by this container
              will no longer be accessible to the child container.
            </summary>
            <param name = "childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type,System.Object)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T"></typeparam>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.Object)">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T"></typeparam>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1">
            <summary>
              Resolve all valid components that match this type.
            </summary>
            <typeparam name = "T">The service type</typeparam>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
              Resolve all valid components that match this type.
              <typeparam name = "T">The service type</typeparam>
              <param name = "arguments">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1(System.Object)">
            <summary>
              Resolve all valid components that match this type.
              <typeparam name = "T">The service type</typeparam>
              <param name = "argumentsAsAnonymousType">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Kernel">
            <summary>
              Returns the inner instance of the MicroKernel
            </summary>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Name">
            <summary>
              Gets the container's name
            </summary>
            <remarks>
              Only useful when child containers are being used
            </remarks>
            <value>The container's name.</value>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Parent">
            <summary>
              Gets or sets the parent container if this instance
              is a sub container.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter">
            <summary>
            Implementation of <see cref="T:Castle.Windsor.Adapters.ComponentModel.IContainerAdapter"/> that assumes ownership of the
            wrapped <see cref="T:Castle.Windsor.IWindsorContainer"/>.  If this adapter is disposed, the underlying
            <see cref="T:Castle.Windsor.IWindsorContainer"/> is diposed as well.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper">
            <summary>
            Implementation of <see cref="T:Castle.Windsor.Adapters.ComponentModel.IContainerAdapter"/> that does not assume ownership of the
            wrapped <see cref="T:Castle.Windsor.IWindsorContainer"/>. 
            </summary>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.#ctor(Castle.Windsor.IWindsorContainer)">
            <summary>
            Constructs an initial ContainerWrapper.
            </summary>
            <param name="container">The <see cref="T:Castle.Windsor.IWindsorContainer"/> to adapt.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.#ctor(Castle.Windsor.IWindsorContainer,System.IServiceProvider)">
            <summary>
            Constructs an initial ContainerWrapper.
            </summary>
            <param name="container">The <see cref="T:Castle.Windsor.IWindsorContainer"/> to adapt.</param>
            <param name="parentProvider">The parent <see cref="T:System.IServiceProvider"/>.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Add(System.ComponentModel.IComponent)">
            <summary>
            Adds the specified <see cref="T:System.ComponentModel.IComponent"/> to the <see cref="T:System.ComponentModel.IContainer"/> at the end of the list.
            </summary>
            <param name="component">The <see cref="T:System.ComponentModel.IComponent"/> to add.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Add(System.ComponentModel.IComponent,System.String)">
            <summary>
            Adds the specified <see cref="T:System.ComponentModel.IComponent"/> to the <see cref="T:System.ComponentModel.IContainer"/> at the end of the list,
            and assigns a name to the component.
            </summary>
            <param name="component">The <see cref="T:System.ComponentModel.IComponent"/> to add.</param>
            <param name="name">The unique, case-insensitive name to assign to the component, or null.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Remove(System.ComponentModel.IComponent)">
            <summary>
            Removes a component from the <see cref="T:System.ComponentModel.IContainer"/>.
            </summary>
            <param name="component">The <see cref="T:System.ComponentModel.IComponent"/> to remove</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.GetService(System.Type)">
            <summary>
            Gets the service object of the specified type.
            </summary>
            <param name="serviceType">The type of service.</param>
            <returns>An object implementing service, or null.</returns>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.AddService(System.Type,System.Object)">
            <summary>
            Adds the specified service to the service container.
            </summary>
            <param name="serviceType">The type of service to add.</param>
            <param name="serviceInstance">The instance of the service to add.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.AddService(System.Type,System.ComponentModel.Design.ServiceCreatorCallback)">
            <summary>
            Adds the specified service to the service container.
            </summary>
            <param name="serviceType">The type of service to add.</param>
            <param name="callback">A callback object that is used to create the service.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.AddService(System.Type,System.Object,System.Boolean)">
            <summary>
            Adds the specified service to the service container, and optionally
            promotes the service to any parent service containers.
            </summary>
            <param name="serviceType">The type of service to add.</param>
            <param name="serviceInstance">The instance of the service to add.</param>
            <param name="promote">true to promote this request to any parent service containers.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.AddService(System.Type,System.ComponentModel.Design.ServiceCreatorCallback,System.Boolean)">
            <summary>
            Adds the specified service to the service container, and optionally 
            promotes the service to parent service containers.
            </summary>
            <param name="serviceType">The type of service to add.</param>
            <param name="callback">A callback object that is used to create the service.</param>
            <param name="promote">true to promote this request to any parent service containers.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.RemoveService(System.Type)">
            <summary>
            Removes the specified service type from the service container.
            </summary>
            <param name="serviceType">The type of service to remove.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.RemoveService(System.Type,System.Boolean)">
            <summary>
            Removes the specified service type from the service container, 
            and optionally promotes the service to parent service containers.
            </summary>
            <param name="serviceType">The type of service to remove.</param>
            <param name="promote">true to promote this request to any parent service containers.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.IsIntrinsicService(System.Type)">
            <summary>
            Determines if the service type represents an intrinsic service.
            </summary>
            <param name="serviceType">The type of service to remove.</param>
            <returns>true if the service type is an intrinsic service.</returns>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.HasService(System.Type)">
            <summary>
            Determines if the specified service type exists in the service container.
            </summary>
            <param name="serviceType">The type of service to remove.</param>
            <returns>true if the service type exists.</returns>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Dispose">
            <summary>
            Releases the resources used by the component.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by the component.
            </summary>
            <param name="disposing">true if disposing.</param>
        </member>
        <member name="P:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Site">
            <summary>
            Gets or sets the <see cref="T:System.ComponentModel.ISite"/> associated with the <see cref="T:System.ComponentModel.IComponent"/>.
            </summary>
        </member>
        <member name="E:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Disposed">
            <summary>
            Event that notifies the disposal of the <see cref="T:System.ComponentModel.IComponent"/>.
            </summary>
        </member>
        <member name="P:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Components">
            <summary>
            Gets all the components in the <see cref="T:System.ComponentModel.IContainer"/>.
            </summary>
        </member>
        <member name="P:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Container">
            <summary>
            Gets the adapted <see cref="T:Castle.Windsor.IWindsorContainer"/>
            </summary>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter.#ctor">
            <summary>
            Constructs a default ContainerAdapter.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter.#ctor(System.IServiceProvider)">
            <summary>
            Constructs a chained ContainerAdapter.
            </summary>
            <param name="parentProvider">The parent <see cref="T:System.IServiceProvider"/>.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter.#ctor(Castle.Windsor.IWindsorContainer)">
            <summary>
            Constructs an initial ContainerAdapter.
            </summary>
            <param name="container">The <see cref="T:Castle.Windsor.IWindsorContainer"/> to adapt.</param>
        </member>
        <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter.#ctor(Castle.Windsor.IWindsorContainer,System.IServiceProvider)">
            <summary>
            Constructs an initial ContainerAdapter.
            </summary>
            <param name="container">The <see cref="T:Castle.Windsor.IWindsorContainer"/> to adapt.</param>
            <param name="parentProvider">The parent <see cref="T:System.IServiceProvider"/>.</param>
        </member>
    </members>
</doc>
